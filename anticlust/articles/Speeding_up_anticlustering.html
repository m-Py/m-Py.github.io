<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Speeding up anticlustering • anticlust</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Speeding up anticlustering">
<meta property="og:description" content="anticlust">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">anticlust</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">0.6.4</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/How_to_cite_anticlust.html">How to cite anticlust</a>
    </li>
    <li>
      <a href="../articles/Speeding_up_anticlustering.html">Speeding up anticlustering</a>
    </li>
    <li>
      <a href="../articles/stimulus-selection.html">Using the R package anticlust for stimulus selection in experiments</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/m-Py/anticlust/" class="external-link">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Speeding up anticlustering</h1>
                        <h4 data-toc-skip class="author">Martin
Papenberg</h4>
            
      
      <small class="dont-index">Source: <a href="https://github.com/m-Py/anticlust/blob/HEAD/vignettes/Speeding_up_anticlustering.Rmd" class="external-link"><code>vignettes/Speeding_up_anticlustering.Rmd</code></a></small>
      <div class="hidden name"><code>Speeding_up_anticlustering.Rmd</code></div>

    </div>

    
    
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/m-Py/anticlust" class="external-link">anticlust</a></span><span class="op">)</span></span></code></pre></div>
<p>This vignette documents various ways by which the speed of the
anticlustering method implemented in the <code>anticlust</code> package
can be adjusted. Speedup is particularly useful for large data sets when
the default anticlustering algorithm becomes too slow. A fast method may
also be desirable for testing purposes, even if the final anticlustering
is based on a slower method.</p>
<div class="section level2">
<h2 id="the-exchange-algorithm">The exchange algorithm<a class="anchor" aria-label="anchor" href="#the-exchange-algorithm"></a>
</h2>
<p>The default anticlustering algorithm works by exchanging data points
between clusters in such a way that exchanges improve the anticlustering
objective as much as possible. Details on the exchange method may also
be found in Papenberg and Klau (2021; <a href="https://doi.org/10.1037/met0000301" class="external-link uri">https://doi.org/10.1037/met0000301</a>), Papenberg (2023; <a href="https://doi.org/10.31234/osf.io/7jw6v" class="external-link uri">https://doi.org/10.31234/osf.io/7jw6v</a>), or the
<code>anticlust</code> documentation (<code><a href="../reference/anticlustering.html">?anticlustering</a></code>).
Basically, running more exchanges tends to improve the results, but the
improvements are diminishing with many repetitions—especially for large
data sets. So, to speed up <code><a href="../reference/anticlustering.html">anticlustering()</a></code>, we can reduce
the number of exchanges. Here we will learn how to do that. However,
first we learn how to slow down anticlustering. Slowing down can lead to
better results and is recommended if you have the time.</p>
<div class="section level3">
<h3 id="slowing-down">Slowing down<a class="anchor" aria-label="anchor" href="#slowing-down"></a>
</h3>
<p>The default exchange algorithm
(<code>anticlustering(..., method = "exchange")</code>) iterates through
all input elements and attempts to improve the anticlustering by
swapping each input element with a element that is currently assigned to
a different cluster. No swap is conducted if an element cannot be
swapped in such a way that the anticlustering objective is improved. The
process stops after all possible exchanges have been evaluated for each
element. When the number of input elements is <span class="math inline">\(N\)</span>, this process leads to approximately
<span class="math inline">\(N^2\)</span>—or <span class="math inline">\(O(N^2)\)</span>—attempted exchanges, because each
element is swapped with all elements that are currently assigned to a
different cluster. To give a concrete example, when having <span class="math inline">\(N = 100\)</span> data points and <span class="math inline">\(K = 4\)</span> equal-sized groups, 75 swaps are
evaluated for each element and the best swap is realized. This leads to
100 * 75 = 7500 exchanges that have to be conducted during the entire
exchange algorithm, and for each exchange the objective function has to
be re-evaluated. This is less exchanges than <span class="math inline">\(N^2 = 100^2 = 10000\)</span> because we skip
exchanges with the 25 elements that are currently in the same cluster
(including itself). However, according to the <a href="https://en.wikipedia.org/wiki/Big_O_notation" class="external-link">Big O notation</a>,
we would still classify the number of exchanges as <span class="math inline">\(O(N^2)\)</span>, independent of the number of
groups. Thus, the total theoretical run time of the exchange method is
<span class="math inline">\(O(N^2)\)</span> multiplied with the effort
needed to compute an anticlustering objective.</p>
<p>The results of the exchange method can be improved by not stopping
after a single iteration through the data set; instead we may repeat the
process until no single exchange is able to further improve the
anticlustering objective, i.e., until a local maximum is found. This
happens if we use
<code>anticlustering(..., method = "local-maximum")</code>. This method
corresponds to the algorithm “LCW” in Weitz and Lakshminarayanan (1998).
Using the local maximum method leads to more exchanges and thus to
longer running time, but also better results than the default exchange
method.</p>
<p>Let’s compare the two exchange methods with regard to their running
time, using the iris data set, which contains 150 elements.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span></span>
<span><span class="va">K</span> <span class="op">&lt;-</span> <span class="fl">3</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="fu"><a href="../reference/anticlustering.html">anticlustering</a></span><span class="op">(</span><span class="va">iris</span><span class="op">[</span>, <span class="op">-</span><span class="fl">5</span><span class="op">]</span>, K <span class="op">=</span> <span class="va">K</span>, method <span class="op">=</span> <span class="st">"exchange"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;   0.012   0.000   0.012</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="fu"><a href="../reference/anticlustering.html">anticlustering</a></span><span class="op">(</span><span class="va">iris</span><span class="op">[</span>, <span class="op">-</span><span class="fl">5</span><span class="op">]</span>, K <span class="op">=</span> <span class="va">K</span>, method <span class="op">=</span> <span class="st">"local-maximum"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;   0.055   0.000   0.056</span></span></code></pre></div>
<p>Depending on how many iterations are needed, the default exchange
method can be much faster than the local maximum method. Generally I
would recommend to use <code>method = "local-maximum"</code> for better
results, but if speed is an issue, stick with the default.</p>
<p>To slow down even more: The exchange process may be restarted several
times, each time using a different initial grouping of the elements.
This is accomplished when specifying the <code>repetitions</code>
argument, which defaults to 1 repetition of the exchange / local maximum
algorithm. Thus, for better results, we may increase the number of
repetitions:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span></span>
<span><span class="va">K</span> <span class="op">&lt;-</span> <span class="fl">3</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="fu"><a href="../reference/anticlustering.html">anticlustering</a></span><span class="op">(</span><span class="va">iris</span><span class="op">[</span>, <span class="op">-</span><span class="fl">5</span><span class="op">]</span>, K <span class="op">=</span> <span class="va">K</span>, method <span class="op">=</span> <span class="st">"exchange"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;   0.011   0.000   0.011</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="fu"><a href="../reference/anticlustering.html">anticlustering</a></span><span class="op">(</span><span class="va">iris</span><span class="op">[</span>, <span class="op">-</span><span class="fl">5</span><span class="op">]</span>, K <span class="op">=</span> <span class="va">K</span>, method <span class="op">=</span> <span class="st">"local-maximum"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;   0.045   0.000   0.045</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="fu"><a href="../reference/anticlustering.html">anticlustering</a></span><span class="op">(</span><span class="va">iris</span><span class="op">[</span>, <span class="op">-</span><span class="fl">5</span><span class="op">]</span>, K <span class="op">=</span> <span class="va">K</span>, method <span class="op">=</span> <span class="st">"local-maximum"</span>, repetitions <span class="op">=</span> <span class="fl">10</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;   0.473   0.000   0.473</span></span></code></pre></div>
<p>In this case, sticking with the default leads to run times that are
much much faster. Still, if your data set is not too large, using
several repetitions may be useful (but you can judge yourself via the
results). The good news is that fewer exchanges may be enough in large
data sets: anticlustering generally becomes easier with more data.</p>
</div>
<div class="section level3">
<h3 id="getting-fast">Getting fast<a class="anchor" aria-label="anchor" href="#getting-fast"></a>
</h3>
<p>If the default exchange method is not fast enough for your taste,
there is an additional “hidden” method to make the
<code><a href="../reference/anticlustering.html">anticlustering()</a></code> function run faster. This approach is
documented here.</p>
<p>For the exchange method to terminate faster, it is possible to reduce
the number of attempted exchanges per element. By default, the exchange
method evaluates each possible exchange with all elements that are
currently assigned to a different cluster. We can restrict the number of
exchanges on a fixed value using the following “hack”.</p>
<p>The first step that I am using here is not strictly necessary—in the
next section, we will learn more about what this accomplishes—but let’s
create the initial clusters before calling
<code><a href="../reference/anticlustering.html">anticlustering()</a></code>. This grouping is the basis on which the
exchange procedure starts to improve the anticlustering:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">N</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">iris</span><span class="op">)</span></span>
<span><span class="va">initial_clusters</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep_len</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">K</span>, <span class="va">N</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">initial_clusters</span></span>
<span><span class="co">#&gt;   [1] 2 3 3 3 2 2 2 3 1 2 3 1 1 2 2 3 3 2 2 1 3 1 2 1 3 3 1 1 1 3 2 2 2 1 3 3 2</span></span>
<span><span class="co">#&gt;  [38] 1 2 1 2 2 2 3 1 3 3 3 1 3 3 3 2 2 1 1 2 1 1 2 1 2 2 1 1 3 3 3 2 3 3 1 1 2</span></span>
<span><span class="co">#&gt;  [75] 2 1 3 3 3 1 3 2 1 2 1 3 1 1 2 1 1 2 1 3 2 3 2 1 3 3 2 1 3 1 2 1 3 1 3 3 1</span></span>
<span><span class="co">#&gt; [112] 1 1 3 3 2 2 3 2 2 3 2 1 2 3 2 1 1 3 3 1 2 3 2 1 1 2 3 1 3 1 3 2 2 1 2 2 1</span></span>
<span><span class="co">#&gt; [149] 3 2</span></span></code></pre></div>
<p>Now, the argument <code>categories</code> can be used to define which
elements serve as exchange partners for each other. Lets create random
groups of 10 elements that serve as exchange elements for each
other:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">n_exchange_partners</span> <span class="op">&lt;-</span> <span class="fl">10</span></span>
<span><span class="va">exchange_partners</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep_len</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="op">(</span><span class="va">N</span><span class="op">/</span><span class="va">n_exchange_partners</span><span class="op">)</span>, <span class="va">N</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">exchange_partners</span></span>
<span><span class="co">#&gt;   [1]  6  2  2  8 10  2  7 13  4  3 15 11  7  6  8 11  8  7 12 15  5 14  3  7  6</span></span>
<span><span class="co">#&gt;  [26]  8 13  2 15  5 11  2  9  7  4  6 10  7  1  8  3 14 11  2  8  9  6 15  9  3</span></span>
<span><span class="co">#&gt;  [51] 11  4  5  3 14  5 12 15 13  5  6 11 14  1  6 12 15 10  9 10  3  3 12  8 10</span></span>
<span><span class="co">#&gt;  [76]  5 12  4 13  8  6 15 14  1 13 11 11  1  9  4 13 12 12 10 15 11  3 13 10  1</span></span>
<span><span class="co">#&gt; [101] 14 10  5  9  7  3 14  4  5  4  2  3  9  1  9 15  2 12 11  5  4 10  9 12  7</span></span>
<span><span class="co">#&gt; [126]  1 13  7 10 14  2  9  2 12  6  1  6  1  5  1 13  8  7  8 14  4 13 15 14  4</span></span></code></pre></div>
<p>The variable <code>exchange_partners</code> now defines groups of
elements that are exchanged with each other. Only elements having the
same value in <code>exchange_partners</code> serve as exchange partners
for each other. Thus, each element is only swapped with 10 other
elements instead of all 150 elements.</p>
<p>Now let’s call anticlustering using the exchange partners we just
defined:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="fu"><a href="../reference/anticlustering.html">anticlustering</a></span><span class="op">(</span><span class="va">iris</span><span class="op">[</span>, <span class="op">-</span><span class="fl">5</span><span class="op">]</span>, K <span class="op">=</span> <span class="va">initial_clusters</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;   0.009   0.000   0.009</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="fu"><a href="../reference/anticlustering.html">anticlustering</a></span><span class="op">(</span><span class="va">iris</span><span class="op">[</span>, <span class="op">-</span><span class="fl">5</span><span class="op">]</span>, K <span class="op">=</span> <span class="va">initial_clusters</span>, categories <span class="op">=</span> <span class="va">exchange_partners</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;   0.003   0.000   0.004</span></span></code></pre></div>
<p>Well, there is not a lot going on here with this very small data set
(N = 150), so let’s do this for a larger data set with 1000 data
points.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">N</span> <span class="op">&lt;-</span> <span class="fl">1000</span></span>
<span><span class="va">M</span> <span class="op">&lt;-</span> <span class="fl">2</span></span>
<span><span class="va">K</span> <span class="op">&lt;-</span> <span class="fl">5</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">M</span><span class="op">*</span><span class="va">N</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="va">M</span><span class="op">)</span></span>
<span></span>
<span><span class="va">initial_clusters</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep_len</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">K</span>, <span class="va">N</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">n_exchange_partners</span> <span class="op">&lt;-</span> <span class="fl">10</span></span>
<span><span class="va">exchange_partners</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep_len</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="op">(</span><span class="va">N</span><span class="op">/</span><span class="va">n_exchange_partners</span><span class="op">)</span>, <span class="va">N</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="fu"><a href="../reference/anticlustering.html">anticlustering</a></span><span class="op">(</span><span class="va">data</span>, K <span class="op">=</span> <span class="va">initial_clusters</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;   3.286   0.000   3.286</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="fu"><a href="../reference/anticlustering.html">anticlustering</a></span><span class="op">(</span><span class="va">data</span>, K <span class="op">=</span> <span class="va">initial_clusters</span>, categories <span class="op">=</span> <span class="va">exchange_partners</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;   0.048   0.012   0.060</span></span></code></pre></div>
<p>The speedup is enormous! Note that this approach even reduces the
theoretical run time of the algorithm, because the number of exchanges
no longer depends on the size of the input data, but instead is given a
fixed value.</p>
</div>
<div class="section level3">
<h3 id="including-categorical-variables">Including categorical variables<a class="anchor" aria-label="anchor" href="#including-categorical-variables"></a>
</h3>
<p>The approach to speed up the anticlustering by requiring fewer
exchange partners used the <code>categories</code> argument. We should
now reflect how this was accomplished, and first note that the
<code>categories</code> argument usually has a different purpose: It is
used to evenly distribute a categorical variable across groups—we did
not care for that in the previous example.</p>
<p>For example, coming back to the iris data set, we may require to
evenly distribute the species of the iris plants across 5 groups of
plants:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">groups</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/anticlustering.html">anticlustering</a></span><span class="op">(</span><span class="va">iris</span><span class="op">[</span>, <span class="op">-</span><span class="fl">5</span><span class="op">]</span>, K <span class="op">=</span> <span class="fl">5</span>, categories <span class="op">=</span> <span class="va">iris</span><span class="op">$</span><span class="va">Species</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">groups</span>, <span class="va">iris</span><span class="op">$</span><span class="va">Species</span><span class="op">)</span></span>
<span><span class="co">#&gt;       </span></span>
<span><span class="co">#&gt; groups setosa versicolor virginica</span></span>
<span><span class="co">#&gt;      1     10         10        10</span></span>
<span><span class="co">#&gt;      2     10         10        10</span></span>
<span><span class="co">#&gt;      3     10         10        10</span></span>
<span><span class="co">#&gt;      4     10         10        10</span></span>
<span><span class="co">#&gt;      5     10         10        10</span></span></code></pre></div>
<p>How does the <code>categories</code> argument accomplish the even
spread of the species? First, the initial grouping of the elements is
not random, but instead a “stratified split”, which ensures that a
categorical variable occurs an equal number of times in each split.
<code>anticlust</code> has the function
<code><a href="../reference/categorical_sampling.html">categorical_sampling()</a></code> for this purpose. After conducting
the initial stratified split, only plants belonging to the same species
serve as exchange partners for each other. This second purpose of the
<code>categories</code> argument is the one that we used above to
restrict the number of exchange partners to speed up anticlustering:
Only elements that have the same value in <code>categories</code> serve
as exchange partners for each other.</p>
<p>In the example above, we prevented <code><a href="../reference/anticlustering.html">anticlustering()</a></code> from
conducting a stratified split on the basis of the
<code>categories</code> argument because we passed the initial grouping
of the variables ourselves. The insight that the <code>categories</code>
argument has a twofold purpose—one of which can be shut down by using
the <code>K</code> argument as the initial grouping vector—leads to the
following approach, where I combine the speedup aspect of
<code>categories</code> with the aspect of conducting a stratified
split.</p>
<p>First, we conduct a manual stratified split as the initial grouping
vector for the <code>K</code> argument in
<code><a href="../reference/anticlustering.html">anticlustering()</a></code>:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">initial_groups</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/categorical_sampling.html">categorical_sampling</a></span><span class="op">(</span><span class="va">iris</span><span class="op">$</span><span class="va">Species</span>, K <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">initial_groups</span>, <span class="va">iris</span><span class="op">$</span><span class="va">Species</span><span class="op">)</span> <span class="co"># even!</span></span>
<span><span class="co">#&gt;               </span></span>
<span><span class="co">#&gt; initial_groups setosa versicolor virginica</span></span>
<span><span class="co">#&gt;              1     10         10        10</span></span>
<span><span class="co">#&gt;              2     10         10        10</span></span>
<span><span class="co">#&gt;              3     10         10        10</span></span>
<span><span class="co">#&gt;              4     10         10        10</span></span>
<span><span class="co">#&gt;              5     10         10        10</span></span></code></pre></div>
<p>Next, as in the previous section, we generate a vector that defines
groups of pairwise exchange partners.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">N</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">iris</span><span class="op">)</span></span>
<span><span class="va">n_exchange_partners</span> <span class="op">&lt;-</span> <span class="fl">10</span></span>
<span><span class="va">exchange_partners</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep_len</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="op">(</span><span class="va">N</span><span class="op">/</span><span class="va">n_exchange_partners</span><span class="op">)</span>, <span class="va">N</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>Now, and this is the crucial part, we pass to the argument
<code>categories</code> a matrix that contains both the species as well
as the <code>exchange_partners</code> vector, and to the argument
<code>K</code> the vector that encodes the stratified split. This way we
ensure that:</p>
<ol style="list-style-type: lower-alpha">
<li>the species is split evenly between groups at the start of the
algorithm (argument <code>K</code>)</li>
<li>the number of exchange partners is restricted to 10 (one column of
the argument <code>categories</code>)</li>
<li>the exchange partners are from the same species, thereby ensuring
that the species remains evenly distributed between groups (the other
column of <code>categories</code>)</li>
</ol>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">groups</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/anticlustering.html">anticlustering</a></span><span class="op">(</span></span>
<span>  <span class="va">iris</span><span class="op">[</span>, <span class="op">-</span><span class="fl">5</span><span class="op">]</span>,</span>
<span>  K <span class="op">=</span> <span class="va">initial_groups</span>, </span>
<span>  categories <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="va">iris</span><span class="op">$</span><span class="va">Species</span>, <span class="va">exchange_partners</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>The groups are still balanced after <code><a href="../reference/anticlustering.html">anticlustering()</a></code> was
called:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">groups</span>, <span class="va">iris</span><span class="op">$</span><span class="va">Species</span><span class="op">)</span></span>
<span><span class="co">#&gt;       </span></span>
<span><span class="co">#&gt; groups setosa versicolor virginica</span></span>
<span><span class="co">#&gt;      1     10         10        10</span></span>
<span><span class="co">#&gt;      2     10         10        10</span></span>
<span><span class="co">#&gt;      3     10         10        10</span></span>
<span><span class="co">#&gt;      4     10         10        10</span></span>
<span><span class="co">#&gt;      5     10         10        10</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="objective-function">Objective function<a class="anchor" aria-label="anchor" href="#objective-function"></a>
</h2>
<p>The package <code>anticlust</code> primarily implements two objective
functions for anticlustering: k-means and the diversity.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> The k-means criterion
is well-known in cluster analysis and is computed as the sum of the
squared Euclidean distances between all data points and the centroid of
their respective cluster. The diversity is the overall sum of distances
of elements in the same sets (for details, see Papenberg &amp; Klau,
2021). By default, <code><a href="../reference/anticlustering.html">anticlustering()</a></code> optimizes the
“Euclidean diversity”: the diversity objective using the Euclidean
distance as measure of pairwise dissimilarity. However, any kind of
dissimilarity matrix can be used as input.</p>
<p>As stated above, the anticlustering algorithms recompute the
objective function for each attempted exchange. Thus, computing the
objective is the major contributor to overall run time. In
<code>anticlust</code>, I exploit the fact that anticlustering
objectives can be recomputed faster when only two items have swapped
between clusters and the objective value prior to the exchange is known.
For example, computing the diversity objective “from scratch” is in
<span class="math inline">\(O(N^2)\)</span>, but when only two items
differ between swaps, it is not necessary to spend the entire <span class="math inline">\(O(N^2)\)</span> time during each exchange.
Instead, by “cleverly” updating the objective before and after the swap,
the computation reduces to <span class="math inline">\(O(N)\)</span>,
leading to about <span class="math inline">\(O(N^3)\)</span> for the
entire exchange method (instead of <span class="math inline">\(O(N^4)\)</span>—this is a huge difference).
Computing the k-means objective (<code>objective = "variance"</code>) is
in <span class="math inline">\(O(M \cdot N)\)</span>, where <span class="math inline">\(M\)</span> is the number of variables.
<code>anticlust</code> uses some optimizations during the exchange
process to prevent the entire re-computation of the cluster centroids
for each exchange, which otherwise consumes most of the run time.
However, this does not change the theoretical <span class="math inline">\(O(M \cdot N)\)</span> run time of the computation.
Thus, theoretically, re-computing the k-means objective is slower than
re-computing the diversity objective. In practice, however, I observe
that k-means anticlustering is oftentimes faster than diversity
anticlustering. That is, when <span class="math inline">\(N\)</span> is
large as compared to <span class="math inline">\(M\)</span> and <span class="math inline">\(K\)</span>. For example, let’s compare running
times for k-means and diversity anticlustering for <span class="math inline">\(N = 1000\)</span>, <span class="math inline">\(M =
2\)</span> variables and <span class="math inline">\(K = 5\)</span>
groups:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">N</span> <span class="op">&lt;-</span> <span class="fl">1000</span></span>
<span><span class="va">M</span> <span class="op">&lt;-</span> <span class="fl">2</span></span>
<span><span class="va">K</span> <span class="op">&lt;-</span> <span class="fl">5</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">M</span><span class="op">*</span><span class="va">N</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="va">M</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="fu"><a href="../reference/anticlustering.html">anticlustering</a></span><span class="op">(</span><span class="va">data</span>, K <span class="op">=</span> <span class="va">K</span>, objective <span class="op">=</span> <span class="st">"diversity"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;   3.279   0.000   3.279</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="fu"><a href="../reference/anticlustering.html">anticlustering</a></span><span class="op">(</span><span class="va">data</span>, K <span class="op">=</span> <span class="va">K</span>, objective <span class="op">=</span> <span class="st">"variance"</span><span class="op">)</span><span class="op">)</span> <span class="co"># k-means anticlustering</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;   1.863   0.000   1.863</span></span></code></pre></div>
<p>When <span class="math inline">\(M\)</span> and/or <span class="math inline">\(K\)</span> increase, the diversity implementation
may be faster, e.g. using <span class="math inline">\(N = 1000\)</span>,
<span class="math inline">\(M = 20\)</span> variables and <span class="math inline">\(K = 50\)</span> yields:</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">N</span> <span class="op">&lt;-</span> <span class="fl">1000</span></span>
<span><span class="va">M</span> <span class="op">&lt;-</span> <span class="fl">20</span></span>
<span><span class="va">K</span> <span class="op">&lt;-</span> <span class="fl">50</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">M</span><span class="op">*</span><span class="va">N</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="va">M</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="fu"><a href="../reference/anticlustering.html">anticlustering</a></span><span class="op">(</span><span class="va">data</span>, K <span class="op">=</span> <span class="va">K</span>, objective <span class="op">=</span> <span class="st">"diversity"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;   0.205   0.008   0.213</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="fu"><a href="../reference/anticlustering.html">anticlustering</a></span><span class="op">(</span><span class="va">data</span>, K <span class="op">=</span> <span class="va">K</span>, objective <span class="op">=</span> <span class="st">"variance"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;   0.826   0.000   0.826</span></span></code></pre></div>
<p>In most application I am aware of, the k-means method is faster
because <span class="math inline">\(M\)</span> and <span class="math inline">\(K\)</span> are usually not very large. However,
for example, if we happen to have (approximately) “<span class="math inline">\(M = N\)</span>”, the diversity implementation is
much faster because its theoretical run time is better. Note that for
very large data sets, however, using the diversity objective may not be
feasible at all. The reason for this is that a quadratic matrix of
between-item distances has to be computed and stored in memory. It is my
experience that on a personal computer this becomes difficult for about
&gt; 20000 elements (where the distance matrix has 20000^2 = 400000000
elements). Thus, for large data sets a change of the objective is
reasonable; the k-means objective is computationally more efficient and
even very large data sets can be processed—at least this is true when
the number of variables is (much) smaller than the number of elements. I
live in a world where this is usually the case.</p>
<p>Because the k-means objective has some disadvantages for
anticlustering (see Papenberg, 2023),<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> you may consider using the k-plus
objective, which extends—and effectively re-uses—the k-means criterion.
For example, the following code—using <span class="math inline">\(N =
50000\)</span>, 2 features and 2 exchange partners per element—ran in
just about 15 seconds on my 10 year old personal computer:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span></span>
<span><span class="va">N</span> <span class="op">&lt;-</span> <span class="fl">50000</span></span>
<span><span class="va">M</span> <span class="op">&lt;-</span> <span class="fl">2</span></span>
<span><span class="va">K</span> <span class="op">&lt;-</span> <span class="fl">5</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">M</span><span class="op">*</span><span class="va">N</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="va">M</span><span class="op">)</span></span>
<span></span>
<span><span class="va">initial_clusters</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep_len</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">K</span>, <span class="va">N</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">n_exchange_partners</span> <span class="op">&lt;-</span> <span class="fl">2</span></span>
<span><span class="va">exchange_partners</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep_len</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="op">(</span><span class="va">N</span><span class="op">/</span><span class="va">n_exchange_partners</span><span class="op">)</span>, <span class="va">N</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="../reference/kplus_anticlustering.html">kplus_anticlustering</a></span><span class="op">(</span><span class="va">data</span>, K <span class="op">=</span> <span class="va">initial_clusters</span>, categories <span class="op">=</span> <span class="va">exchange_partners</span><span class="op">)</span></span></code></pre></div>
<p>My computer crashes when I insert 50000 data points into diversity
anticlustering.</p>
</div>
<div class="section level2">
<h2 id="addendum-fast_anticlustering">Addendum: <code>fast_anticlustering()</code><a class="anchor" aria-label="anchor" href="#addendum-fast_anticlustering"></a>
</h2>
<p>The <code>anticlust</code> package contains a function called
<code><a href="../reference/fast_anticlustering.html">fast_anticlustering()</a></code>, which (as the name suggests) was
introduced to be a faster version of <code><a href="../reference/anticlustering.html">anticlustering()</a></code> to
process large data sets. <code><a href="../reference/fast_anticlustering.html">fast_anticlustering()</a></code> optimizes
the k-means criterion and has an argument <code>k_neighbours</code>,
which adjusts the number of exchange partners. Details are found in the
documentation (<code><a href="../reference/fast_anticlustering.html">?fast_anticlustering</a></code>) and in Papenberg and
Klau (2021). In my view, the <code><a href="../reference/fast_anticlustering.html">fast_anticlustering()</a></code> approach
to adjusting the number of exchange partners is theoretically and
practically more satisfying than the previous “hack” of using the
<code>categories</code> argument. However, while the function may still
be useful in some settings, I currently do not recommend its use. This
is because the exchange algorithm that is called in
<code><a href="../reference/anticlustering.html">anticlustering()</a></code> (and therefore also
<code><a href="../reference/kplus_anticlustering.html">kplus_anticlustering()</a></code>, which calls
<code><a href="../reference/anticlustering.html">anticlustering()</a></code>) has been rewritten in C after including
<code><a href="../reference/fast_anticlustering.html">fast_anticlustering()</a></code> in the package. The C implementation
is considerably faster as compared to the R implementation in
<code><a href="../reference/fast_anticlustering.html">fast_anticlustering()</a></code>. Due to the way in which exchange
partners are generated in <code><a href="../reference/fast_anticlustering.html">fast_anticlustering()</a></code>, it is also
not straight forward use the C implementation of the exchange method in
<code><a href="../reference/fast_anticlustering.html">fast_anticlustering()</a></code>—I would like to change this in the
future, but I am not sure when this will happen. So, ironically,
<code><a href="../reference/fast_anticlustering.html">fast_anticlustering()</a></code> is currently not the fastest method
for anticlustering, by a long shot:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">N</span> <span class="op">&lt;-</span> <span class="fl">1000</span></span>
<span><span class="va">M</span> <span class="op">&lt;-</span> <span class="fl">2</span></span>
<span><span class="va">K</span> <span class="op">&lt;-</span> <span class="fl">5</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">M</span><span class="op">*</span><span class="va">N</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="va">M</span><span class="op">)</span></span>
<span></span>
<span><span class="va">initial_clusters</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep_len</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">K</span>, <span class="va">N</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">n_exchange_partners</span> <span class="op">&lt;-</span> <span class="fl">10</span></span>
<span><span class="va">exchange_partners</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep_len</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="op">(</span><span class="va">N</span><span class="op">/</span><span class="va">n_exchange_partners</span><span class="op">)</span>, <span class="va">N</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># fast_anticlustering() always optimizes the k-means criterion (i.e., objective = "variance")</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="fu"><a href="../reference/anticlustering.html">anticlustering</a></span><span class="op">(</span><span class="va">data</span>, K <span class="op">=</span> <span class="va">initial_clusters</span>, categories <span class="op">=</span> <span class="va">exchange_partners</span>, objective <span class="op">=</span> <span class="st">"variance"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;   0.026   0.000   0.025</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="fu"><a href="../reference/fast_anticlustering.html">fast_anticlustering</a></span><span class="op">(</span><span class="va">data</span>, K <span class="op">=</span> <span class="va">initial_clusters</span>, k_neighbours <span class="op">=</span> <span class="va">n_exchange_partners</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;   0.866   0.004   0.870</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<p>Papenberg, M., &amp; Klau, G. W. (2021). Using anticlustering to
partition data sets into equivalent parts. Psychological Methods, 26(2),
161–174. <a href="https://doi.org/10.1037/met0000301" class="external-link uri">https://doi.org/10.1037/met0000301</a>.</p>
<p>Papenberg, M. (2023). k-plus Anticlustering: An Improved k-means
Criterion for Maximizing Between-Group Similarity. Preprint available
from <a href="https://doi.org/10.31234/osf.io/7jw6v" class="external-link uri">https://doi.org/10.31234/osf.io/7jw6v</a></p>
<p>Weitz, R., &amp; Lakshminarayanan, S. (1998). An empirical comparison
of heuristic methods for creating maximally diverse groups. Journal of
the Operational Research Society, 49 (6), 635–646. <a href="https://doi.org/10.1057/palgrave.jors.2600510" class="external-link uri">https://doi.org/10.1057/palgrave.jors.2600510</a></p>
</div>
<div class="footnotes footnotes-end-of-document">
<hr>
<ol>
<li id="fn1"><p>Actually, four objectives are natively supported for the
<code><a href="../reference/anticlustering.html">anticlustering()</a></code> argument <code>objective</code>:
<code>"diversity"</code>, <code>"variance"</code> (i.e, k-means),
<code>"kplus"</code> and <code>"dispersion"</code>. However, the k-plus
objective as implemented in <code>anticlust</code> effectively re-uses
the original k-means criterion and just extends the input data
internally. The dispersion objective has a different goal than the other
objectives as it does not strive for between-group similarity, so it
cannot be used as an alternative to the other objectives.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>The primary disadvantage is that k-means anticlustering
only leads to similarity in means, but not in standard deviations or any
other distribution aspects; the k-plus criterion can be used to equalize
arbitrary distribution moments between groups.<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Martin Papenberg.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer>
</div>

  


  

  </body>
</html>
