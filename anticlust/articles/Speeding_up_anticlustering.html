<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Speeding up anticlustering • anticlust</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Speeding up anticlustering">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">


    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">anticlust</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">0.8.12</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles

    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/Anticlustering_in_2025.html">Anticlustering in 2025</a>
    </li>
    <li>
      <a href="../articles/Best_practices.html">Some best practices for anticlustering</a>
    </li>
    <li>
      <a href="../articles/Categorical_vars.html">Using categorical variables with anticlustering</a>
    </li>
    <li>
      <a href="../articles/Speeding_up_anticlustering.html">Speeding up anticlustering</a>
    </li>
    <li>
      <a href="../articles/stimulus-selection.html">Using the R package anticlust for stimulus selection in experiments</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
<li>
  <a href="https://m-py.github.io/anticlust-blog" class="external-link">Blog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/m-Py/anticlust/" class="external-link">
    <span class="fab fa-github fa-lg"></span>

  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->



      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Speeding up anticlustering</h1>
                        <h4 data-toc-skip class="author">Martin
Papenberg</h4>
            
      
      <small class="dont-index">Source: <a href="https://github.com/m-Py/anticlust/blob/HEAD/vignettes/Speeding_up_anticlustering.Rmd" class="external-link"><code>vignettes/Speeding_up_anticlustering.Rmd</code></a></small>
      <div class="hidden name"><code>Speeding_up_anticlustering.Rmd</code></div>

    </div>

    
    
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/m-Py/anticlust" class="external-link">anticlust</a></span><span class="op">)</span></span></code></pre></div>
<p>This vignette documents various ways by which the speed of the
anticlustering method implemented in the <code>anticlust</code> package
can be adjusted. Speedup is particularly useful for large data sets when
the default anticlustering algorithm becomes too slow. A fast method may
also be desirable for testing purposes, even if the final anticlustering
is based on a slower method.</p>
<div class="section level2">
<h2 id="the-exchange-algorithm">The exchange algorithm<a class="anchor" aria-label="anchor" href="#the-exchange-algorithm"></a>
</h2>
<p>The default anticlustering algorithm works by exchanging data points
between clusters in such a way that exchanges improve the anticlustering
objective as much as possible. Details on the exchange method may also
be found in Papenberg and Klau (2021; <a href="https://doi.org/10.1037/met0000301" class="external-link uri">https://doi.org/10.1037/met0000301</a>), Papenberg (2024; <a href="https://doi.org/10.1111/bmsp.12315" class="external-link uri">https://doi.org/10.1111/bmsp.12315</a>), or the
<code>anticlust</code> documentation (<code><a href="../reference/anticlustering.html">?anticlustering</a></code>).
Basically, running more exchanges tends to improve the results, but the
improvements are diminishing with many repetitions—especially for large
data sets. So, to speed up anticlustering, we can reduce the number of
exchanges. Here we will learn how to do that. However, first we learn
how to slow down anticlustering. Slowing down can lead to better results
and is recommended if you have the time.</p>
</div>
<div class="section level2">
<h2 id="slowing-down">Slowing down<a class="anchor" aria-label="anchor" href="#slowing-down"></a>
</h2>
<p>The default exchange algorithm
(<code>anticlustering(..., method = "exchange")</code>) iterates through
all input elements and attempts to improve the anticlustering by
swapping each input element with a element that is currently assigned to
a different cluster. No swap is conducted if an element cannot be
swapped in such a way that the anticlustering objective is improved. The
process stops after all possible exchanges have been evaluated for each
element. When the number of input elements is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>,
this process leads to approximately
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>N</mi><mn>2</mn></msup><annotation encoding="application/x-tex">N^2</annotation></semantics></math>—or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math>—attempted
exchanges, because each element is swapped with all elements that are
currently assigned to a different cluster. To give a concrete example,
when having
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">N = 100</annotation></semantics></math>
data points and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">K = 4</annotation></semantics></math>
equal-sized groups, 75 swaps are evaluated for each element and the best
swap is realized. This leads to 100 * 75 = 7500 exchanges that have to
be conducted during the entire exchange algorithm, and for each exchange
the objective function has to be re-evaluated. This is less exchanges
than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup><mo>=</mo><msup><mn>100</mn><mn>2</mn></msup><mo>=</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">N^2 = 100^2 = 10000</annotation></semantics></math>
because we skip exchanges with the 25 elements that are currently in the
same cluster (including itself). However, according to the <a href="https://en.wikipedia.org/wiki/Big_O_notation" class="external-link">Big O notation</a>,
we would still classify the number of exchanges as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math>,
independent of the number of groups. Thus, the total theoretical run
time of the exchange method is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math>
multiplied with the effort needed to compute an anticlustering
objective.</p>
<p>The results of the exchange method can be improved by not stopping
after a single iteration through the data set; instead we may repeat the
process until no single exchange is able to further improve the
anticlustering objective, i.e., until a local maximum is found. This
happens if we use
<code>anticlustering(..., method = "local-maximum")</code>. This method
corresponds to the algorithm “LCW” in Weitz and Lakshminarayanan (1998).
Using the local maximum method leads to more exchanges and thus to
longer running time, but also better results than the default exchange
method.</p>
<p>Let’s compare the two exchange methods with regard to their running
time, using the iris data set, which contains 150 elements.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span></span>
<span><span class="va">K</span> <span class="op">&lt;-</span> <span class="fl">3</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="fu"><a href="../reference/anticlustering.html">anticlustering</a></span><span class="op">(</span><span class="va">iris</span><span class="op">[</span>, <span class="op">-</span><span class="fl">5</span><span class="op">]</span>, K <span class="op">=</span> <span class="va">K</span>, method <span class="op">=</span> <span class="st">"exchange"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;   0.012   0.001   0.011</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="fu"><a href="../reference/anticlustering.html">anticlustering</a></span><span class="op">(</span><span class="va">iris</span><span class="op">[</span>, <span class="op">-</span><span class="fl">5</span><span class="op">]</span>, K <span class="op">=</span> <span class="va">K</span>, method <span class="op">=</span> <span class="st">"local-maximum"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;   0.042   0.000   0.043</span></span></code></pre></div>
<p>Depending on how many iterations are needed, the default exchange
method can be much faster than the local maximum method. Generally I
would recommend to use <code>method = "local-maximum"</code> for better
results, but if speed is an issue, stick with the default.</p>
<p>To slow down even more: The exchange process may be restarted several
times, each time using a different initial grouping of the elements.
This is accomplished when specifying the <code>repetitions</code>
argument, which defaults to 1 repetition of the exchange / local maximum
algorithm. Thus, for better results, we may increase the number of
repetitions:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span></span>
<span><span class="va">K</span> <span class="op">&lt;-</span> <span class="fl">3</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="fu"><a href="../reference/anticlustering.html">anticlustering</a></span><span class="op">(</span><span class="va">iris</span><span class="op">[</span>, <span class="op">-</span><span class="fl">5</span><span class="op">]</span>, K <span class="op">=</span> <span class="va">K</span>, method <span class="op">=</span> <span class="st">"exchange"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;   0.009   0.000   0.010</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="fu"><a href="../reference/anticlustering.html">anticlustering</a></span><span class="op">(</span><span class="va">iris</span><span class="op">[</span>, <span class="op">-</span><span class="fl">5</span><span class="op">]</span>, K <span class="op">=</span> <span class="va">K</span>, method <span class="op">=</span> <span class="st">"local-maximum"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;    0.03    0.00    0.03</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="fu"><a href="../reference/anticlustering.html">anticlustering</a></span><span class="op">(</span><span class="va">iris</span><span class="op">[</span>, <span class="op">-</span><span class="fl">5</span><span class="op">]</span>, K <span class="op">=</span> <span class="va">K</span>, method <span class="op">=</span> <span class="st">"local-maximum"</span>, repetitions <span class="op">=</span> <span class="fl">10</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;   0.305   0.000   0.305</span></span></code></pre></div>
<p>In this case, sticking with the default leads to run times that are
much much faster. Still, if your data set is not too large, using
several repetitions may be useful (but you can judge yourself via the
results). The good news is that fewer exchanges may be enough in large
data sets: anticlustering generally becomes easier with more data.</p>
</div>
<div class="section level2">
<h2 id="getting-fast-using-fewer-exchange-partners">Getting fast: Using fewer exchange partners<a class="anchor" aria-label="anchor" href="#getting-fast-using-fewer-exchange-partners"></a>
</h2>
<p>If the default exchange method is not fast enough for your taste, it
is possible to use fewer exchange partners during the anticlustering
process. By default, the exchange method evaluates each possible
exchange with all elements that are currently assigned to a different
cluster, leading to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math>
exchanges. If we only use a fixed number of exchange partners per
element, we can reduce the number of exchanges to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math>,
corresponding to a gain of an order of magnitude in terms of run time.
Using fewer exchange partners for each element may decrease the quality
of the results, and is generally only recommended if speed is an issue,
e.g. for large data sets. But the run time will be considerably faster.
We will consider three possibilities of using fewer exchange partners in
<code>anticlust</code>: <code><a href="../reference/fast_anticlustering.html">fast_anticlustering()</a></code>,
preclustering, and an additional secret hack.</p>
<div class="section level3">
<h3 id="fast_anticlustering">fast_anticlustering()<a class="anchor" aria-label="anchor" href="#fast_anticlustering"></a>
</h3>
<p>In Papenberg and Klau (2021), we described the function
<code><a href="../reference/fast_anticlustering.html">fast_anticlustering()</a></code> as a method to speed up the
anticlustering process for large data sets. It optimizes the k-means
objective because computing all pairwise distances as is done when
optimizing the “diversity” (i.e., the default in
<code><a href="../reference/anticlustering.html">anticlustering()</a></code>) is not feasible for very large data sets
(for about N &gt; 20000 on my personal computer). Moreover,
<code><a href="../reference/fast_anticlustering.html">fast_anticlustering()</a></code> directly takes as argument the number
of exchange partners for each element, via the argument
<code>k_neighbours</code>. In this case, the application is straight
forward:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">N</span> <span class="op">&lt;-</span> <span class="fl">5000</span></span>
<span><span class="va">M</span> <span class="op">&lt;-</span> <span class="fl">2</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">N</span> <span class="op">*</span> <span class="va">M</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="va">M</span><span class="op">)</span></span>
<span><span class="va">start</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Sys.time.html" class="external-link">Sys.time</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">groups1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/fast_anticlustering.html">fast_anticlustering</a></span><span class="op">(</span><span class="va">data</span>, K <span class="op">=</span> <span class="fl">2</span><span class="op">)</span>  <span class="co"># default uses all exchange partners</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Sys.time.html" class="external-link">Sys.time</a></span><span class="op">(</span><span class="op">)</span> <span class="op">-</span> <span class="va">start</span> </span>
<span><span class="co">#&gt; Time difference of 2.220607 secs</span></span></code></pre></div>
<p>The default behaviour in <code><a href="../reference/fast_anticlustering.html">fast_anticlustering()</a></code> is to use
all exchange partners. Using fewer exchange partners can lead to much
faster run time:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">start</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Sys.time.html" class="external-link">Sys.time</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">groups2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/fast_anticlustering.html">fast_anticlustering</a></span><span class="op">(</span><span class="va">data</span>, K <span class="op">=</span> <span class="fl">2</span>, k_neighbours <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Sys.time.html" class="external-link">Sys.time</a></span><span class="op">(</span><span class="op">)</span> <span class="op">-</span> <span class="va">start</span> </span>
<span><span class="co">#&gt; Time difference of 0.218188 secs</span></span></code></pre></div>
<p>Was there a cost to this speedup?</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/variance_objective.html">variance_objective</a></span><span class="op">(</span><span class="va">data</span>, <span class="va">groups1</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 9925.961</span></span>
<span><span class="fu"><a href="../reference/variance_objective.html">variance_objective</a></span><span class="op">(</span><span class="va">data</span>, <span class="va">groups2</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 9925.961</span></span></code></pre></div>
<p>Frankly, there is no observable difference with regard to the
objective that was obtained, but the call to
<code><a href="../reference/fast_anticlustering.html">fast_anticlustering()</a></code>, which used fewer exchange partners,
was much faster. In general, for large data sets, using fewer exchange
partners may not impair the results and instead lead to heavily reduced
run times. <em>Sometimes, there is free lunch</em>.</p>
<p>By default, <code><a href="../reference/fast_anticlustering.html">fast_anticlustering()</a></code> selects exchange
partners though a nearest neighbour search when specifying
<code>k_neighbours</code>: similar elements serve as exchange partners.
The nearest neighbour search, which is done once in the beginning, only
has O(N log(N)) run time and therefore does not strongly contribute to
the overall run time. It is possible to suppress the nearest neighbour
search by passing custom exchange partners using the
<code>exchange_partners</code> argument of
<code><a href="../reference/fast_anticlustering.html">fast_anticlustering()</a></code>. Exchange partners can for example be
generated by <code><a href="../reference/generate_exchange_partners.html">generate_exchange_partners()</a></code>, but a custom
list may also be used. See the documentation
(<code><a href="../reference/fast_anticlustering.html">?fast_anticlustering</a></code> and
<code>?generate_exchange_partners()</code>) for more information.</p>
</div>
<div class="section level3">
<h3 id="preclustering">Preclustering<a class="anchor" aria-label="anchor" href="#preclustering"></a>
</h3>
<p>A second way of doing using fewer exchange partners is by including
“preclustering” restrictions with the standard anticlustering function
<code><a href="../reference/anticlustering.html">anticlustering()</a></code>. Unlike
<code><a href="../reference/fast_anticlustering.html">fast_anticlustering()</a></code>, preclustering works with all
anticlustering objectives that are available in
<code><a href="../reference/anticlustering.html">anticlustering()</a></code> (e.g., the diversity). When setting
<code>preclustering = TRUE</code>, the optimization restricts the number
of exchange partners to <code>K - 1</code> (very similar) elements.
While the logic is similar to the nearest neighbour approach in
<code><a href="../reference/fast_anticlustering.html">fast_anticlustering()</a></code>, the difference is that the exchange
partners consist of mutually exclusive groups when using preclustering.
For example, the first, third and tenth element may only serve as
exchange partners for each other, and none of them is exchanged with an
“outsider” of this particular group. With
<code><a href="../reference/fast_anticlustering.html">fast_anticlustering()</a></code>, each element has its own separate
list of exchange partners, which can even be user generated when using
the argument <code>exchange_partners</code>. In graph terms, with
preclustering, the exchange partners form a clique, whereas with
<code><a href="../reference/fast_anticlustering.html">fast_anticlustering()</a></code>, any (number of) connections are
possible.</p>
<p>Note that the preclustering algorithm, which has to be performed
prior to the anticlustering algorithm, has
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math>
run time, which is slower than the nearest neighbour search in
<code><a href="../reference/fast_anticlustering.html">fast_anticlustering()</a></code>. It nevertheless leads to strongly
improved run times for larger data sets:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">N</span> <span class="op">&lt;-</span> <span class="fl">1000</span></span>
<span><span class="va">M</span> <span class="op">&lt;-</span> <span class="fl">5</span></span>
<span><span class="va">K</span> <span class="op">&lt;-</span> <span class="fl">3</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">N</span><span class="op">*</span><span class="va">M</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="va">M</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="fu"><a href="../reference/anticlustering.html">anticlustering</a></span><span class="op">(</span><span class="va">data</span>, K <span class="op">=</span> <span class="va">K</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;   4.857   0.000   4.858</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="fu"><a href="../reference/anticlustering.html">anticlustering</a></span><span class="op">(</span><span class="va">data</span>, K <span class="op">=</span> <span class="va">K</span>, preclustering <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;    0.11    0.00    0.11</span></span></code></pre></div>
<p>Still, the preclustering approach is probably not necessarily
recommended to speed up anticlustering for very large data sets; it is
useful if you are interested in enforcing the preclustering restrictions
in the groupings.</p>
</div>
<div class="section level3">
<h3 id="secret-hack">Secret hack<a class="anchor" aria-label="anchor" href="#secret-hack"></a>
</h3>
<p>There is also an additional “hidden” method to make the
<code><a href="../reference/anticlustering.html">anticlustering()</a></code> function run faster. This method also
relies on using fewer exchange partners during the exchange process, but
does not use preclustering or the approach used in
<code><a href="../reference/fast_anticlustering.html">fast_anticlustering()</a></code>. This approach is documented here and
mostly relies on a dirty “hack” involving the
<code><a href="../reference/anticlustering.html">anticlustering()</a></code> argument <code>categories</code>. Since it
works with <code><a href="../reference/anticlustering.html">anticlustering()</a></code>, it can be used for all
anticlustering objectives (unlike <code><a href="../reference/fast_anticlustering.html">fast_anticlustering()</a></code>).
Let’s see how it works:</p>
<p>The first step that I am using here is not strictly necessary—in the
next section, we will learn more about what this accomplishes—but let’s
create the initial clusters before calling
<code><a href="../reference/anticlustering.html">anticlustering()</a></code>. This grouping is the basis on which the
exchange procedure starts to improve the anticlustering:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">N</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">iris</span><span class="op">)</span></span>
<span><span class="va">K</span> <span class="op">&lt;-</span> <span class="fl">3</span></span>
<span><span class="va">initial_clusters</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep_len</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">K</span>, <span class="va">N</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">initial_clusters</span></span>
<span><span class="co">#&gt;   [1] 3 1 1 2 3 2 3 3 1 1 1 3 2 2 3 2 2 3 1 3 1 3 1 3 2 3 3 3 3 2 1 3 2 1 2 1 2</span></span>
<span><span class="co">#&gt;  [38] 3 1 2 3 3 1 2 2 3 2 2 3 1 3 3 3 2 2 2 2 3 2 1 2 3 1 2 1 3 1 2 2 2 1 2 2 1</span></span>
<span><span class="co">#&gt;  [75] 2 3 3 2 3 3 3 1 2 1 1 3 1 1 1 1 1 3 1 2 3 2 3 2 1 3 3 2 1 2 3 2 3 1 3 1 2</span></span>
<span><span class="co">#&gt; [112] 1 3 2 1 2 2 1 1 1 2 1 1 3 2 1 1 3 1 2 2 1 3 3 3 1 1 3 2 1 3 1 2 2 1 1 3 2</span></span>
<span><span class="co">#&gt; [149] 2 3</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">initial_clusters</span><span class="op">)</span></span>
<span><span class="co">#&gt; initial_clusters</span></span>
<span><span class="co">#&gt;  1  2  3 </span></span>
<span><span class="co">#&gt; 50 50 50</span></span></code></pre></div>
<p>Now, the argument <code>categories</code> can be used to define which
elements serve as exchange partners for each other. Lets create random
groups of 10 elements that serve as exchange elements for each
other:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">exchange_partners</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep_len</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="op">(</span><span class="va">N</span><span class="op">/</span><span class="fl">10</span><span class="op">)</span>, <span class="va">N</span><span class="op">)</span><span class="op">)</span> <span class="co">#somewhat ugly but works</span></span>
<span><span class="va">exchange_partners</span></span>
<span><span class="co">#&gt;   [1] 11  2  9 12 15  6 11 15  2  1  5  4  6  8  9 14  4  9  1  9  9 11 10 15 14</span></span>
<span><span class="co">#&gt;  [26]  1  4  3  1  3 15  5  2 12 12  2  3 15  3  8 14  6  8  9  7  5 10  5  6 12</span></span>
<span><span class="co">#&gt;  [51] 13 10 12 13 11 14  7  8 15  5  1  7  4  4  2  5 10  5  5  7  3  8 13 11 10</span></span>
<span><span class="co">#&gt;  [76] 13  3 10  7 10  4 13  8  1  7  3 13 12  3  7 15  7 14 13 13  3 12  8  5  6</span></span>
<span><span class="co">#&gt; [101] 11 14 15  1  9  6  7  6  4 10 12 11 11  3  4  4  6 14 10  1 14  7  8  9  6</span></span>
<span><span class="co">#&gt; [126]  9  2 11  1 15  6  4  8  8 13 11 12  9  5  2 14  2 12 10 15  2 14 13  2  1</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">exchange_partners</span><span class="op">)</span></span>
<span><span class="co">#&gt; exchange_partners</span></span>
<span><span class="co">#&gt;  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 </span></span>
<span><span class="co">#&gt; 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10</span></span></code></pre></div>
<p>The variable <code>exchange_partners</code> now defines groups of
elements that are exchanged with each other: When passed to
<code>categories</code>, only elements having the same value in
<code>exchange_partners</code> serve as exchange partners for each other
– this is how the <code>categories</code> argument operates. Thus, each
element is only swapped with 9 other elements instead of all 150
elements.</p>
<p>Now let’s call anticlustering using the exchange partners we just
defined:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="fu"><a href="../reference/anticlustering.html">anticlustering</a></span><span class="op">(</span><span class="va">iris</span><span class="op">[</span>, <span class="op">-</span><span class="fl">5</span><span class="op">]</span>, K <span class="op">=</span> <span class="va">initial_clusters</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;    0.01    0.00    0.01</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="fu"><a href="../reference/anticlustering.html">anticlustering</a></span><span class="op">(</span><span class="va">iris</span><span class="op">[</span>, <span class="op">-</span><span class="fl">5</span><span class="op">]</span>, K <span class="op">=</span> <span class="va">initial_clusters</span>, categories <span class="op">=</span> <span class="va">exchange_partners</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;   0.004   0.000   0.004</span></span></code></pre></div>
<p>Well, there is not a lot going on here with this very small data set
(N = 150), so let’s do this for a larger data set with 1000 data
points.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">N</span> <span class="op">&lt;-</span> <span class="fl">1000</span></span>
<span><span class="va">M</span> <span class="op">&lt;-</span> <span class="fl">2</span></span>
<span><span class="va">K</span> <span class="op">&lt;-</span> <span class="fl">5</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">M</span><span class="op">*</span><span class="va">N</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="va">M</span><span class="op">)</span></span>
<span></span>
<span><span class="va">initial_clusters</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep_len</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">K</span>, <span class="va">N</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">exchange_partners</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep_len</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="op">(</span><span class="va">N</span><span class="op">/</span><span class="fl">10</span><span class="op">)</span>, <span class="va">N</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="fu"><a href="../reference/anticlustering.html">anticlustering</a></span><span class="op">(</span><span class="va">data</span>, K <span class="op">=</span> <span class="va">initial_clusters</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;   3.314   0.000   3.314</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span><span class="fu"><a href="../reference/anticlustering.html">anticlustering</a></span><span class="op">(</span><span class="va">data</span>, K <span class="op">=</span> <span class="va">initial_clusters</span>, categories <span class="op">=</span> <span class="va">exchange_partners</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;   0.062   0.000   0.063</span></span></code></pre></div>
<p>The speedup is enormous!</p>
</div>
<div class="section level3">
<h3 id="including-categorical-variables">Including categorical variables<a class="anchor" aria-label="anchor" href="#including-categorical-variables"></a>
</h3>
<p>The previous “hacky” approach to speed up anticlustering used the
<code>categories</code> argument. We should now reflect how this was
accomplished, and first note that the <code>categories</code> argument
usually has a different purpose: It is used to evenly distribute a
categorical variable across groups—we did not care for that in the
previous example.</p>
<p>For example, coming back to the iris data set, we may require to
evenly distribute the species of the iris plants across 5 groups of
plants:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">groups</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/anticlustering.html">anticlustering</a></span><span class="op">(</span><span class="va">iris</span><span class="op">[</span>, <span class="op">-</span><span class="fl">5</span><span class="op">]</span>, K <span class="op">=</span> <span class="fl">5</span>, categories <span class="op">=</span> <span class="va">iris</span><span class="op">$</span><span class="va">Species</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">groups</span>, <span class="va">iris</span><span class="op">$</span><span class="va">Species</span><span class="op">)</span></span>
<span><span class="co">#&gt;       </span></span>
<span><span class="co">#&gt; groups setosa versicolor virginica</span></span>
<span><span class="co">#&gt;      1     10         10        10</span></span>
<span><span class="co">#&gt;      2     10         10        10</span></span>
<span><span class="co">#&gt;      3     10         10        10</span></span>
<span><span class="co">#&gt;      4     10         10        10</span></span>
<span><span class="co">#&gt;      5     10         10        10</span></span></code></pre></div>
<p>How does the <code>categories</code> argument accomplish the even
spread of the species? First, the initial grouping of the elements is
not random, but instead a “stratified split”, which ensures that a
categorical variable occurs an equal number of times in each split.
<code>anticlust</code> has the function
<code><a href="../reference/categorical_sampling.html">categorical_sampling()</a></code> for this purpose, which is called by
<code><a href="../reference/anticlustering.html">anticlustering()</a></code> internally before the exchange algorithm
starts. After conducting the initial stratified split, only plants
belonging to the same species serve as exchange partners for each other.
This second purpose of the <code>categories</code> argument is the one
that we used above to restrict the number of exchange partners to speed
up anticlustering: Only elements that have the same value in
<code>categories</code> serve as exchange partners for each other.</p>
<p>In the example above, we prevented <code><a href="../reference/anticlustering.html">anticlustering()</a></code> from
conducting a stratified split on the basis of the
<code>categories</code> argument because we passed the initial grouping
of the variables ourselves. The insight that the <code>categories</code>
argument has a twofold purpose—one of which can be shut down by using
the <code>K</code> argument as the initial grouping vector—leads to the
following approach, where I combine the speedup aspect of
<code>categories</code> with the aspect of conducting a stratified
split.</p>
<p>First, we conduct a manual stratified split as the initial grouping
vector for the <code>K</code> argument in
<code><a href="../reference/anticlustering.html">anticlustering()</a></code>:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">initial_groups</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/categorical_sampling.html">categorical_sampling</a></span><span class="op">(</span><span class="va">iris</span><span class="op">$</span><span class="va">Species</span>, K <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">initial_groups</span>, <span class="va">iris</span><span class="op">$</span><span class="va">Species</span><span class="op">)</span> <span class="co"># even!</span></span>
<span><span class="co">#&gt;               </span></span>
<span><span class="co">#&gt; initial_groups setosa versicolor virginica</span></span>
<span><span class="co">#&gt;              1     10         10        10</span></span>
<span><span class="co">#&gt;              2     10         10        10</span></span>
<span><span class="co">#&gt;              3     10         10        10</span></span>
<span><span class="co">#&gt;              4     10         10        10</span></span>
<span><span class="co">#&gt;              5     10         10        10</span></span></code></pre></div>
<p>Next, as in the previous section, we generate a vector that defines
groups of pairwise exchange partners.</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">N</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">iris</span><span class="op">)</span></span>
<span><span class="va">exchange_partners</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep_len</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="op">(</span><span class="va">N</span><span class="op">/</span><span class="fl">10</span><span class="op">)</span>, <span class="va">N</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>Now, and this is the crucial part, we pass to the argument
<code>categories</code> a matrix that contains both the species as well
as the <code>exchange_partners</code> vector, and to the argument
<code>K</code> the vector that encodes the stratified split. This way we
ensure that:</p>
<ol style="list-style-type: lower-alpha">
<li>the species is split evenly between groups at the start of the
algorithm (argument <code>K</code>)</li>
<li>the number of exchange partners is restricted to 9 elements (one
column of the argument <code>categories</code>)</li>
<li>the exchange partners are from the same species, thereby ensuring
that the species remains evenly distributed between groups (the other
column of <code>categories</code>)</li>
</ol>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">groups</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/anticlustering.html">anticlustering</a></span><span class="op">(</span></span>
<span>  <span class="va">iris</span><span class="op">[</span>, <span class="op">-</span><span class="fl">5</span><span class="op">]</span>,</span>
<span>  K <span class="op">=</span> <span class="va">initial_groups</span>, </span>
<span>  categories <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="va">iris</span><span class="op">$</span><span class="va">Species</span>, <span class="va">exchange_partners</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>The groups are still balanced after <code><a href="../reference/anticlustering.html">anticlustering()</a></code> was
called:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">groups</span>, <span class="va">iris</span><span class="op">$</span><span class="va">Species</span><span class="op">)</span></span>
<span><span class="co">#&gt;       </span></span>
<span><span class="co">#&gt; groups setosa versicolor virginica</span></span>
<span><span class="co">#&gt;      1     10         10        10</span></span>
<span><span class="co">#&gt;      2     10         10        10</span></span>
<span><span class="co">#&gt;      3     10         10        10</span></span>
<span><span class="co">#&gt;      4     10         10        10</span></span>
<span><span class="co">#&gt;      5     10         10        10</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="objective-function">Objective function<a class="anchor" aria-label="anchor" href="#objective-function"></a>
</h2>
<p>The package <code>anticlust</code> primarily implements two objective
functions for anticlustering: k-means and the diversity.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> The k-means criterion
is well-known in cluster analysis and is computed as the sum of the
squared Euclidean distances between all data points and the centroid of
their respective cluster: the variance. The diversity is the overall sum
of all pairwise distances between elements that are grouped in the same
cluster (for details, see Papenberg &amp; Klau, 2021). By default,
<code><a href="../reference/anticlustering.html">anticlustering()</a></code> optimizes the “Euclidean diversity”: the
diversity objective using the Euclidean distance as measure of pairwise
dissimilarity.</p>
<p>As explained in the previous section, the anticlustering algorithms
recompute the objective function for each attempted exchange. Computing
the objective is therefore the major contributor to overall run time. In
<code>anticlust</code>, I exploit the fact that anticlustering
objectives can be recomputed faster when only two items have swapped
between clusters and the objective value prior to the exchange is known.
For example, computing the diversity objective “from scratch” is in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math>.
When the cluster affiliation of only two items differs between swaps, it
is however not necessary to spend the entire
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math>
time during each exchange. Instead, by “cleverly” updating the objective
before and after the swap, the computation reduces to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math>,
leading to about
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>N</mi><mn>3</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(N^3)</annotation></semantics></math>
for the entire exchange method (instead of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>N</mi><mn>4</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(N^4)</annotation></semantics></math>—this
is a huge difference). When using a fixed number of exchange partners as
described in the previous section, we are left with a run time of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math><em>in total</em>. However, note that for very large data sets, using
the diversity objective may not be feasible at all. The reason for this
is that a quadratic matrix of between-item distances has to be computed
and stored in memory. It is my experience that on a personal computer
this becomes difficult for about &gt; 20000 elements (where the distance
matrix has 20000^2 = 400000000 elements).</p>
<p>Computing the standard k-means objective (which is done when using
<code>anticlustering(..., objective = "variance"</code>) is in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>M</mi><mo>⋅</mo><mi>N</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(M \cdot N)</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
is the number of variables. The function <code><a href="../reference/anticlustering.html">anticlustering()</a></code>
uses some optimizations during the exchange process to prevent the
entire re-computation of the cluster centroids for each exchange, which
otherwise consumes most of the run time. However, this does not change
the theoretical
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>M</mi><mo>⋅</mo><mi>N</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(M \cdot N)</annotation></semantics></math>
run time of the computation. The function
<code><a href="../reference/fast_anticlustering.html">fast_anticlustering()</a></code> uses a different – but equivalent –
formulation of the k-means objective where the re-computation of the
objective only depends on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>,
but no longer on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>.<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> This
reduces the run time by an additional order of magnitude and makes
k-means anticlustering applicable to very large data sets (even in the
millions).</p>
<p>Because the k-means objective has some disadvantages for
anticlustering (see Papenberg, 2024),<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a> you may consider using the k-plus
objective, which extends—and effectively re-uses—the k-means criterion.
It can also be applied to very large data sets using
<code><a href="../reference/fast_anticlustering.html">fast_anticlustering()</a></code>. For example, the following
code—using
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">N = 100000</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">K = 5</annotation></semantics></math>,
3 features and 10 exchange partners per element—runs quite quickly:</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">N</span> <span class="op">&lt;-</span> <span class="fl">100000</span></span>
<span><span class="va">M</span> <span class="op">&lt;-</span> <span class="fl">3</span></span>
<span><span class="va">K</span> <span class="op">&lt;-</span> <span class="fl">5</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">M</span><span class="op">*</span><span class="va">N</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="va">M</span><span class="op">)</span></span>
<span></span>
<span><span class="va">start</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Sys.time.html" class="external-link">Sys.time</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">groups</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/fast_anticlustering.html">fast_anticlustering</a></span><span class="op">(</span></span>
<span>  <span class="fu"><a href="../reference/kplus_moment_variables.html">kplus_moment_variables</a></span><span class="op">(</span><span class="va">data</span>, T <span class="op">=</span> <span class="fl">2</span><span class="op">)</span>, </span>
<span>  K <span class="op">=</span> <span class="va">K</span>, </span>
<span>  exchange_partners <span class="op">=</span> <span class="fu"><a href="../reference/generate_exchange_partners.html">generate_exchange_partners</a></span><span class="op">(</span><span class="fl">10</span>, N <span class="op">=</span> <span class="va">N</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Sys.time.html" class="external-link">Sys.time</a></span><span class="op">(</span><span class="op">)</span> <span class="op">-</span> <span class="va">start</span></span>
<span><span class="co">#&gt; Time difference of 4.420855 secs</span></span>
<span><span class="fu"><a href="../reference/mean_sd_tab.html">mean_sd_tab</a></span><span class="op">(</span><span class="va">data</span>, <span class="va">groups</span><span class="op">)</span> <span class="co"># means and standard deviations are similar</span></span>
<span><span class="co">#&gt;   [,1]          [,2]          [,3]         </span></span>
<span><span class="co">#&gt; 1 "0.00 (1.00)" "0.01 (1.00)" "0.00 (1.00)"</span></span>
<span><span class="co">#&gt; 2 "0.00 (1.00)" "0.01 (1.00)" "0.00 (1.00)"</span></span>
<span><span class="co">#&gt; 3 "0.00 (1.00)" "0.01 (1.00)" "0.00 (1.00)"</span></span>
<span><span class="co">#&gt; 4 "0.00 (1.00)" "0.01 (1.00)" "0.00 (1.00)"</span></span>
<span><span class="co">#&gt; 5 "0.00 (1.00)" "0.01 (1.00)" "0.00 (1.00)"</span></span></code></pre></div>
<p>When k-plus anticlustering is conducted with
<code><a href="../reference/fast_anticlustering.html">fast_anticlustering()</a></code>, we have to augment the numeric input
with so called k-plus variables to ensure that k-plus anticlustering is
actually performed (because otherwise <code><a href="../reference/fast_anticlustering.html">fast_anticlustering()</a></code>
just performs k-means anticlustering). We should also use the argument
<code>exchange_partners</code> instead of relying on the default nearest
neighbour search, because searching nearest neighbours based on the
k-plus variables does not really make sense (even though it probably
wouldn’t hurt too much).</p>
</div>
<div class="section level2">
<h2 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<p>Papenberg, M., &amp; Klau, G. W. (2021). Using anticlustering to
partition data sets into equivalent parts. <em>Psychological Methods,
26</em>(2), 161–174. <a href="https://doi.org/10.1037/met0000301" class="external-link uri">https://doi.org/10.1037/met0000301</a>.</p>
<p>Papenberg, M. (2024). K-plus Anticlustering: An Improved k-means
Criterion for Maximizing Between-Group Similarity. <em>British Journal
of Mathematical and Statistical Psychology, 77</em> (1), 80–102. <a href="https://doi.org/10.1111/bmsp.12315" class="external-link uri">https://doi.org/10.1111/bmsp.12315</a></p>
<p>Weitz, R., &amp; Lakshminarayanan, S. (1998). An empirical comparison
of heuristic methods for creating maximally diverse groups. <em>Journal
of the Operational Research Society, 49</em>(6), 635–646. <a href="https://doi.org/10.1057/palgrave.jors.2600510" class="external-link uri">https://doi.org/10.1057/palgrave.jors.2600510</a></p>
</div>
<div class="footnotes footnotes-end-of-document">
<hr>
<ol>
<li id="fn1"><p>Actually, four objectives are natively supported for the
<code><a href="../reference/anticlustering.html">anticlustering()</a></code> argument <code>objective</code>:
<code>"diversity"</code>, <code>"variance"</code> (i.e, k-means),
<code>"kplus"</code> and <code>"dispersion"</code>. However, the k-plus
objective as implemented in <code>anticlust</code> effectively re-uses
the original k-means criterion and just extends the input data
internally. So, k-plus anticlustering will be somewhat slower than
k-means anticlustering because the number of variables
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
does contribute to the overall run time; however, the run time is
usually dominated by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>,
the number of elements. The dispersion objective has a different goal
than the other objectives as it does not strive for between-group
similarity, so it cannot be used as an alternative to the other
objectives.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p><code><a href="../reference/fast_anticlustering.html">fast_anticlustering()</a></code> minimizes the
weighted sum of squared distances between cluster centroids and the
overall data centroid; the distances between all individual data points
and their cluster center are no longer computed.<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p>The primary disadvantage is that k-means anticlustering
only leads to similarity in means, but not in standard deviations or any
other distribution aspects; the k-plus criterion can be used to equalize
any distribution moments between groups.<a href="#fnref3" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

      </div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Martin Papenberg.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

      </footer>
</div>






  </body>
</html>
