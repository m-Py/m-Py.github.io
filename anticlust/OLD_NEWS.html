<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>anticlust 0.2.7 • anticlust</title><!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous"><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="bootstrap-toc.css"><script src="bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="pkgdown.css" rel="stylesheet"><script src="pkgdown.js"></script><meta property="og:title" content="anticlust 0.2.7"><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body data-spy="scroll" data-target="#toc">
    

    <div class="container template-title-body">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="index.html">anticlust</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">0.8.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav"><li>
  <a href="reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu"><li>
      <a href="articles/Best_practices.html">Some best practices for anticlustering</a>
    </li>
    <li>
      <a href="articles/Categorical_vars.html">Using categorical variables with anticlustering</a>
    </li>
    <li>
      <a href="articles/Speeding_up_anticlustering.html">Speeding up anticlustering</a>
    </li>
    <li>
      <a href="articles/stimulus-selection.html">Using the R package anticlust for stimulus selection in experiments</a>
    </li>
  </ul></li>
<li>
  <a href="news/index.html">Changelog</a>
</li>
<li>
  <a href="https://m-py.github.io/anticlust-blog" class="external-link">Blog</a>
</li>
      </ul><ul class="nav navbar-nav navbar-right"><li>
  <a href="https://github.com/m-Py/anticlust/" class="external-link">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header><div class="row">
  <div class="contents col-md-9">
    <div class="page-header">
      <h1>anticlust 0.2.7</h1>
    </div>


<div class="section level2">
<h2 id="anticlust-040">anticlust 0.4.0<a class="anchor" aria-label="anchor" href="#anticlust-040"></a></h2>
<p>2020-01-28</p>
<p>Major update. Many changes are due to the philosophy that future maintainability should be maximized. This mostly implies simplifying the exported functions, such as reducing the number of functions and the number of arguments for each exported function. I took the liberty to introduce some major changes to the existing functions; this version will be submitted to CRAN, after which such changes will no longer occur. Other changes bring about new possibilities for stimulus selection in experimental psychology (in particular, the new function <code><a href="reference/matching.html">matching()</a></code>).</p>
<p><strong>Major</strong></p>
<ul><li>A new exported function: <code><a href="reference/matching.html">matching()</a></code> finds groups of similar elements. Internally, <code><a href="reference/matching.html">matching()</a></code> calls the same clustering algorithm as <code><a href="reference/balanced_clustering.html">balanced_clustering()</a></code>, but it differs with regard to the arguments: In <code><a href="reference/matching.html">matching()</a></code>, you specify the size of the groups rather than the number of groups. Moreover, <code><a href="reference/matching.html">matching()</a></code> offers some unique functionality:
<ul><li>Conduct K-partite matching, that is: include a grouping vector (via argument <code>match_between</code>) and matches are selected between elements of different groups</li>
<li>Only match elements that are part of the same group (this categorical constraint is induced through the argument <code>match_within</code>)</li>
<li>The matches that are returned by <code><a href="reference/matching.html">matching()</a></code> are numbered by similarity; the group identified by <code>1</code> has the least sum of distances between matched elements etc.</li>
<li>In <code><a href="reference/balanced_clustering.html">balanced_clustering()</a></code>, nearest neighbours are first sought for extreme elements that are far away from the cluster centroid. In <code><a href="reference/matching.html">matching()</a></code>, it is possible to start searching for matches at the center (setting <code>match_extreme_first</code> to <code>FALSE</code>)</li>
<li>When a grouping restriction via <code>match_between</code> is included, it is possible to further specify how matches are selected through the option <code>target_group</code> is included. When specifying <code>"none"</code>, matches are always selected for extreme (or central elements first when <code>match_extreme_first = FALSE</code>). With option <code>"smallest"</code> (default), matches are selected from the smallest group specified in <code>match_between</code>. With option <code>"diverse"</code>, matches are selected from the group having the largest variance.</li>
</ul></li>
<li>All clustering and anticlustering functions now only take one data argument (called <code>x</code>). Internally, <code>anticlust</code> tests if the input is a distance matrix or not. This is a major improvement for the function interfaces.</li>
<li>The argument <code>iv</code> was removed from the function <code><a href="reference/anticlustering.html">anticlustering()</a></code> as it does not fit the anticlustering semantic. Its functionality is available in other functions (in particular: <code><a href="reference/matching.html">matching()</a></code>),</li>
<li>The random sampling method for anticlustering was removed. It was an unnecessary burden for the <code>anticlust</code> code base as it is much less performant than the exchange method. (This implies that the <code><a href="reference/anticlustering.html">anticlustering()</a></code> function no longer has an argument <code>nrep</code>)</li>
<li>The functions <code>initialize_K()</code> and <code><a href="reference/generate_exchange_partners.html">generate_exchange_partners()</a></code> were removed. They did not fit into the current design philosophy of the project (as soon as <code>anticlust</code> hits CRAN I will no longer remove exported functions)</li>
<li>It is no longer possible to pass a cluster assignment to <code><a href="reference/anticlustering.html">anticlustering()</a></code> via argument <code>K</code> that contains some <code>NA</code>. This functionality is now obsolete because the function <code><a href="reference/matching.html">matching()</a></code> exists for subset selection (see the package vignette)</li>
<li>Alas, dropped support for the commercial linear programming solvers that hinder compatibility with CRAN checks
<ul><li>Using the commericial solvers to solve anticluster editing or cluster editing is still be possible via version 0.3.0 that is tagged on Github</li>
<li>install version 0.3.0 through <code>remotes::install_github("m-Py/anticlust", ref = "v0.3.0")</code>
</li>
</ul></li>
</ul><p><strong>Minor</strong></p>
<ul><li>A new exported convenience function: <code><a href="reference/plot_similarity.html">plot_similarity()</a></code> plot the sum of pairwise distances by cluster to find out which clusters are highly similar</li>
<li>The function <code>mean_sd_obj()</code> no longer computes the discrepancy of medians, only in means and standard deviations (as the name would also suggest)</li>
<li>Function <code><a href="reference/plot_clusters.html">plot_clusters()</a></code>
<ul><li>removed arguments <code>col</code> and <code>pch</code>
</li>
<li>renamed argument <code>clustering</code> to <code>clusters</code>
</li>
</ul></li>
<li>Funtion <code><a href="reference/generate_partitions.html">generate_partitions()</a></code>
<ul><li>changed order of the arguments <code>N</code> and <code>K</code> (is now consistent with <code><a href="reference/n_partitions.html">n_partitions()</a></code>)</li>
</ul></li>
<li>Function <code><a href="reference/balanced_clustering.html">balanced_clustering()</a></code>
<ul><li>the default heuristic option is now called <code>"centroid"</code>
</li>
</ul></li>
</ul></div>
<div class="section level2">
<h2 id="anticlust-030">anticlust 0.3.0<a class="anchor" aria-label="anchor" href="#anticlust-030"></a></h2>
<p>2019-10-30</p>
<p>This is a rather big update including several changes that may break code used with earlier versions.</p>
<ul><li><p>The package title was changed to »<code>anticlust</code>: Subset partitioning via anticlustering«</p></li>
<li><p>The arguments <code>parallelize</code>, <code>seed</code> and <code>standardize</code> were removed from the function <code><a href="reference/anticlustering.html">anticlustering()</a></code>. Parallelization was used to speed up the random sampling method, but as the exchange algorithm has proven to be much better—for which reason I do not intend to extend code for the random sampling method—having options for parallelization is an unnecessary burden in my code base. Therefore, the option <code>seed</code> is also no longer needed as it was only used to ensure reproducibility when using the parallel option. The argument <code>standardize</code> has also been removed. Users now have to manually call the function <code><a href="https://rdrr.io/r/base/scale.html" class="external-link">scale()</a></code> on the input before calling the <code><a href="reference/anticlustering.html">anticlustering()</a></code> function if they wish to standardize the input. The philosophy behind these changes is that the main function of the <code>anticlust</code> package should not have too many arguments, making it easier usable. I also expect that it this makes it easier to adapt the code base in the future.</p></li>
<li><p>Minor change: The argument <code>preclustering</code> now only accepts <code>TRUE</code>/<code>FALSE</code> as it used to before (see the discussion <a href="https://github.com/m-Py/anticlust/issues/19" class="external-link">here</a>). To induce customized clustering constraints, we can still use the argument <code>categories</code>. In the following example, we restrict the exchange partners for each element to four similar elements by creating clusters of size 5:</p></li>
</ul><div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="reference/anticlustering.html">anticlustering</a></span><span class="op">(</span></span>
<span>  <span class="va">iris</span><span class="op">[</span>, <span class="op">-</span><span class="fl">5</span><span class="op">]</span>,</span>
<span>  K <span class="op">=</span> <span class="fl">3</span>,</span>
<span>  categories <span class="op">=</span> <span class="fu"><a href="reference/balanced_clustering.html">balanced_clustering</a></span><span class="op">(</span><span class="va">iris</span><span class="op">[</span>, <span class="op">-</span><span class="fl">5</span><span class="op">]</span>, K <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<ul><li><p>An enhancement was added to the <code><a href="reference/balanced_clustering.html">balanced_clustering()</a></code> function: The heuristic algorithm to create equal-sized clusters was replaced by one that is much faster and better (courteously contributed by <a href="https://reaktanz.de/?c=hacking&amp;s=koRpus" class="external-link">Meik Michalke</a>). This method is also called when the argument <code>preclustering</code> is <code>TRUE</code> in a function call of the <code><a href="reference/anticlustering.html">anticlustering()</a></code> function (unless the argument <code>method</code> is “ilp”, in which case an exact clustering algorithm is called).</p></li>
<li><p>A new function is available: <code><a href="reference/n_partitions.html">n_partitions()</a></code> computes the number of equal-sized partitions for given <em>N</em> and <em>K</em>.</p></li>
<li><p>A new function is available: <code><a href="reference/generate_exchange_partners.html">generate_exchange_partners()</a></code> can be used to group elements that serve as exchange partners when using one of the functions <code><a href="reference/anticlustering.html">anticlustering()</a></code> or <code><a href="reference/fast_anticlustering.html">fast_anticlustering()</a></code>. This is good because users can now easily speed up anticlustering computations by reducing the number of exchange partners. The function also enables the possibility to combine categorical and preclustering restrictions, see <code>?generate_exchange_partners()</code> (it is still not possible to combine <code>preclustering = TRUE</code> and the <code>categories</code> argument). In the following example, we restrict the exchange partners to four random elements within the same species:</p></li>
</ul><div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="reference/anticlustering.html">anticlustering</a></span><span class="op">(</span></span>
<span>  <span class="va">iris</span><span class="op">[</span>, <span class="op">-</span><span class="fl">5</span><span class="op">]</span>,</span>
<span>  K <span class="op">=</span> <span class="fl">3</span>,</span>
<span>  categories <span class="op">=</span> <span class="fu"><a href="reference/generate_exchange_partners.html">generate_exchange_partners</a></span><span class="op">(</span></span>
<span>    categories <span class="op">=</span> <span class="va">iris</span><span class="op">[</span>, <span class="fl">5</span><span class="op">]</span>, </span>
<span>    p <span class="op">=</span> <span class="fl">4</span></span>
<span>  <span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<ul><li>Note that the function <code><a href="reference/generate_exchange_partners.html">generate_exchange_partners()</a></code> takes as argument the number of exchange partners «<code>p</code>»; this is different from the anticlustering and clustering functions that take as input the size of the expected cluster «<code>K</code>». Hence, <code>K = 5</code> and <code>p = 4</code> will lead to the same number of exchange partners.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> In another example, we restrict the exchange partners to four similar elements within the same species (here, balanced input is necessary again because internally, clusters of equal size are computed using the function <code><a href="reference/balanced_clustering.html">balanced_clustering()</a></code> on each category separately):</li>
</ul><div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="reference/anticlustering.html">anticlustering</a></span><span class="op">(</span></span>
<span>  <span class="va">iris</span><span class="op">[</span>, <span class="op">-</span><span class="fl">5</span><span class="op">]</span>,</span>
<span>  K <span class="op">=</span> <span class="fl">3</span>,</span>
<span>  categories <span class="op">=</span> <span class="fu"><a href="reference/generate_exchange_partners.html">generate_exchange_partners</a></span><span class="op">(</span></span>
<span>    features <span class="op">=</span> <span class="va">iris</span><span class="op">[</span>, <span class="op">-</span><span class="fl">5</span><span class="op">]</span>, </span>
<span>    categories <span class="op">=</span> <span class="va">iris</span><span class="op">[</span>, <span class="fl">5</span><span class="op">]</span>, </span>
<span>    p <span class="op">=</span> <span class="fl">4</span>, </span>
<span>    similar <span class="op">=</span> <span class="cn">TRUE</span></span>
<span>  <span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>Moreover, several internal changes were implemented to the code base to enhance future maintainability. For example, to differentiate between distance and features input, custom S3 classes are added to the data matrices. For anyone inspecting the source code and wondering why I use customized classes instead of just using the class <code>dist</code> for distance input: usually, I want a complete matrix (having upper and lower triangular) and not a reduced matrix of class <code>dist</code>. Also, it is not really more effort to add a custom S3 class.</p>
</div>
<div class="section level2">
<h2 id="anticlust-029-5">anticlust 0.2.9-5<a class="anchor" aria-label="anchor" href="#anticlust-029-5"></a></h2>
<p>2019-09-17</p>
<ul><li>Fix: Random assignment under categorical restrictions failed if a category only had one member because in this case <code>sample</code> was called with an vector input of length 1, e.g., <code>sample(9)</code> actually returns <code>sample(1:9)</code> but should return 9 in this case. This was fixed with <a href="https://github.com/m-Py/anticlust/commit/f53bf4ec19a9cefe44b1639a814bc97c61f4181b" class="external-link">f53bf4e</a>.</li>
<li>There is no longer any error tolerance with the CPLEX solver; previously there was an optimality gap of 1e-11, but now it is 0.</li>
<li>There is a new exported fuction: <code><a href="reference/wce.html">wce()</a></code>. This corresponds to optimal weighted cluster editing without group size restrictions. Optimality means: an ILP solver is required to use this function. Note that the (only) argument <code>weights</code> is a <strong>similarity</strong> matrix, i.e., larger values indicate stronger agreement between elements. This is unlike the other functions, but common for cluster editing.</li>
</ul></div>
<div class="section level2">
<h2 id="anticlust-029-4">anticlust 0.2.9-4<a class="anchor" aria-label="anchor" href="#anticlust-029-4"></a></h2>
<p>2019-07-23</p>
<p>Internal change: Optimizing the exchange method with the default distance objective is now much faster. This is accomplished by only updating the sum of distances after each exchange, instead of recomputing all distances (see <a href="https://github.com/m-Py/anticlust/commit/d51e59d56d2d4b679db6a7969f5a5c71ac0d4438" class="external-link">d51e59d</a>)</p>
<p>This example illustrates the run time improvement:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># For N = 20 to N = 300, test run time for old and new </span></span>
<span><span class="co"># optimization of distance criterion:</span></span>
<span></span>
<span><span class="va">n</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">20</span>, <span class="fl">300</span>, by <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></span>
<span><span class="va">times</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span>nrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">n</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span><span class="va">times</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">n</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">colnames</a></span><span class="op">(</span><span class="va">times</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"n"</span>, <span class="st">"old_features_input"</span>, <span class="st">"old_distance_input"</span>, <span class="st">"new_distance"</span><span class="op">)</span></span>
<span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq_along</a></span><span class="op">(</span><span class="va">n</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">start</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Sys.time.html" class="external-link">Sys.time</a></span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span>  <span class="co"># Simulate 2 features as input data</span></span>
<span>  <span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">n</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">*</span> <span class="fl">2</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span>  <span class="co">## Old version: feature table as input</span></span>
<span>  <span class="va">ac1</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/anticlustering.html">anticlustering</a></span><span class="op">(</span></span>
<span>    <span class="va">data</span>,</span>
<span>    K <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep_len</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span><span class="op">)</span>,</span>
<span>    objective <span class="op">=</span> <span class="fu">anticlust</span><span class="fu">:::</span><span class="va">obj_value_distance</span></span>
<span>  <span class="op">)</span></span>
<span>  <span class="va">times</span><span class="op">[</span><span class="va">i</span>, <span class="st">"old_features_input"</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/difftime.html" class="external-link">difftime</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Sys.time.html" class="external-link">Sys.time</a></span><span class="op">(</span><span class="op">)</span>, <span class="va">start</span>, units <span class="op">=</span> <span class="st">"s"</span><span class="op">)</span></span>
<span></span>
<span>  <span class="co">## Old version: distance matrix as input</span></span>
<span>  <span class="va">ac2</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/anticlustering.html">anticlustering</a></span><span class="op">(</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/stats/dist.html" class="external-link">dist</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span>,</span>
<span>    K <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep_len</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span><span class="op">)</span>,</span>
<span>    objective <span class="op">=</span> <span class="fu">anticlust</span><span class="fu">:::</span><span class="va">distance_objective_</span></span>
<span>  <span class="op">)</span></span>
<span>  <span class="va">times</span><span class="op">[</span><span class="va">i</span>, <span class="st">"old_distance_input"</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/difftime.html" class="external-link">difftime</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Sys.time.html" class="external-link">Sys.time</a></span><span class="op">(</span><span class="op">)</span>, <span class="va">start</span>, units <span class="op">=</span> <span class="st">"s"</span><span class="op">)</span></span>
<span></span>
<span>  <span class="va">start</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Sys.time.html" class="external-link">Sys.time</a></span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="va">ac3</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/anticlustering.html">anticlustering</a></span><span class="op">(</span></span>
<span>    <span class="va">data</span>,</span>
<span>    K <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep_len</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span><span class="op">)</span>,</span>
<span>    objective <span class="op">=</span> <span class="st">"distance"</span></span>
<span>  <span class="op">)</span></span>
<span>  <span class="va">times</span><span class="op">[</span><span class="va">i</span>, <span class="st">"new_distance"</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/difftime.html" class="external-link">difftime</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Sys.time.html" class="external-link">Sys.time</a></span><span class="op">(</span><span class="op">)</span>, <span class="va">start</span>, units <span class="op">=</span> <span class="st">"s"</span><span class="op">)</span></span>
<span></span>
<span>  <span class="co">## Ensures that all methods have the same output</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/stopifnot.html" class="external-link">stopifnot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/all.html" class="external-link">all</a></span><span class="op">(</span><span class="va">ac1</span> <span class="op">==</span> <span class="va">ac2</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/stopifnot.html" class="external-link">stopifnot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/all.html" class="external-link">all</a></span><span class="op">(</span><span class="va">ac1</span> <span class="op">==</span> <span class="va">ac3</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="va">times</span>, <span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#         n old_features_input old_distance_input new_distance</span></span>
<span><span class="co">#  [1,]  20               0.08               0.12         0.01</span></span>
<span><span class="co">#  [2,]  40               0.26               0.50         0.03</span></span>
<span><span class="co">#  [3,]  60               0.72               1.36         0.10</span></span>
<span><span class="co">#  [4,]  80               1.07               2.62         0.22</span></span>
<span><span class="co">#  [5,] 100               1.81               4.98         0.46</span></span>
<span><span class="co">#  [6,] 120               3.84              11.17         0.82</span></span>
<span><span class="co">#  [7,] 140               3.72              13.17         1.33</span></span>
<span><span class="co">#  [8,] 160               5.20              20.65         2.16</span></span>
<span><span class="co">#  [9,] 180               7.30              31.48         2.44</span></span>
<span><span class="co"># [10,] 200               8.63              37.96         3.38</span></span>
<span><span class="co"># [11,] 220              10.97              53.26         4.80</span></span>
<span><span class="co"># [12,] 240              13.78              74.17         6.66</span></span>
<span><span class="co"># [13,] 260              17.49             106.81         8.43</span></span>
<span><span class="co"># [14,] 280              20.40             149.38        12.23</span></span>
<span><span class="co"># [15,] 300              27.21             178.46        15.20</span></span></code></pre></div>
<p>As shown in the code and in the output table, two different objective functions could be called when the exchange algorithm was employed, depending on the input: When a feature table was passed, the internal function <code>anticlust:::obj_value_distance</code> was called in each iteration of the exchange algorithm; When a distance matrix was passed, the internal function <code>anticlust:::distance_objective_</code> was called in each iteration of the exchange algorithm. The former function computes all between-element distances within each set and returns their sum (using the <code>R</code> functions <code>by</code>, <code>dist</code>, <code>sapply</code> and <code>sum</code>). The latter function stores all distances and will index the relevant distances and return their sum. Interestingly, this indexing approach was a lot slower than recomputing all distances every iteration in the exchange algorithm.</p>
<p>In the new version, there no longer is a difference between a feature and distance input; in both cases, the sum of distances is updated based on only the relevant columns/rows in a distance matrix (that means, in each iteration of the exchange method, 4 rows/columns need to be investigated, independent of N). The new approach is a lot faster and especially benefial when we pass distance as input.</p>
</div>
<div class="section level2">
<h2 id="anticlust-029-3">anticlust 0.2.9-3<a class="anchor" aria-label="anchor" href="#anticlust-029-3"></a></h2>
<p>2019-07-22</p>
<p>New feature:</p>
<ul><li>There is now an argument <code>iv</code> for the function <code><a href="reference/anticlustering.html">anticlustering()</a></code>. It can be used for »min-max anticlustering«; <code>iv</code> then contains numeric features (vector, matrix or data frame) whose values are made dissimilar between sets – as opposed to the usual anticlustering where all features are made similar. See <code><a href="reference/schaper2019.html">?schaper2019</a></code> for an example.</li>
</ul></div>
<div class="section level2">
<h2 id="anticlust-029-2">anticlust 0.2.9-2<a class="anchor" aria-label="anchor" href="#anticlust-029-2"></a></h2>
<p>2019-07-18</p>
<p>New features:</p>
<ul><li>In the <code><a href="reference/anticlustering.html">anticlustering()</a></code> function, the argument <code>K</code> can now be a vector that serves as the initiation of the anticlusters (This functionality is only available when <code>method = "exchange"</code>).
<ul><li>Subset selection is now possible. Subset selection means that not all input item are assigned to a set, but from the total input a subset is selected that is assigned to the different sets. This functionality is enabled by passing a initial cluster assignment via the argument <code>K</code> that contains some <code>NA</code> (For example, if N = 50 and two sets of 20 items should be created, the argument <code>K</code> will contain 10 elements that are <code>NA</code>, 20 times 1, and 20 times 2.)</li>
<li>By using a customized <code>K</code> as input, it is now also possible to create sets of different size (e.g. <code>K = c(1, 1, 1, 1, 2, 2)</code>)</li>
<li>The function <code>initialize_K()</code> can be used to generate initial anticluster assignments in a user-friendly way. The documentation of the function <code>initialize_K()</code> contains example code how to conduct subset selection and anticlustering with different set sizes.</li>
</ul></li>
<li>A new objective function was added: <code>mean_sd_obj()</code>. Maximizing this objective will simply make all sets similar with regard to the mean, median and the standard deviation of all input features.</li>
</ul><p>Internal changes:</p>
<ul><li>Major internal restructuring to improve the expected maintainability in the future. In the last weeks, a lot of features were added to <code>anticlust</code> and a restructuring seemed necessary.</li>
<li>Many test cases were added to test the features that were added in the previous weeks.</li>
<li>To accommodate the possibility that the argument <code>K</code> contains <code>NA</code>, the objective function to be optimized will be restructured internally. In particular, before the objective is computed, all cases are removed where the cluster is <code>NA</code> (i.e., cases that are currently not assigned to any set). This also works for user-defined objective functions, so users do not need to deal with the handling of <code>NA</code> themselves.</li>
</ul></div>
<div class="section level2">
<h2 id="anticlust-029">anticlust 0.2.9<a class="anchor" aria-label="anchor" href="#anticlust-029"></a></h2>
<p>2019-07-09</p>
<ul><li>A bug was fixed that led to an incorrect computation of the objective function for anticluster editing when employing the exchange method (see <a href="https://github.com/m-Py/anticlust/commit/243ca642be787e8c59ece4dbbb1b567fdac05656" class="external-link">243ca64</a>). Tests show that the exchange method now outperforms random sampling for anticluster editing (as well as for k-means anticlustering). Therefore, the exchange method is now the default method (see <a href="https://github.com/m-Py/anticlust/commit/b101073602906b6b9bbf00c76943668f43407e0e" class="external-link">b101073</a>).</li>
<li>The fast exchange method is now used when optimizing the variance criterion in a call to <code><a href="reference/anticlustering.html">anticlustering()</a></code>. This improves run time by a large margin for this important application. See <a href="https://github.com/m-Py/anticlust/commit/2f47feaf05aee1d53b60bf78bb7c02994a4659c9" class="external-link">2f47fea</a>.</li>
<li>Two changes with regard to the functionality of arguments in <code><a href="reference/anticlustering.html">anticlustering()</a></code>
<ul><li>It is possible that the argument <code>objective</code> now takes as input a function. The passed function has to take two arguments, the first being a cluster assignment vector (such as returned by <code><a href="reference/anticlustering.html">anticlustering()</a></code>), the second being the data the objective is computed on (e.g. an N x M matrix where rows are elements and columns are features). Larger return values must indicate a better objective as the objective is maximized with the existing methods (exchange method and random sampling). This functionality makes it possible for users to implement their own operationalization of set similarity.</li>
<li>It is possible that the argument <code>preclustering</code> now takes as input a preclustering vector and not only <code>TRUE</code> or <code>FALSE</code> (in the former case, the preclustering vector has been computed within the <code><a href="reference/anticlustering.html">anticlustering()</a></code> function). This allows for more flexibility in combining preclustering and anticlustering methods. For example, it is now possible to conduct optimal preclustering using integer linear programming with the function <code><a href="reference/balanced_clustering.html">balanced_clustering()</a></code>, and then use a heuristic anticlustering method that incorporates this preclustering.</li>
<li>Both of these changes have not yet been added to the function documentation as they require some more testing.</li>
</ul></li>
<li>The <code><a href="reference/fast_anticlustering.html">fast_anticlustering()</a></code> function has been documented more thoroughly and part of the <code><a href="reference/anticlustering.html">anticlustering()</a></code> docs have been reworked (now advocating the exchange method as the preferable option).</li>
</ul></div>
<div class="section level2">
<h2 id="anticlust-028">anticlust 0.2.8<a class="anchor" aria-label="anchor" href="#anticlust-028"></a></h2>
<p>2019-07-05</p>
<p>A new exported function is available: <code><a href="reference/fast_anticlustering.html">fast_anticlustering()</a></code>. As the name suggests, it is optimized for speed and particularly useful for large data sets (many thousand elements). It uses the k-means variance objective because computing all pairwise distances for the cluster editing objective becomes computationally infeasible for large data sets. Additionally, it employs a speed-optimized exchange method. The number of exchange partners can be adjusted using the argument <code>k_neighbours</code>. Fewer exchange partners make it possible to apply the <code><a href="reference/fast_anticlustering.html">fast_anticlustering()</a></code> function to very large data sets. The default value for <code>k_neighbours</code> is <code>Inf</code>, meaning that in the default case, each element is swapped with all other elements.</p>
</div>
<div id="anticlust-027" class="section level1">

<p>2019-07-01</p>
<p>A big update:</p>
<ul><li>A new algorithm for anticlustering is available: the exchange method. Building on an initial random assignment, elements are swapped between anticlusters in such a way that each swap improves anticluster similarity by the largest amount that is possible (cf. Späth, 1986). This procedure is repeated for each element; because each possible swap is investigated for each element, the total number of exchanges grows quadratically with input size, rendering the exchange method unsuitable for large N. Setting <code>preclustering = TRUE</code> will limit the legal exchange partners to very similar elements, resulting in improved run time while preserving a rather good solution. The exchange method outperforms the random sampling heuristic for k-means anticlustering. The exchange method may incorporate both categorical and preclustering constraints, which is not possible for the random sampling approach. As there are now two heuristic methods (random sampling and exchange) the argument <code>method</code> of the function <code><a href="reference/anticlustering.html">anticlustering()</a></code> now has the following three possible values: “sampling”, “exchange”, “ilp”. In earlier versions, the two options were “heuristic” and “ilp”; this change does not break earlier code because using <code>method = "heuristic"</code> will still refer to the random sampling method.</li>
<li>A new function <code>generate_partitions</code> can be used to generate all partitions, making it possible to solve anticlustering via complete enumeration. In particular, it is now possible—for small problem instances—to solve k-means anticlustering optimally, which cannot be done with integer linear programming. The help file (<code><a href="reference/generate_partitions.html">?generate_partitions</a></code>) contains example code illustrating how to do this.</li>
</ul><p>Minor changes:</p>
<ul><li>The “variance” criterion can now be computed when there are missing values in the input data.</li>
<li>In <code>plot_clusters</code>, it is now possible to adjust the size of the cluster centroid using the new argument <code>cex_centroid</code>
</li>
</ul><div class="section level2">
<h2 id="anticlust-026">anticlust 0.2.6<a class="anchor" aria-label="anchor" href="#anticlust-026"></a></h2>
<p>2019-06-19</p>
<p>Minor update: <code>plot_clusters</code> now has an additional argument <code>illustrate_variance</code>. If this argument is set to <code>TRUE</code>, a cluster solution is illustrated with the k-means variance criterion.</p>
</div>
<div class="section level2">
<h2 id="anticlust-025">anticlust 0.2.5<a class="anchor" aria-label="anchor" href="#anticlust-025"></a></h2>
<p>2019-05-27</p>
<p>The new version of anticlust now enables parallelization of the random sampling method, improving run time.</p>
<ul><li>The <code>anticlustering</code> function now has an additional argument (<code>parallelize</code>) that can be used to activate parallel computation when using the heuristic method</li>
<li>For now, the default value of <code>parallelize</code> is <code>FALSE</code>
</li>
<li>Another argument was added (<code>seed</code>) to make the random sampling method reproducible
<ul><li>Just using <code><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed()</a></code> prior to the computation does not make a function call reproducible when <code>parallelize</code> is <code>TRUE</code> because each core has its own random seed</li>
<li>The <code>seed</code> argument is optional</li>
</ul></li>
</ul><p>An example data set is now included with the package, courteously provided by Marie Lusia Schaper and Ute Bayen. For details, see <code><a href="reference/schaper2019.html">?schaper2019</a></code>.</p>
</div>
<div class="section level2">
<h2 id="anticlust-024">anticlust 0.2.4<a class="anchor" aria-label="anchor" href="#anticlust-024"></a></h2>
<p>2019-04-26</p>
<p>The new version of anticlust includes support for constraints induced by grouping variables.</p>
<ul><li>The <code>anticlustering</code> function now has an optional argument (<code>categories</code>) that can be used to induce categorical constraints</li>
<li>
<code>categories</code> can be a vector if there is is one grouping variable or a matrix/data if there is more than one grouping variable</li>
<li>Currently, <code>categories</code> can only be used with the random sampling method (<code>method = "heuristic"</code>)</li>
<li>
<code>categories</code> overrides the value of <code>preclustering</code>; it is not possible to use categorical and preclustering constraints at the same time</li>
</ul><p>In <code>anticlustering</code>, the default value of <code>preclustering</code> is now FALSE.</p>
</div>
</div>
<div class="footnotes footnotes-end-of-document">
<hr><ol><li id="fn1"><p>Maybe the argument <code>p</code> will be added to the <code><a href="reference/anticlustering.html">anticlustering()</a></code> function in a future release (in this case, the function <code><a href="reference/generate_exchange_partners.html">generate_exchange_partners()</a></code> would be called internally). This is probably a useful extension.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
</ol></div>


  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top"><h2 data-toc-skip>Contents</h2>
    </nav></div>

</div>



      <footer><div class="copyright">
  <p></p><p>Developed by Martin Papenberg.</p>
</div>

<div class="pkgdown">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer></div>

  


  

  </body></html>

