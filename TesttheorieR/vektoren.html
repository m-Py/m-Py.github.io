<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title></title>
  <meta name="description" content="Testtheorie mit R">
  <meta name="generator" content="bookdown  and GitBook 2.6.7">

  <meta property="og:title" content="" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="" />
  
  
  




  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="einstieg.html">
<link rel="next" href="dataframes.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="1" data-path="einstieg.html"><a href="einstieg.html"><i class="fa fa-check"></i><b>1</b> Einstieg</a><ul>
<li class="chapter" data-level="1.1" data-path="einstieg.html"><a href="einstieg.html#uber-dieses-skript"><i class="fa fa-check"></i><b>1.1</b> Über dieses Skript</a><ul>
<li class="chapter" data-level="1.1.1" data-path="einstieg.html"><a href="einstieg.html#feedback-und-fehlermeldungen"><i class="fa fa-check"></i><b>1.1.1</b> Feedback und Fehlermeldungen</a></li>
<li class="chapter" data-level="1.1.2" data-path="einstieg.html"><a href="einstieg.html#danksagung"><i class="fa fa-check"></i><b>1.1.2</b> Danksagung</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="einstieg.html"><a href="einstieg.html#erste-schritte-mit-r"><i class="fa fa-check"></i><b>1.2</b> Erste Schritte mit <code>R</code></a><ul>
<li class="chapter" data-level="1.2.1" data-path="einstieg.html"><a href="einstieg.html#die-r-konsole"><i class="fa fa-check"></i><b>1.2.1</b> Die <code>R</code>-Konsole</a></li>
<li class="chapter" data-level="1.2.2" data-path="einstieg.html"><a href="einstieg.html#der-skript-editor"><i class="fa fa-check"></i><b>1.2.2</b> Der Skript-Editor</a></li>
<li class="chapter" data-level="1.2.3" data-path="einstieg.html"><a href="einstieg.html#kommentare"><i class="fa fa-check"></i><b>1.2.3</b> Kommentare</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="einstieg.html"><a href="einstieg.html#ausblick"><i class="fa fa-check"></i><b>1.3</b> Ausblick</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="vektoren.html"><a href="vektoren.html"><i class="fa fa-check"></i><b>2</b> Vektoren</a><ul>
<li class="chapter" data-level="2.1" data-path="vektoren.html"><a href="vektoren.html#variablen"><i class="fa fa-check"></i><b>2.1</b> Variablen</a><ul>
<li class="chapter" data-level="2.1.1" data-path="vektoren.html"><a href="vektoren.html#ausgabevsabspeichern"><i class="fa fa-check"></i><b>2.1.1</b> Ausgabe versus Abspeichern</a></li>
<li class="chapter" data-level="2.1.2" data-path="vektoren.html"><a href="vektoren.html#variablennamen"><i class="fa fa-check"></i><b>2.1.2</b> Variablennamen</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="vektoren.html"><a href="vektoren.html#datentypen-von-vektoren"><i class="fa fa-check"></i><b>2.2</b> Datentypen von Vektoren</a><ul>
<li class="chapter" data-level="2.2.1" data-path="vektoren.html"><a href="vektoren.html#character"><i class="fa fa-check"></i><b>2.2.1</b> <code>character</code></a></li>
<li class="chapter" data-level="2.2.2" data-path="vektoren.html"><a href="vektoren.html#logical"><i class="fa fa-check"></i><b>2.2.2</b> <code>logical</code></a></li>
<li class="chapter" data-level="2.2.3" data-path="vektoren.html"><a href="vektoren.html#factor"><i class="fa fa-check"></i><b>2.2.3</b> <code>factor</code></a></li>
<li class="chapter" data-level="2.2.4" data-path="vektoren.html"><a href="vektoren.html#na"><i class="fa fa-check"></i><b>2.2.4</b> <code>NA</code></a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="vektoren.html"><a href="vektoren.html#logischevergleiche"><i class="fa fa-check"></i><b>2.3</b> Logische Vergleiche</a><ul>
<li class="chapter" data-level="2.3.1" data-path="vektoren.html"><a href="vektoren.html#anwendungsbeispiel-uberprufe-das-gesetz-der-groen-zahlen"><i class="fa fa-check"></i><b>2.3.1</b> Anwendungsbeispiel: Überprüfe das Gesetz der großen Zahlen</a></li>
<li class="chapter" data-level="2.3.2" data-path="vektoren.html"><a href="vektoren.html#der-in-operator"><i class="fa fa-check"></i><b>2.3.2</b> Der <code>%in%</code> Operator</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="vektoren.html"><a href="vektoren.html#zugriff-auf-vektorelemente"><i class="fa fa-check"></i><b>2.4</b> Zugriff auf Vektorelemente</a><ul>
<li class="chapter" data-level="2.4.1" data-path="vektoren.html"><a href="vektoren.html#veczugriff"><i class="fa fa-check"></i><b>2.4.1</b> Der <code>[·]</code>-Zugriff</a></li>
<li class="chapter" data-level="2.4.2" data-path="vektoren.html"><a href="vektoren.html#logischerZugriff"><i class="fa fa-check"></i><b>2.4.2</b> <code>[·]</code>-Zugriff mit einem logischen Vektor</a></li>
<li class="chapter" data-level="2.4.3" data-path="vektoren.html"><a href="vektoren.html#vektorAendern"><i class="fa fa-check"></i><b>2.4.3</b> <code>[·]</code>-Zugriff zum Ändern von Daten</a></li>
</ul></li>
<li class="chapter" data-level="2.5" data-path="vektoren.html"><a href="vektoren.html#praezedenz"><i class="fa fa-check"></i><b>2.5</b> Präzedenz</a></li>
<li class="chapter" data-level="2.6" data-path="vektoren.html"><a href="vektoren.html#zusammenfassung"><i class="fa fa-check"></i><b>2.6</b> Zusammenfassung</a></li>
<li class="chapter" data-level="2.7" data-path="vektoren.html"><a href="vektoren.html#fragen-zum-vertiefenden-verstandnis"><i class="fa fa-check"></i><b>2.7</b> Fragen zum vertiefenden Verständnis</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="dataframes.html"><a href="dataframes.html"><i class="fa fa-check"></i><b>3</b> <code>data.frames</code></a><ul>
<li class="chapter" data-level="3.1" data-path="dataframes.html"><a href="dataframes.html#die-funktion-data.frame"><i class="fa fa-check"></i><b>3.1</b> Die Funktion <code>data.frame</code></a></li>
<li class="chapter" data-level="3.2" data-path="dataframes.html"><a href="dataframes.html#zugriff-auf-eine-einzelne-spalte-die--notation"><i class="fa fa-check"></i><b>3.2</b> Zugriff auf eine einzelne Spalte: die <code>$</code>-Notation</a></li>
<li class="chapter" data-level="3.3" data-path="dataframes.html"><a href="dataframes.html#datenzugriffe"><i class="fa fa-check"></i><b>3.3</b> Zugriff auf Spalten und Zeilen: die <code>[·,·]</code>-Notation</a></li>
<li class="chapter" data-level="3.4" data-path="dataframes.html"><a href="dataframes.html#subset"><i class="fa fa-check"></i><b>3.4</b> Die Funktion <code>subset</code></a><ul>
<li class="chapter" data-level="3.4.1" data-path="dataframes.html"><a href="dataframes.html#zeileneinfach"><i class="fa fa-check"></i><b>3.4.1</b> Vereinfachte Zeilenauswahl</a></li>
<li class="chapter" data-level="3.4.2" data-path="dataframes.html"><a href="dataframes.html#teaserfunktionen"><i class="fa fa-check"></i><b>3.4.2</b> Funktionsargumente</a></li>
<li class="chapter" data-level="3.4.3" data-path="dataframes.html"><a href="dataframes.html#spalteneinfach"><i class="fa fa-check"></i><b>3.4.3</b> Sonderregeln zur Auswahl von Spalten</a></li>
</ul></li>
<li class="chapter" data-level="3.5" data-path="dataframes.html"><a href="dataframes.html#doppelteckig"><i class="fa fa-check"></i><b>3.5</b> Weitere Zugriffe auf <code>data.frames</code></a><ul>
<li class="chapter" data-level="3.5.1" data-path="dataframes.html"><a href="dataframes.html#der--zugriff"><i class="fa fa-check"></i><b>3.5.1</b> Der <code>[[·]]</code>-Zugriff</a></li>
<li class="chapter" data-level="3.5.2" data-path="dataframes.html"><a href="dataframes.html#der--zugriff-1"><i class="fa fa-check"></i><b>3.5.2</b> Der <code>[·]</code>-Zugriff</a></li>
<li class="chapter" data-level="3.5.3" data-path="dataframes.html"><a href="dataframes.html#nameindex"><i class="fa fa-check"></i><b>3.5.3</b> Zugriff nach Name und Index</a></li>
</ul></li>
<li class="chapter" data-level="3.6" data-path="dataframes.html"><a href="dataframes.html#convenient"><i class="fa fa-check"></i><b>3.6</b> Nützliche Funktionen zum Arbeiten mit <code>data.frames</code></a><ul>
<li class="chapter" data-level="3.6.1" data-path="dataframes.html"><a href="dataframes.html#tapply"><i class="fa fa-check"></i><b>3.6.1</b> <code>tapply</code></a></li>
<li class="chapter" data-level="3.6.2" data-path="dataframes.html"><a href="dataframes.html#nrow-und-ncol"><i class="fa fa-check"></i><b>3.6.2</b> <code>nrow</code> und <code>ncol</code></a></li>
<li class="chapter" data-level="3.6.3" data-path="dataframes.html"><a href="dataframes.html#head-und-tail"><i class="fa fa-check"></i><b>3.6.3</b> <code>head</code> und <code>tail</code></a></li>
<li class="chapter" data-level="3.6.4" data-path="dataframes.html"><a href="dataframes.html#sortieren-dplyrarrange"><i class="fa fa-check"></i><b>3.6.4</b> Sortieren: <code>dplyr::arrange</code></a></li>
</ul></li>
<li class="chapter" data-level="3.7" data-path="dataframes.html"><a href="dataframes.html#zusammenfassung-1"><i class="fa fa-check"></i><b>3.7</b> Zusammenfassung</a></li>
<li class="chapter" data-level="3.8" data-path="dataframes.html"><a href="dataframes.html#fragen-zum-vertiefenden-verstandnis-1"><i class="fa fa-check"></i><b>3.8</b> Fragen zum vertiefenden Verständnis</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="psychometrie.html"><a href="psychometrie.html"><i class="fa fa-check"></i><b>4</b> Arbeiten mit psychometrischen Daten</a><ul>
<li class="chapter" data-level="4.1" data-path="psychometrie.html"><a href="psychometrie.html#kap4einstieg"><i class="fa fa-check"></i><b>4.1</b> Ausgedehntes Beispiel zum Einstieg</a><ul>
<li class="chapter" data-level="4.1.1" data-path="psychometrie.html"><a href="psychometrie.html#testscores"><i class="fa fa-check"></i><b>4.1.1</b> Testscores</a></li>
<li class="chapter" data-level="4.1.2" data-path="psychometrie.html"><a href="psychometrie.html#item-schwierigkeiten"><i class="fa fa-check"></i><b>4.1.2</b> Item-Schwierigkeiten</a></li>
<li class="chapter" data-level="4.1.3" data-path="psychometrie.html"><a href="psychometrie.html#item-interkorrelationen"><i class="fa fa-check"></i><b>4.1.3</b> Item-Interkorrelationen</a></li>
<li class="chapter" data-level="4.1.4" data-path="psychometrie.html"><a href="psychometrie.html#trennschaerfe"><i class="fa fa-check"></i><b>4.1.4</b> Item-Trennschärfen</a></li>
<li class="chapter" data-level="4.1.5" data-path="psychometrie.html"><a href="psychometrie.html#cronbachs-alpha"><i class="fa fa-check"></i><b>4.1.5</b> Cronbachs Alpha</a></li>
<li class="chapter" data-level="4.1.6" data-path="psychometrie.html"><a href="psychometrie.html#split-half-reliabilitat"><i class="fa fa-check"></i><b>4.1.6</b> Split-Half-Reliabilität</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="psychometrie.html"><a href="psychometrie.html#umgang-mit-echten-daten"><i class="fa fa-check"></i><b>4.2</b> Umgang mit echten Daten</a><ul>
<li class="chapter" data-level="4.2.1" data-path="psychometrie.html"><a href="psychometrie.html#umkodierung"><i class="fa fa-check"></i><b>4.2.1</b> Umkodierung von Variablen</a></li>
<li class="chapter" data-level="4.2.2" data-path="psychometrie.html"><a href="psychometrie.html#invertierung-von-antworten"><i class="fa fa-check"></i><b>4.2.2</b> Invertierung von Antworten</a></li>
<li class="chapter" data-level="4.2.3" data-path="psychometrie.html"><a href="psychometrie.html#umgang-mit-fehlenden-werten"><i class="fa fa-check"></i><b>4.2.3</b> Umgang mit fehlenden Werten</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="psychometrie.html"><a href="psychometrie.html#zusammenfassung-2"><i class="fa fa-check"></i><b>4.3</b> Zusammenfassung</a></li>
<li class="chapter" data-level="4.4" data-path="psychometrie.html"><a href="psychometrie.html#fragen-zum-vertiefenden-verstandnis-2"><i class="fa fa-check"></i><b>4.4</b> Fragen zum vertiefenden Verständnis</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="funktionen.html"><a href="funktionen.html"><i class="fa fa-check"></i><b>5</b> Funktionen</a><ul>
<li class="chapter" data-level="5.1" data-path="funktionen.html"><a href="funktionen.html#das-black-box-modell"><i class="fa fa-check"></i><b>5.1</b> Das Black-Box-Modell</a></li>
<li class="chapter" data-level="5.2" data-path="funktionen.html"><a href="funktionen.html#argumente"><i class="fa fa-check"></i><b>5.2</b> Argumente</a><ul>
<li class="chapter" data-level="5.2.1" data-path="funktionen.html"><a href="funktionen.html#help"><i class="fa fa-check"></i><b>5.2.1</b> Die <code>R</code>-Hilfe</a></li>
<li class="chapter" data-level="5.2.2" data-path="funktionen.html"><a href="funktionen.html#namenlose-argumente"><i class="fa fa-check"></i><b>5.2.2</b> Namenlose Argumente</a></li>
</ul></li>
<li class="chapter" data-level="5.3" data-path="funktionen.html"><a href="funktionen.html#ruckgabewerte"><i class="fa fa-check"></i><b>5.3</b> Rückgabewerte</a></li>
<li class="chapter" data-level="5.4" data-path="funktionen.html"><a href="funktionen.html#seiteneffekte"><i class="fa fa-check"></i><b>5.4</b> Seiteneffekte</a></li>
<li class="chapter" data-level="5.5" data-path="funktionen.html"><a href="funktionen.html#selbst-geschriebene-funktionen"><i class="fa fa-check"></i><b>5.5</b> Selbst geschriebene Funktionen</a><ul>
<li class="chapter" data-level="5.5.1" data-path="funktionen.html"><a href="funktionen.html#definition-der-eigenen-funktion"><i class="fa fa-check"></i><b>5.5.1</b> Definition der eigenen Funktion</a></li>
<li class="chapter" data-level="5.5.2" data-path="funktionen.html"><a href="funktionen.html#lokale-variablen"><i class="fa fa-check"></i><b>5.5.2</b> Lokale Variablen</a></li>
<li class="chapter" data-level="5.5.3" data-path="funktionen.html"><a href="funktionen.html#optionale-argumente"><i class="fa fa-check"></i><b>5.5.3</b> Optionale Argumente</a></li>
<li class="chapter" data-level="5.5.4" data-path="funktionen.html"><a href="funktionen.html#wann-schreibe-ich-meine-eigene-funktion"><i class="fa fa-check"></i><b>5.5.4</b> Wann schreibe ich meine eigene Funktion</a></li>
</ul></li>
<li class="chapter" data-level="5.6" data-path="funktionen.html"><a href="funktionen.html#fragen-zum-vertiefenden-verstandnis-3"><i class="fa fa-check"></i><b>5.6</b> Fragen zum vertiefenden Verständnis</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="schleifen.html"><a href="schleifen.html"><i class="fa fa-check"></i><b>6</b> Schleifen</a><ul>
<li class="chapter" data-level="6.1" data-path="schleifen.html"><a href="schleifen.html#sequentielle-bepunktung-von-testitems"><i class="fa fa-check"></i><b>6.1</b> Sequentielle Bepunktung von Testitems</a></li>
<li class="chapter" data-level="6.2" data-path="schleifen.html"><a href="schleifen.html#berechnung-von-part-whole-korrigierten-trennscharfen"><i class="fa fa-check"></i><b>6.2</b> Berechnung von part-whole korrigierten Trennschärfen</a></li>
<li class="chapter" data-level="6.3" data-path="schleifen.html"><a href="schleifen.html#datenspeicherung-in-einer-schleife"><i class="fa fa-check"></i><b>6.3</b> Datenspeicherung in einer Schleife</a><ul>
<li class="chapter" data-level="6.3.1" data-path="schleifen.html"><a href="schleifen.html#adressierung-per-name"><i class="fa fa-check"></i><b>6.3.1</b> Adressierung per Name</a></li>
<li class="chapter" data-level="6.3.2" data-path="schleifen.html"><a href="schleifen.html#vektorspeicherung-adressierung-per-index"><i class="fa fa-check"></i><b>6.3.2</b> Vektorspeicherung – Adressierung per Index</a></li>
</ul></li>
<li class="chapter" data-level="6.4" data-path="schleifen.html"><a href="schleifen.html#for-loops-are-evil-oder-nicht"><i class="fa fa-check"></i><b>6.4</b> for-loops are evil – oder nicht?</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="simulationen.html"><a href="simulationen.html"><i class="fa fa-check"></i><b>7</b> Simulationen</a></li>
<li class="chapter" data-level="8" data-path="anhang.html"><a href="anhang.html"><i class="fa fa-check"></i><b>8</b> Anhang</a><ul>
<li class="chapter" data-level="8.1" data-path="anhang.html"><a href="anhang.html#datenEinlesen"><i class="fa fa-check"></i><b>8.1</b> Daten einlesen</a></li>
<li class="chapter" data-level="8.2" data-path="anhang.html"><a href="anhang.html#das-environment-sauber-halten"><i class="fa fa-check"></i><b>8.2</b> Das Environment sauber halten</a><ul>
<li class="chapter" data-level="8.2.1" data-path="anhang.html"><a href="anhang.html#variablen-loschen"><i class="fa fa-check"></i><b>8.2.1</b> Variablen löschen</a></li>
<li class="chapter" data-level="8.2.2" data-path="anhang.html"><a href="anhang.html#mit-einem-sauberen-environment-starten"><i class="fa fa-check"></i><b>8.2.2</b> Mit einem sauberen Environment starten</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="9" data-path="referenzen.html"><a href="referenzen.html"><i class="fa fa-check"></i><b>9</b> Referenzen</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./"><div style="white-space: pre-line;">Testtheorie mit R</div></a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="vektoren" class="section level1">
<h1><span class="header-section-number">2</span> Vektoren</h1>
<p>Die einfachste und wichtigste Datenstruktur von <code>R</code> ist der <em>Vektor</em>. Ein Vektor ist beispielsweise eine einzelne Zahl wie in den Taschenrechner-Berechnungen in Kapitel 1. So gilt für die Berechnung <code>1 + 3</code>:</p>
<ul>
<li><code>1</code> ist ein Vektor</li>
<li><code>3</code> ein Vektor</li>
<li>das Ergebnis <code>4</code> ist auch ein Vektor</li>
</ul>
<p>Das Interessante an Vektoren ist, dass der ein-elementige Vektor nur ein Spezialfall ist. Im Normalfall können Vektoren mehrere Elemente enthalten; die „atomare“ Einheit in <code>R</code> ist also nicht ein einzelnes Element, sondern gleich eine Aneinanderreihung beliebig vieler<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a> gleichartiger Elemente, etwa Zahlen. Statistische Berechnungen – wie die Berechnung eines Mittelwerts oder einer Standardabweichung – lassen sich direkt auf einer Menge an Daten durchführen, da diese in <strong>einem</strong> Vektor gespeichert sind. Diese „Vektorbasiertheit“ ist vermutlich die größte Stärke von <code>R</code> für statistische Berechnungen.</p>
<p>Elemente zu Vektoren zusammenfügen (sprich: <strong>mehrere</strong> Vektoren zu <strong>einem</strong> Vektor zusammenfügen) funktioniert mit der <em>Funktion</em> <code>c</code> – die vermutlich basalste Funktion in <code>R</code>. Sie ist so simpel und grundlegend, dass man sie gegebenenfalls vergisst, wenn man sie braucht – versucht, sie zu erinnern!</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Füge mehrere Zahlen zu einem Vektor zusammen:
<span class="kw">c</span>(<span class="fl">0.5</span>, <span class="dv">1</span>, <span class="fl">1.5</span>) <span class="co"># Kommazahlen mit DezimalPUNKT schreiben</span></code></pre></div>
<pre><code>[1] 0.5 1.0 1.5</code></pre>
<p>Man kann die Funktion <code>c</code> auch auf eine einzelne Zahl anwenden. Das ist dasselbe als würde man nur die Zahl eingeben:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">c</span>(<span class="dv">1</span>)</code></pre></div>
<pre><code>[1] 1</code></pre>
<p>Folgendes geht auch, da <code>c</code> mehrere Vektoren zu <strong>einem einzelnen</strong> Vektor „verschmilzt“:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">c</span>(<span class="fl">0.5</span>, <span class="dv">1</span>, <span class="fl">1.5</span>, <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>))</code></pre></div>
<pre><code>[1] 0.5 1.0 1.5 1.0 2.0 3.0</code></pre>
<p>Auf mehrelementigen Vektoren kann man statistische Berechnungen durchführen, wie etwa die Bestimmung des arithmetischen Mittels, einer Standardabweichung, der Varianz, oder des Minimums oder Maximums:<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Berechne einen Mittelwert
<span class="kw">mean</span>(<span class="kw">c</span>(<span class="fl">0.5</span>, <span class="dv">1</span>, <span class="fl">1.5</span>))</code></pre></div>
<pre><code>[1] 1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Berechne eine Standardabweichung
<span class="kw">sd</span>(<span class="kw">c</span>(<span class="fl">0.5</span>, <span class="dv">1</span>, <span class="fl">1.5</span>))</code></pre></div>
<pre><code>[1] 0.5</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Berechne eine Varianz:
<span class="kw">var</span>(<span class="kw">c</span>(<span class="fl">0.5</span>, <span class="dv">1</span>, <span class="fl">1.5</span>))</code></pre></div>
<pre><code>[1] 0.25</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Und jetzt noch einmal die Standardabweichung:
<span class="kw">sqrt</span>(<span class="kw">var</span>(<span class="kw">c</span>(<span class="fl">0.5</span>, <span class="dv">1</span>, <span class="fl">1.5</span>))) <span class="co"># was ist `sqrt`?</span></code></pre></div>
<pre><code>[1] 0.5</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Minimum:
<span class="kw">min</span>(<span class="kw">c</span>(<span class="fl">0.5</span>, <span class="dv">1</span>, <span class="fl">1.5</span>))</code></pre></div>
<pre><code>[1] 0.5</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Maximum:
<span class="kw">max</span>(<span class="kw">c</span>(<span class="fl">0.5</span>, <span class="dv">1</span>, <span class="fl">1.5</span>))</code></pre></div>
<pre><code>[1] 1.5</code></pre>
<p>In diesem Code-Block haben wir implizit einen wichtigen Bestandteil von <code>R</code> kennengelernt: <em>Funktionen</em>. Für den Einstieg reicht es für uns, folgende Eigenschaften von Funktionen zu verstehen:</p>
<ul>
<li>Funktionen haben einen Namen – etwa: <code>mean</code> oder <code>c</code></li>
<li>Hinter dem Namen einer Funktion werden in Klammern ein oder mehrere <em>Argumente</em> übergeben, etwa: ein Vektor</li>
<li>Wenn einer Funktion mehrere Argumente übergeben werden, werden diese mit Kommata separiert, etwa: <code>c(1, 2, 3)</code></li>
<li>Funktionen führen eine Berechnung durch und geben uns das Ergebnis zurück</li>
</ul>
<p>Einfach gesagt nehmen also Funktionen Daten entgegen und geben wiederum Daten zurück. Der Großteil unserer Arbeit mit <code>R</code> ist die Anwendung von Funktionen. Es ist möglich Funktionsaufrufe zu verschachteln, wie dieses Beispiel zeigte:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sqrt</span>(<span class="kw">var</span>(<span class="kw">c</span>(<span class="fl">0.5</span>, <span class="dv">1</span>, <span class="fl">1.5</span>)))</code></pre></div>
<p>Hier wertet die Funktion <code>sqrt</code> (die Wurzel; engl. <em>square root</em>) das Ergebnis der Funktion <code>var</code> aus, um eine Standardabweichnung zu bestimmen. Der Aufruf ist also äquivalent zu <code>sqrt(0.25)</code>, da die Varianz von 0.5, 1, und 1.5 gleich 0.25 ist. Diese Beobachtung offenbart eine weitere wichtige Eigenschaft von <code>R</code>: Wir können unseren Code immer als das verstehen, was er ergibt, wenn er von <code>R</code> ausgewertet wird. Es macht keinen Unterschied, ob ich das Ergebnis einer Berechnung selber „händisch“ aufschreibe – also hier 0.25 –, oder Code schreibe, der mir dieses Ergebnis generiert – hier: <code>var(c(0.5, 1, 1.5))</code>.</p>
<p>Eine nützliche und oft verwendete Kurzform, um Vektoren aufsteigender, ganzer Zahlen zu erstellen ist folgende:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="dv">1</span><span class="op">:</span><span class="dv">20</span></code></pre></div>
<pre><code> [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20</code></pre>
<p>So lässt sich beispielsweise sehr einfach die Summe aller Zahlen von 1 bis 1,000 berechnen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sum</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">1000</span>)</code></pre></div>
<pre><code>[1] 500500</code></pre>
<p>Wir können auch absteigende Sequenzen erstellen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="dv">5</span><span class="op">:-</span><span class="dv">5</span></code></pre></div>
<pre><code> [1]  5  4  3  2  1  0 -1 -2 -3 -4 -5</code></pre>
<p>Diese Tabelle enthält einige nützliche Funktionen, die auf Vektoren anwendbar sind (in <code>R</code>-Jargon: sie nehmen einen Vektor als <em>Argument</em> an) und jeweils selber auch einen Vektor zurückgeben:</p>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Funktionalität</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>mean</code></td>
<td>Berechnet den Mittelwert eines Vektors</td>
</tr>
<tr class="even">
<td><code>median</code></td>
<td>Berechnet den Median eines Vektors</td>
</tr>
<tr class="odd">
<td><code>sum</code></td>
<td>Berechnet die Summe aller Elemente eines Vektors</td>
</tr>
<tr class="even">
<td><code>max</code></td>
<td>Gibt den größten Wert eines Vektors zurück</td>
</tr>
<tr class="odd">
<td><code>min</code></td>
<td>Gibt den kleinsten Wert eines Vektors zurück</td>
</tr>
<tr class="even">
<td><code>length</code></td>
<td>Gibt die Zahl der Elemente eines Vektors zurück</td>
</tr>
<tr class="odd">
<td><code>sd</code></td>
<td>Berechnet die Standardabweichung eines Vektors</td>
</tr>
<tr class="even">
<td><code>var</code></td>
<td>Berechnet die Varianz eines Vektors</td>
</tr>
<tr class="odd">
<td><code>sort</code></td>
<td>Sortiert einen Vektor aufsteigend</td>
</tr>
<tr class="even">
<td><code>rev</code></td>
<td>Kehrt die Reihenfolge der Elemente im Vektor um</td>
</tr>
<tr class="odd">
<td><code>round</code></td>
<td>Rundet die Elemente in einem Vektor</td>
</tr>
<tr class="even">
<td><code>sqrt</code></td>
<td>Berechnet für jedes Element im Vektor die Quadratwurzel</td>
</tr>
<tr class="odd">
<td><code>unique</code></td>
<td>Gibt alle unterschiedlichen Werte eines Vektors aus</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Für die Funktionen in dieser Tabelle gilt, dass sie zwar alle einen Vektor zurückgeben, aber die Länge des Ausgabevektors unterschiedlich sein kann. Die Funktionen <code>mean</code> und <code>sum</code> ergeben etwa Vektoren der Länge 1, da sie genau einen Kennwert bestimmen. Die Funktionen <code>sort</code>, <code>sqrt</code> und <code>round</code> geben hingegen einen Vektor zurück, der aus genauso vielen Elementen besteht wie der Eingabevektor.</p>
<p>Auch basale mathematische Berechnungen werden gleich auf alle Elemente eines Vektors angewendet:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="dv">1</span><span class="op">:</span><span class="dv">10</span> <span class="op">*</span><span class="st"> </span><span class="dv">2</span></code></pre></div>
<pre><code> [1]  2  4  6  8 10 12 14 16 18 20</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span> <span class="op">*</span><span class="st"> </span><span class="dv">2</span>) <span class="op">-</span><span class="st"> </span><span class="dv">1</span></code></pre></div>
<pre><code> [1]  1  3  5  7  9 11 13 15 17 19</code></pre>
<p>Hierbei werden die Operationen <code>* 2</code> bzw. <code>-1</code> direkt auf alle Elemente der Vektoren <code>1:10</code> bzw. <code>(1:10 * 2)</code> angewendet; die Ausgabe ist jeweils ein Vektor der Länge 10. Bei gleich langen Vektoren werden solche Operationen im Allgemeinen <strong>komponentenweise</strong>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="dv">2</span><span class="op">:</span><span class="dv">4</span> <span class="op">*</span><span class="st"> </span><span class="dv">4</span><span class="op">:</span><span class="dv">6</span> <span class="co"># entspricht c(2*4, 3*5, 4*6)</span></code></pre></div>
<pre><code>[1]  8 15 24</code></pre>
<p>Dieses Verhalten ist typisch für <code>R</code>: Viele Funktionen und Operationen in <code>R</code> arbeiten komponentenweise, wenn zwei Vektoren gleicher Länge übergeben werden. Das Element an Position 1 im einen Vektor wird dann mit dem Element an Position 1 im anderen Vektor gepaart, das Element an Position 2 im einen Vektor mit dem Element an Position 2 im anderen Vektor – und so weiter.</p>
<p>Werden ein ein-elementiger Vektor und ein mehr-elementiger Vektor mit einer Berechnung (etwa einer Addition) verknüpft, wird normalerweise das einzelne Element mit allen Elementen des anderen Vektors „gepaart“.<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a></p>
<div id="variablen" class="section level2">
<h2><span class="header-section-number">2.1</span> Variablen</h2>
<p>Wir wollen unsere Daten nicht nur in der Konsole ausgeben lassen, sondern auch abspeichern und damit arbeiten. Ein essentieller Bestandteil einer jeden Programmiersprache ist es, Daten in Variablen abzuspeichern. Variablen sind Namen, mit deren Hilfe wir auf gespeicherte Daten zugreifen. Wenn wir Daten in einer Variablen abgespeichert haben, können wir unter dem Namen der Variablen immer wieder darauf zugreifen. In <code>R</code> funktioniert das mit der Zuweisung <code>&lt;-</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Speichert einen Vektor in einer Variablen:
meinVektor &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">10</span>)</code></pre></div>
<p>Ich kann den Inhalt von Variablen in der <code>R</code>-Konsole ausgeben lassen, wenn ich den Namen der Variablen in die Konsole schreibe und <code>Enter</code> drücke:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">meinVektor</code></pre></div>
<pre><code>[1]  1  2  6  7 10</code></pre>
<p>Ich kann Variablen in Berechnungen verwenden:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">meinVektor <span class="op">*</span><span class="st"> </span><span class="dv">2</span></code></pre></div>
<pre><code>[1]  2  4 12 14 20</code></pre>
<p>Ich kann Funktionen auf Variablen anwenden und das Ergebnis der Funktion wiederum in einer Variablen speichern:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xx &lt;-<span class="st"> </span><span class="kw">mean</span>(meinVektor)

## &quot;Zentrierter&quot; numerischer Vektor:
meinVektor <span class="op">-</span><span class="st"> </span>xx</code></pre></div>
<pre><code>[1] -4.2 -3.2  0.8  1.8  4.8</code></pre>
<p>Variablen können an jeder Stelle verwendet werden, an der man Daten sonst „händisch“ eingeben würde. Wir können jegliche Objekte – nicht nur Vektoren, sondern auch Datentabellen oder beliebig komplizierte Ergebnisse von Berechnungen – in Variablen speichern. Der Workflow in <code>R</code> ist so ausgelegt, dass Zwischenergebnisse weiterverwendet werden können. Hierbei unterscheidet es sich fundamental von SPSS, das einen Unterschied zwischen Daten und „Output“ macht. In <code>R</code> kann das Ergebnis jeglicher Berechnung als Input einer anderen Berechnung dienen.</p>
<div class="block">
<p>
<strong>Merke</strong>: In <code>R</code> kann (fast) alles in Variablen gespeichert und weiterverwendet werden.
</p>
</div>
<p>Wir können auch mit einem Gleichzeichen <code>=</code> Daten zu Variablen zuweisen. Das funktioniert genauso wie mit <code>&lt;-</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">foo =<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">2</span>
foo</code></pre></div>
<pre><code>[1] 1 2</code></pre>
<p>In <code>R</code> hat sich aus historischen Gründen die Konvention durchgesetzt, <code>&lt;-</code> zu verwenden, die ich in diesem Skript auch befolgen werde. In vielen anderen Programmiersprachen werden Variablen mit Gleichzeichen zugewiesen.</p>
<div id="ausgabevsabspeichern" class="section level3">
<h3><span class="header-section-number">2.1.1</span> Ausgabe versus Abspeichern</h3>
<p>Wir haben jetzt zwei verschiedene Möglichkeiten kennengelernt, Objekte<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a> in <code>R</code> zu verwenden:</p>
<ol style="list-style-type: decimal">
<li>Wir geben Objekte in der Konsole aus.</li>
<li>Wir speichern Objekte in einer Variable ab.</li>
</ol>
<p>Diese beiden Verwendungen sind <strong>fundamental</strong> unterschiedlich. Das mag erst einmal trivial erscheinen, aber ist im Einzelfall nicht unbedingt ersichtlich. Betrachten wir das folgende Beispiel:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">bar &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">6</span>, <span class="dv">3</span>, <span class="dv">9</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="op">-</span><span class="dv">3</span>)
<span class="kw">sort</span>(bar)</code></pre></div>
<pre><code>[1] -3  2  3  3  5  6  7  9</code></pre>
<p>Die Funktion <code>sort</code> sortiert den numerischen Vektor <code>bar</code> aufsteigend. Wie sieht der Vektor <code>bar</code> nach der Operation aus? Es gibt zwei Möglichkeiten:</p>
<ol style="list-style-type: decimal">
<li><code>bar</code> enthält den sortierten Vektor, den ich mithilfe von <code>sort(bar)</code> erstellt habe</li>
<li><code>bar</code> enthält den unsortierten Vektor, den ich vor der Operation <code>sort(bar)</code> erstellt habe</li>
</ol>
<p>Wir können die Frage leicht klären, indem wir <code>bar</code> in der Konsole ausgeben:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">bar</code></pre></div>
<pre><code>[1]  3  2  6  3  9  5  7 -3</code></pre>
<p>Offensichtlich hat <code>sort(bar)</code> den Vektor, der in der Variablen <code>bar</code> gespeichert ist, nicht geändert. Das ist eine fundamentale Eigenschaft der Programmiersprache <code>R</code>: <strong>Funktionen nehmen Daten an und sie geben Daten zurück – sie verändern aber nicht die eingegebenen Daten</strong>. Wenn wir wollen, dass <code>bar</code> die Zahlenfolge in sortierter Reihenfolge enthält, können wir die folgende Befehlkette verwenden:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">bar &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">6</span>, <span class="dv">3</span>, <span class="dv">9</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="op">-</span><span class="dv">3</span>)
bar &lt;-<span class="st"> </span><span class="kw">sort</span>(bar)</code></pre></div>
<p>In diesem Fall geht der Ursprungsvektor verloren und wir behalten nur den sortieren Vektor. Generell gilt: wenn wir Daten in der Konsole ausgeben lassen, verschwinden diese sozusagen im „Nirvana“. Wenn wir mit Daten weiterarbeiten wollen, müssen wir die Ausgabe einer Funktion in einer Variablen speichern. Beide Verwendungszwecke sind denkbar: Manchmal benötige ich nur die Ausgabe einer Berechnung, manchmal möchte ich das Ergebnis abspeichern.</p>
</div>
<div id="variablennamen" class="section level3">
<h3><span class="header-section-number">2.1.2</span> Variablennamen</h3>
<p>Generell bestehen Variablennamen aus Buchstaben und Zahlen und den Zeichen <code>.</code> und <code>_</code>. Folgende Einschränkungen sind zu beachten:</p>
<ul>
<li>Variablennamen dürfen keine Leerzeichen enthalten
<ul>
<li><code>bla bla &lt;- c(1, 2)</code> funktioniert nicht</li>
<li><code>blabla  &lt;- c(1, 2)</code> funktioniert</li>
</ul></li>
<li>Variablennamen dürfen nicht mit einer Zahl starten
<ul>
<li><code>1bla &lt;- c(1, 2)</code> funktioniert nicht</li>
<li><code>bla1 &lt;- c(1, 2)</code> funktioniert</li>
</ul></li>
<li>Variablennamen dürfen keine Sonderzeichen außer <code>_</code> oder <code>.</code> enthalten
<ul>
<li><code>bla-bla &lt;- c(1, 2)</code> funktioniert nicht</li>
<li><code>bla%bla &lt;- c(1, 2)</code> funktioniert nicht</li>
<li><code>bla_bla &lt;- c(1, 2)</code> funktioniert</li>
<li><code>bla.bla &lt;- c(1, 2)</code> funktioniert</li>
</ul></li>
<li><code>bla &lt;- 1</code> ist nicht das Gleiche wie <code>Bla &lt;- 1</code> oder gar <code>BLA &lt;- 1</code></li>
<li>Vermeidet Umlaute in Variablennamen. <code>R</code> wird diese zwar akzeptieren, aber ich würde dennoch davon abraten, sie zu nutzen.</li>
</ul>
<p>Eine fundamentale Schwierigkeit beim Programmieren ist das Finden <em>guter</em> Variablennamen; <code>bla</code> und <code>blabla</code> sind denkbar schlechte Variablennamen. Gute Variablennamen <em>sprechen</em>, d.h. sie machen eine Aussage darüber, was für Daten sie beinhalten.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Schlechter Variablenname:
foo &lt;-<span class="st"> </span><span class="kw">mean</span>(age)

## Ggf. etwas besser:
mean_age &lt;-<span class="st"> </span><span class="kw">mean</span>(age)</code></pre></div>
<p>Beachtet <strong>immer</strong> folgende Regel: Variablennamen sollten nicht lügen, also verwendet niemals einen Namen der folgenden Art:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mean_age &lt;-<span class="st"> </span><span class="kw">sd</span>(age) <span class="co"># Niemals machen!</span></code></pre></div>
<p>Man ist schnell geneigt einen unsinnigen Variablennamen zu vergeben, um keine Zeit mit der Namensfindung zu verschwenden – man hat ja schließlich wichtigen Code zu schreiben! Man sollte sich jedoch so gut wie immer kurz Zeit nehmen, einen sinnigen Namen zu finden – das zukünftige Selbst wird es einem danken. Unsinnige Variablennamen sind in Ordnung, wenn man sich zu 100% sicher ist, dass man die Variable nach einmaliger Nutzung nicht mehr verwendet. Wenn man eine Variable nicht mehr benutzen möchte, kann man sie mit der <code>rm</code> Funktion löschen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">foo &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">10</span> <span class="co"># Wegwerfvariable</span>
<span class="kw">rm</span>(foo)
foo
Fehler<span class="op">:</span><span class="st"> </span>Objekt <span class="st">&#39;foo&#39;</span> nicht gefunden</code></pre></div>
<p>Weiterhin ist es guter Stil <em>konsistent</em> in der Vergebung der Variablennamen zu sein. Variablennamen sollen einen semantischen Gehalt haben, das heißt sie machen eine Aussage darüber, welche Daten sie enthalten. Häufig ist diese Information nicht in einem Wort erklärbar. Um auszusagen, dass eine Variable „das mittlere Alter“ enthält, müssen mindestens die Anteile „mittel“ und „Alter“ enthalten sein. Wie soll das verknüpft werden? Verschiedene Konventionen existieren; wichtig ist, dass ihr euch konsistent für eine Variante entscheidet.<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Mögliche Konventionen der Namensgebung von Variablen:
mean_age &lt;-<span class="st"> </span><span class="kw">mean</span>(age)
mean.age &lt;-<span class="st"> </span><span class="kw">mean</span>(age)
meanAge  &lt;-<span class="st"> </span><span class="kw">mean</span>(age)

## keine gute Konvention:
meanage  &lt;-<span class="st"> </span><span class="kw">mean</span>(age)</code></pre></div>
</div>
</div>
<div id="datentypen-von-vektoren" class="section level2">
<h2><span class="header-section-number">2.2</span> Datentypen von Vektoren</h2>
<p>In <code>R</code> hat jeder Vektor genau einen Datentyp. Bis jetzt haben wir nur mit dem Datentyp Zahl gearbeitet, der in <code>R</code> „<code>numeric</code>“ heißt. Der Datentyp eines Vektors bestimmt, was für Operationen wir damit durchführen können. Vektoren vom Typ <code>numeric</code> etwa kann man addieren, multiplizieren und so weiter. Mit der Funktion <code>mode</code> können wir überprüfen, welchen Datentyp ein Vektor hat:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mode</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)</code></pre></div>
<pre><code>[1] &quot;numeric&quot;</code></pre>
<p>In diesem Abschnitt werden weitere Datentypen behandelt, die wir nutzen, um unterschiedliche Informationen darzustellen.</p>
<div id="character" class="section level3">
<h3><span class="header-section-number">2.2.1</span> <code>character</code></h3>
<p>Der Datentyp für Text heißt <code>character</code>. Text wird mit doppelten oder einfachen Anführungszeichen angegeben:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="st">&quot;Hallo Welt!&quot;</span> <span class="co"># doppelte Anführungszeichen</span></code></pre></div>
<pre><code>[1] &quot;Hallo Welt!&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mein_text &lt;-<span class="st"> &#39;bla bla bla&#39;</span> <span class="co"># einfache Anführungszeichen</span>

## zwei-elementiger Vektor vom Typ character:
mein_text2 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Cronbachs&quot;</span>, <span class="st">&quot;Alpha&quot;</span>)</code></pre></div>
<p>Mit Texten können wir andere Operationen durchführen als mit Zahlen, etwa ergibt Folgendes eine Fehlermeldung<a href="#fn9" class="footnoteRef" id="fnref9"><sup>9</sup></a> und ergibt auch gar keinen Sinn, da man Text nicht mit einer Zahl multiplizieren kann:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="st">&quot;bla&quot;</span> <span class="op">*</span><span class="st"> </span><span class="dv">2</span>
Fehler <span class="cf">in</span> <span class="st">&quot;bla&quot;</span> <span class="op">*</span><span class="st"> </span><span class="dv">2</span> <span class="op">:</span><span class="st"> </span>nicht<span class="op">-</span>numerisches Argument
für binären Operator</code></pre></div>
<p>In diesem Skript spielt Text keine allzu große Rolle. In erster Linie werden wir Vektoren vom Typ <code>character</code> für Datenzugriffe verwenden; im Speziellen werden wir sie einsetzen, um Spalten in Datentabellen zu adressieren (siehe <a href="dataframes.html#datenzugriffe">Kapitel 3</a>). Zu diesem Zweck werden wir die Funktion <code>paste0</code> nutzen, die <code>character</code>-Vektoren beliebiger Länge erstellt. So lassen sich beispielsweise bequem 10 durchnummerierte Itemnamen generieren, wodurch man gleich 10 Spalten aus einer Tabelle auswählen könnte:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">items &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="st">&quot;item_&quot;</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)</code></pre></div>
<p>Hierbei wird der Text “item_” mit den Zahlen von 1 bis 10 gepaart. Das Ergebnis des Befehls ist ein 10-elementiger Vektor, was wir auch wie folgt überprüfen können:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">length</span>(items)</code></pre></div>
<pre><code>[1] 10</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">items</code></pre></div>
<pre><code> [1] &quot;item_1&quot;  &quot;item_2&quot;  &quot;item_3&quot;  &quot;item_4&quot;  &quot;item_5&quot;  &quot;item_6&quot;  &quot;item_7&quot; 
 [8] &quot;item_8&quot;  &quot;item_9&quot;  &quot;item_10&quot;</code></pre>
<p>Wenn man mit der Funktion <code>paste0</code> mehrere ein-elementige Vektoren miteinander verknüpft, wird ein ein-elementiger Vektor vom Typ <code>character</code> ausgegeben:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">paste0</span>(<span class="st">&quot;item&quot;</span>, <span class="st">&quot;_&quot;</span>, <span class="dv">1</span>) <span class="co"># paste0 nimmt beliebig viele Argumente an</span></code></pre></div>
<pre><code>[1] &quot;item_1&quot;</code></pre>
</div>
<div id="logical" class="section level3">
<h3><span class="header-section-number">2.2.2</span> <code>logical</code></h3>
<p>Es hat sich als nützlich erwiesen, einen Datentyp einzuführen, der “Wahrheit” kodiert. Dieser Datentyp wird in <code>R</code> “logical” genannt; er kennt nur die Ausprägungen <code>TRUE</code> und <code>FALSE</code>. Eine sonst gängige Bezeichnung für diesen Datentyp ist auch “boolean”.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">wahr   &lt;-<span class="st"> </span><span class="ot">TRUE</span>
falsch &lt;-<span class="st"> </span><span class="ot">FALSE</span></code></pre></div>
<p>Wir werden häufig vom Typ <code>logical</code> Gebrauch machen, wenn wir in Datentabellen Fälle auswählen (etwa alle weiblichen oder männlichen Teilnehmer in einer Umfrage).</p>
<p>Mit logischen Werten kann man die logischen Operationen UND (in <code>R</code>: <code>&amp;</code> ), ODER (in <code>R</code>: <code>|</code> ) und NICHT (in <code>R</code>: <code>!</code> ) durchführen:<a href="#fn10" class="footnoteRef" id="fnref10"><sup>10</sup></a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Logisches UND
<span class="ot">TRUE</span> <span class="op">&amp;</span><span class="st"> </span><span class="ot">TRUE</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="ot">TRUE</span> <span class="op">&amp;</span><span class="st"> </span><span class="ot">FALSE</span></code></pre></div>
<pre><code>[1] FALSE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="ot">FALSE</span> <span class="op">&amp;</span><span class="st"> </span><span class="ot">FALSE</span></code></pre></div>
<pre><code>[1] FALSE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Logisches ODER
<span class="ot">TRUE</span> <span class="op">|</span><span class="st"> </span><span class="ot">TRUE</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="ot">TRUE</span> <span class="op">|</span><span class="st"> </span><span class="ot">FALSE</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="ot">FALSE</span> <span class="op">|</span><span class="st"> </span><span class="ot">FALSE</span></code></pre></div>
<pre><code>[1] FALSE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Logisches NICHT
<span class="op">!</span><span class="ot">TRUE</span></code></pre></div>
<pre><code>[1] FALSE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="op">!</span><span class="ot">FALSE</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<p>Auch diese logischen Operationen arbeiten komponentenweise auf Vektoren, die mehr als ein Element enthalten:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">FALSE</span>) <span class="op">&amp;</span><span class="st"> </span><span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">TRUE</span>, <span class="ot">FALSE</span>)</code></pre></div>
<pre><code>[1]  TRUE FALSE FALSE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">FALSE</span>) <span class="op">|</span><span class="st"> </span><span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">TRUE</span>, <span class="ot">FALSE</span>)</code></pre></div>
<pre><code>[1]  TRUE  TRUE FALSE</code></pre>
</div>
<div id="factor" class="section level3">
<h3><span class="header-section-number">2.2.3</span> <code>factor</code></h3>
<p>Vektoren vom Typ <code>factor</code> stellen kategoriale Variablen dar – etwa die unabhängigen Variablen in einer ANOVA. So können wir einen Vektor vom Typ <code>factor</code> erstellen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">laune &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>)

laune_faktor &lt;-<span class="st"> </span><span class="kw">factor</span>(laune, <span class="dt">levels =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>),
                       <span class="dt">labels =</span> <span class="kw">c</span>(<span class="st">&quot;:(&quot;</span>, <span class="st">&quot;:)&quot;</span>, <span class="st">&quot;:D&quot;</span>))

laune_faktor</code></pre></div>
<pre><code>[1] :( :) :D :( :) :(
Levels: :( :) :D</code></pre>
<p>Die Funktion <code>factor</code> wird hier genutzt, um numerische Werte in <code>factor</code> umzuwandeln. Dabei wurden <code>levels</code> spezifiziert, d.h. die Werte, die der ursprüngliche Vektor angenommen hat. Das Argument <code>labels</code> ordnet den <code>levels</code> eine Bezeichnung zu; diese wird uns angezeigt, wenn wir den Vektor aufrufen. Mit einem Vektor vom Typ <code>factor</code> kann ich keine numerischen Berechnungen mehr durchführen, da er <strong>kategoriale</strong> Daten beinhaltet. Etwa kann ich für <code>laune_faktor</code> keinen Mittelwert berechnen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mean</span>(laune)</code></pre></div>
<pre><code>[1] 1.666667</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mean</span>(laune_faktor)</code></pre></div>
<pre><code>[1] NA</code></pre>
<p>Da die Berechnung nicht möglich ist, gibt <code>R</code> die folgende “Warnmeldung” aus:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
Warnmeldung<span class="op">:</span>
In <span class="kw">mean.default</span>(laune_faktor) <span class="op">:</span>
<span class="st">  </span>argument is not numeric or logical<span class="op">:</span><span class="st"> </span>returning <span class="ot">NA</span></code></pre></div>
</div>
<div id="na" class="section level3">
<h3><span class="header-section-number">2.2.4</span> <code>NA</code></h3>
<p><code>R</code> hat einen eigenen Datentyp, um fehlende Werte zu kodieren: <code>NA</code>.<a href="#fn11" class="footnoteRef" id="fnref11"><sup>11</sup></a> Da wir mit echten Datensätzen arbeiten, die oftmals „messy“ sind, d.h. nicht notwendigerweise vollständig, ist diese Eigenschaft sehr nützlich. Gerade bei der Arbeit mit Daten in der psychologischen Diagnostik ist dies wichtig: Menschen geben in Fragebögen eben nicht immer auf alle Fragen eine Antwort.</p>
<p>Man kann selber Vektoren erstellen, die fehlende Werte enthalten:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">messy_data &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">9</span>, <span class="dv">3</span>, <span class="ot">NA</span>, <span class="dv">6</span>, <span class="ot">NA</span>, <span class="dv">5</span>)</code></pre></div>
<p>Die Anwesenheit von fehlenden Werten hat Auswirkungen darauf, welche Berechnungen <code>R</code> mit dem Vektor anstellen kann. Etwa können wir nicht mehr ohne Weiteres einen Mittelwert berechnen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mean</span>(messy_data) <span class="co"># geht nicht wegen des fehlenden Werts</span></code></pre></div>
<pre><code>[1] NA</code></pre>
<p>Man muss <code>R</code> explizit mitteilen, dass man trotz des Auftretens fehlender Werte einen Mittelwert ausrechnen möchte. Dies funktioniert mit dem <em>optionalen Argument</em> <code>na.rm</code><a href="#fn12" class="footnoteRef" id="fnref12"><sup>12</sup></a> der Funktion <code>mean</code>, welches wir auf <code>TRUE</code> setzen können. Mit dem <em>Argument</em> <code>na.rm</code> (“NA remove”) teilt man <code>mean</code> mit, dass <code>NA</code> Werte bei der Berechnung des Mittelwerts nicht berücksichtigt werden sollen (andere Funktionen wie <code>sd</code> und <code>var</code> haben auch das Argument <code>na.rm</code>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mean</span>(messy_data, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</code></pre></div>
<pre><code>[1] 4.142857</code></pre>
<p>Hierbei nehmen wir zur Kenntnis, dass man Argumente von Funktionen benennen kann – was wir aber nicht immer machen. Dazu später mehr.</p>
</div>
</div>
<div id="logischevergleiche" class="section level2">
<h2><span class="header-section-number">2.3</span> Logische Vergleiche</h2>
<p>Wir können in <code>R</code> Eigenschaften von Vektoren mithilfe von logischen Vergleichen erfragen. So kann man beispielsweise prüfen, welche Werte eines numerischen Vektors (a) gleich, (b) größer (c) kleiner, (d) größer gleich, (e) kleiner gleich oder (f) ungleich einem bestimmten Wert sind. Dieser Code-Abschnitt stellt die grundlegenden logischen Vergleiche dar:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">vergleichswert &lt;-<span class="st"> </span><span class="dv">3</span>
daten &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">5</span>
daten <span class="op">&gt;</span><span class="st"> </span>vergleichswert</code></pre></div>
<pre><code>[1] FALSE FALSE FALSE  TRUE  TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">daten <span class="op">&lt;</span><span class="st"> </span>vergleichswert</code></pre></div>
<pre><code>[1]  TRUE  TRUE FALSE FALSE FALSE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">daten <span class="op">&gt;=</span><span class="st"> </span>vergleichswert</code></pre></div>
<pre><code>[1] FALSE FALSE  TRUE  TRUE  TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">daten <span class="op">&lt;=</span><span class="st"> </span>vergleichswert</code></pre></div>
<pre><code>[1]  TRUE  TRUE  TRUE FALSE FALSE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">daten <span class="op">==</span><span class="st"> </span>vergleichswert</code></pre></div>
<pre><code>[1] FALSE FALSE  TRUE FALSE FALSE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">daten <span class="op">!=</span><span class="st"> </span>vergleichswert</code></pre></div>
<pre><code>[1]  TRUE  TRUE FALSE  TRUE  TRUE</code></pre>
<p>Das Ergebnis dieser Operationen ist ein Vektor aus <code>TRUE</code> und <code>FALSE</code> Werten. Die Werte nehmen <code>TRUE</code> an, wenn die Zahlen die kleiner/größer/gleich Bedingung erfüllen – andernfalls <code>FALSE</code>. <strong>Beachtet, dass auf Gleichheit mit dem “doppelten” <code>==</code> Operator getestet wird und nicht mit einem einfachen <code>=</code>.</strong> Dies ist eine häufige Quelle von Fehlern, die schwierig zu entdecken sind. Betrachtet etwa folgenden Code – was geht hier schief?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">daten =<span class="st"> </span>vergleichswert</code></pre></div>
<p>Hierbei wird die Variable <code>daten</code> mit dem Wert in der Variablen <code>vergleichswert</code> überschrieben, da <code>=</code> als Zuweisung agiert:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">daten</code></pre></div>
<pre><code>[1] 3</code></pre>
<p>Dies ist ein Beispiel für einen Fehler (<em>Bug</em>), den man nicht anhand von einer Fehlermeldung bemerkt, da der Befehl <em>syntaktisch</em> korrekt ist. Es ist jedoch problematisch, dass ich an dieser Stelle meine Daten mit einem irrelevanten Wert überschrieben habe, und das bei einem späteren Zugriff darauf vermutlich nicht beachten werde.</p>
<p>Welche logischen Vergleiche möglich sind, hängt vom Datentyp eines Vektors ab. Für Vektoren vom typ <code>character</code> etwa macht eine kleiner/größer Abfrage keinen Sinn, jedoch eine Abfrage auf Gleichheit.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">text1 &lt;-<span class="st"> &quot;Hallo Welt&quot;</span>
text1 <span class="op">==</span><span class="st"> &quot;Hallo Welt&quot;</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">text1 <span class="op">==</span><span class="st"> &quot;Hallo Welt!&quot;</span></code></pre></div>
<pre><code>[1] FALSE</code></pre>
<p>Für Vektoren vom Typ <code>factor</code> lässt sich genauso eine Abfrage auf Gleichheit umsetzen. Hier wird beim Test auf Gleichheit das überprüfte <code>factor</code>-Label in Anführungszeichen gesetzt:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">geschlecht &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>)
geschlecht &lt;-<span class="st"> </span><span class="kw">factor</span>(laune, <span class="dt">levels =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>,
                     <span class="dt">labels =</span> <span class="kw">c</span>(<span class="st">&quot;weiblich&quot;</span>, <span class="st">&quot;maennlich&quot;</span>, <span class="st">&quot;divers&quot;</span>))

geschlecht <span class="op">==</span><span class="st"> &quot;maennlich&quot;</span></code></pre></div>
<pre><code>[1] FALSE  TRUE FALSE FALSE  TRUE FALSE</code></pre>
<p>Wenn zwei Vektoren gleicher Länge mit logischen Operatoren verglichen werden, werden die Elemente komponentenweise verglichen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">score_test1 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">23</span>, <span class="dv">19</span>, <span class="dv">44</span>, <span class="dv">18</span>, <span class="dv">25</span>, <span class="dv">22</span>)
score_test2 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">26</span>, <span class="dv">23</span>, <span class="dv">29</span>, <span class="dv">18</span>, <span class="dv">32</span>, <span class="dv">19</span>)

score_test1 <span class="op">&gt;</span><span class="st"> </span>score_test2</code></pre></div>
<pre><code>[1] FALSE FALSE  TRUE FALSE FALSE  TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">score_test1 <span class="op">==</span><span class="st"> </span>score_test2</code></pre></div>
<pre><code>[1] FALSE FALSE FALSE  TRUE FALSE FALSE</code></pre>
<div id="anwendungsbeispiel-uberprufe-das-gesetz-der-groen-zahlen" class="section level3">
<h3><span class="header-section-number">2.3.1</span> Anwendungsbeispiel: Überprüfe das Gesetz der großen Zahlen</h3>
<p>Häufig verwendet man die Vergleichsoperatoren, um zu prüfen, wie viele Daten eine bestimmte Eigenschaft erfüllen. Dafür verknüpfen wir die Vergleichsoperatoren mit den Funktionen <code>sum</code> oder <code>mean</code>.</p>
<p>Dafür bietet sich ein Beispiel aus der Statistik an: Wie viele von 1,000 Zufallsdaten aus einer Standardnormalverteilung sind größer als 1? <code>R</code> hat zahlreiche Funktionen, um Zufallszahlen aus verschiedenen Verteilungen zu generieren. Mit <code>rnorm</code> lassen sich Zufallszahlen generieren, die einer Normalverteilungen folgen; wenn man keine weiteren Argumente angibt, ist die Standardnormalverteilung gemeint, die einen Mittelwert von <code>0</code> und eine Standardabweichung von <code>1</code> hat:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Erstelle 1,000 Zufallsdaten:
zufallsdaten &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1000</span>)</code></pre></div>
<p>Zur Verdeutlichung: Der Vektor <code>zufallsdaten</code> enthält jetzt 1,000 Elemente, wie wir mit der Funktion <code>length</code> leicht überprüfen können:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">length</span>(zufallsdaten)</code></pre></div>
<pre><code>[1] 1000</code></pre>
<p>Die Funktion <code>head</code> zeigt uns die ersten sechs Werte des Vektors an. <code>head</code> ist sehr praktisch, um sich schnell einen Blick über Daten zu verschaffen. Das machen wir hier auch, da wir nicht alle 1,000 Werte in die Konsole schreiben wollen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(zufallsdaten)</code></pre></div>
<pre><code>[1]  1.3709584 -0.5646982  0.3631284  0.6328626  0.4042683 -0.1061245</code></pre>
<p>Wir können die Daten mithilfe eines Histogramms betrachten, um uns davon zu überzeugen, dass sie tatsächlich normalverteilt sind – sich also der Großteil der Daten um die <code>0</code> tummelt und extreme Werte in beide Richtungen seltener werden (dieser Code muss nicht verstanden werden):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Male Histogram
<span class="kw">hist</span>(zufallsdaten, <span class="dt">freq =</span> <span class="ot">FALSE</span>,
     <span class="dt">main =</span> <span class="st">&quot;Schöne normalverteilte Daten&quot;</span>,
     <span class="dt">xlab =</span> <span class="st">&quot;&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;&quot;</span>, <span class="dt">las =</span> <span class="dv">1</span>,
     <span class="dt">xlim =</span> <span class="kw">c</span>(<span class="op">-</span><span class="dv">4</span>, <span class="dv">4</span>), <span class="dt">ylim =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="fl">0.4</span>),
     <span class="dt">cex.main =</span> <span class="fl">0.5</span>, <span class="dt">cex.axis =</span> <span class="fl">0.6</span>)

## Lege eine Normalverteilungskurve über die Daten
<span class="kw">curve</span>(dnorm, <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>, <span class="dt">add =</span> <span class="ot">TRUE</span>, <span class="dt">lwd =</span> <span class="fl">1.5</span>)

## Zeichne eine graue Linie beim x-Wert `1` ein:
<span class="kw">abline</span>(<span class="dt">v =</span> <span class="dv">1</span>, <span class="dt">lwd =</span> <span class="dv">2</span>, <span class="dt">col =</span> <span class="st">&quot;darkgrey&quot;</span>)</code></pre></div>
<p><img src="01_Einstieg_files/figure-html/unnamed-chunk-52-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Nach visueller Inspektion der Verteilung der Zufallszahlen können wir mit <code>sum</code> testen, wie viele der 1,000 Zufallsdaten größer als 1 sind:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sum</span>(zufallsdaten <span class="op">&gt;</span><span class="st"> </span><span class="dv">1</span>)</code></pre></div>
<pre><code>[1] 153</code></pre>
<p>Zur Erinnerung: Der Befehl “<code>zufallsdaten &gt; 1</code>” ergibt einen Vektor aus <code>TRUE</code> und <code>FALSE</code> Werten, der genauso viele Elemente enthält wie der Vektor <code>zufallsdaten</code>; wann immer ein Eintrag in <code>zufallsdaten</code> größer ist als 1, erhalten wir <code>TRUE</code>, andernfalls <code>FALSE</code>. <code>sum</code> gibt die Zahl der <code>TRUE</code> Einträge aus. <strong>Das funktioniert, da <code>TRUE</code> und <code>FALSE</code> eine numerische Interpretation haben: <code>TRUE</code> wird als <code>1</code> interpretiert und <code>FALSE</code> als <code>0</code></strong>.<a href="#fn13" class="footnoteRef" id="fnref13"><sup>13</sup></a></p>
<p>Analog können wir mit <code>mean</code> den relativen Anteil der Daten bestimmen, die größer als 1 sind:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mean</span>(zufallsdaten <span class="op">&gt;</span><span class="st"> </span><span class="dv">1</span>)</code></pre></div>
<pre><code>[1] 0.153</code></pre>
<p>Der Erwartungswert, dass eine zufällige Zahl aus einer Standardnormalverteilung größer ist als <code>1</code> – also mehr als eine Standardabweichung vom Mittelwert entfernt liegt – liegt bei etwa 15.9%. Den exakten Erwartungswert könnte ich in <code>R</code> mit der Funktion <code>pnorm</code> herausfinden:<a href="#fn14" class="footnoteRef" id="fnref14"><sup>14</sup></a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="dv">1</span> <span class="op">-</span><span class="st"> </span><span class="kw">pnorm</span>(<span class="dv">1</span>)</code></pre></div>
<pre><code>[1] 0.1586553</code></pre>
<p>Nach dem Gesetz der großen Zahlen liegt der folgende Wert wahrscheinlich näher an 15.9% als der Schätzer, der auf 1,000 Zufallszahlen basiert:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## 100,000 Zufallsdaten sind für R kein Problem
zufallsdaten &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">100000</span>) <span class="co"># 100000</span>
<span class="kw">mean</span>(zufallsdaten <span class="op">&gt;</span><span class="st"> </span><span class="dv">1</span>)</code></pre></div>
<pre><code>[1] 0.15838</code></pre>
<p>Ihr könnt für das Gesetz der großen Zahlen selber ein Gefühl entwickeln, wenn ihr mehrfach <code>mean(rnorm(1000)&gt;1)</code> und <code>mean(rnorm(100000)&gt;1)</code> in die <code>R</code>-Konsole eingebt und beobachtet, welcher Wert häufiger näher an 0.159 liegt. Beachtet wie schnell <code>R</code> Operationen mit 100,000 Zahlen durchführen kann.</p>
</div>
<div id="der-in-operator" class="section level3">
<h3><span class="header-section-number">2.3.2</span> Der <code>%in%</code> Operator</h3>
<p>Um zu testen, ob ein oder mehrere Elemente in einem Vektor enthalten sind, kann man den <code>%in%</code>-Operator verwenden. Der sieht zwar gewöhnungsbedürftig aus, ist aber einfach zu verwenden und hat auch eine einfache verbale Interpretation: Sind die Elemente aus Vektor A in Vektor B?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="dv">2</span> <span class="op">%in%</span><span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">3</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="dv">4</span> <span class="op">%in%</span><span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">3</span></code></pre></div>
<pre><code>[1] FALSE</code></pre>
<p>Der <code>%in%</code>-Operator testet für jedes der Elemente <em>vor</em> <code>%in%</code>, ob dieses im Vektor <em>nach</em> <code>%in%</code> enthalten ist:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">3</span>) <span class="op">%in%</span><span class="st"> </span><span class="dv">3</span><span class="op">:</span><span class="dv">5</span></code></pre></div>
<pre><code>[1] FALSE  TRUE</code></pre>
<p>Die Ausgabe der <code>%in%</code>-Operation ist also ein logischer Vektor; die Länge des Ausgabevektors entspricht dabei immer der Länge des Vektors auf der linken Seite von <code>%in%</code>.</p>
</div>
</div>
<div id="zugriff-auf-vektorelemente" class="section level2">
<h2><span class="header-section-number">2.4</span> Zugriff auf Vektorelemente</h2>
<p>Der Zugriff auf Daten ist ein wichtiger Abschnitt unserer Einleitung in die Grundlagen <code>R</code>s. In diesem Abschnitt lernen wir, wie wir Elemente aus einfachen Vektoren „herausgreifen“ können.</p>
<div id="veczugriff" class="section level3">
<h3><span class="header-section-number">2.4.1</span> Der <code>[·]</code>-Zugriff</h3>
<p>Daten können mit dem <code>[·]</code>-Zugriff<a href="#fn15" class="footnoteRef" id="fnref15"><sup>15</sup></a> <em>indexbasiert</em> aus Vektoren ausgewählt werden. Jedes Element im Vektor hat einen <em>Index</em>, der seiner Position im Vektor entspricht. Im folgenden Vektor etwa hat <code>2</code> den Index <code>1</code>, <code>4</code> den Index <code>2</code> und <code>1</code> den Index <code>3</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">daten &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">1</span>)</code></pre></div>
<p>Ich kann mit dem <code>[·]</code>-Zugriff durch Angabe des Index auf einzelne Elemente im Vektor zugreifen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">daten[<span class="dv">1</span>]</code></pre></div>
<pre><code>[1] 2</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xx &lt;-<span class="st"> </span>daten[<span class="dv">3</span>] <span class="co"># ein-elementiger Vektor</span>
xx</code></pre></div>
<pre><code>[1] 1</code></pre>
<p>Ebenso kann ich einen „Negativ“-Zugriff durchführen: Ich kann auswählen, welchen Index ich <em>nicht</em> in meinem Ergebnis haben will:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">daten[<span class="op">-</span><span class="dv">1</span>]</code></pre></div>
<pre><code>[1] 4 1</code></pre>
<p>Interessant wird diese Art des Zugriffs, da der Index in den <code>[·]</code> Klammern auch ein mehr-elementiger numerischer Vektor sein kann – hier nutzen wir die <code>c</code> Funktion:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">daten[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>)]</code></pre></div>
<pre><code>[1] 2 4</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">daten[<span class="op">-</span><span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">3</span>)]</code></pre></div>
<pre><code>[1] 2</code></pre>
</div>
<div id="logischerZugriff" class="section level3">
<h3><span class="header-section-number">2.4.2</span> <code>[·]</code>-Zugriff mit einem logischen Vektor</h3>
<p>Anstatt direkt den Index eines Elements zu übergeben – den wir häufig nicht wissen, da wir bei vielen Daten nicht den Überblick über die Position aller einzelnen Datenpunkte behalten – möchten wir häufig Daten auswählen, die eine bestimmte Eigenschaft erfüllen. Hierbei machen wir uns die logischen Operationen zunutze, die wir oben kennengelernt haben:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">meinVektor &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>)

auswahl &lt;-<span class="st"> </span>meinVektor <span class="op">&gt;</span><span class="st"> </span><span class="dv">5</span>
auswahl</code></pre></div>
<pre><code>[1] FALSE FALSE FALSE  TRUE  TRUE  TRUE</code></pre>
<p><code>auswahl</code> ist ein logischer Vektor, der kodiert, welche Elemente des Vektors <code>meinVektor</code> größer als 5 sind (spezifisch: an welchen Positionen ist in <code>meinVektor</code> ein Element enthalten, das größer ist als 5). Ich kann nun den <code>[·]</code>-Zugriff mithilfe von <code>auswahl</code> verwenden, um nur die Elemente auszuwählen, die größer sind als 5:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">meinVektor[auswahl]</code></pre></div>
<pre><code>[1] 7 8 9</code></pre>
<p>Hierbei wurden die Werte 7, 8 und 9 ausgewählt, da für diese Werte der Vektor <code>auswahl</code> auf <code>TRUE</code> steht. Genauer gesagt: <code>auswahl</code> steht für die Indexe 4, 5 und 6 auf <code>TRUE</code> und es gilt <code>meinVektor[4] == 7</code>, <code>meinVektor[5] == 8</code>, und <code>meinVektor[6] == 9</code>.</p>
<p>Man kann dieses Vorgehen sogar mit den UND/ODER-Operationen verknüpfen, um Daten anhand verschiedener Kriterien auszuwählen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">meinVektor &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">20</span>

auswahl &lt;-<span class="st"> </span>(meinVektor <span class="op">&lt;</span><span class="st"> </span><span class="dv">5</span>) <span class="op">|</span><span class="st"> </span>(meinVektor <span class="op">&gt;</span><span class="st"> </span><span class="dv">17</span>)
auswahl</code></pre></div>
<pre><code> [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[12] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">meinVektor[auswahl]</code></pre></div>
<pre><code>[1]  1  2  3  4 18 19 20</code></pre>
<p>Hier ein weiteres Beispiel mit normalverteilten Zufallsdaten:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Wähle alle Daten aus, die größer sind als 2 (das sollten im Schnitt
## etwa 2.5% der Daten sein)
daten &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">300</span>)
daten[daten <span class="op">&gt;</span><span class="st"> </span><span class="dv">2</span>]</code></pre></div>
<pre><code>[1] 3.196362 2.386513 2.791331 2.123950</code></pre>
<p>An dieser Stelle sollte man sich klar machen, warum <code>daten</code> sowohl vor als auch innerhalb der <code>[·]</code> Klammern vorkommt. Das ist prinzipiell dasselbe wie im Beispiel <code>meinVektor[auswahl]</code> oben, nur das ich dort den <code>TRUE/FALSE</code> Vektor, der die Daten ausgewählt hat, in einer Variablen – <code>auswahl</code> – zwischengespeichert habe.</p>
</div>
<div id="vektorAendern" class="section level3">
<h3><span class="header-section-number">2.4.3</span> <code>[·]</code>-Zugriff zum Ändern von Daten</h3>
<p>Wir sind mit dem <code>[·]</code>-Zugriff nicht darauf beschränkt Elemente aus Vektoren auszulesen, sondern wir können auf diese Weise auch einzelne Elemente im Vektor verändern:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">daten &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">5</span>
daten[<span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">5</span>)] &lt;-<span class="st"> </span><span class="dv">0</span>
daten</code></pre></div>
<pre><code>[1] 1 0 3 4 0</code></pre>
<p>Dies geht wiederum auch mit einem logischen Vektor in den <code>[·]</code>-Klammern, wie das folgende Beispiel zeigt:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">daten &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">5</span>
daten[<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">FALSE</span>)] &lt;-<span class="st"> </span><span class="dv">0</span>
daten</code></pre></div>
<pre><code>[1] 0 2 0 4 5</code></pre>
<p>Das würde man so “händisch” nicht machen, aber es soll zum Verständnis dessen dienen, was im folgenden – anwendungsnäheren – Beispiel passiert. Angenommen, bei einer Dateneingabe wurden fehlende Werte in einem Fragebogen mit <code>-99</code> kodiert.<a href="#fn16" class="footnoteRef" id="fnref16"><sup>16</sup></a> Wir wollen <code>R</code> mitteilen, diesen Wert als fehlend zu interpretieren. Hier kommt uns wiederum eine logische Abfrage zugute:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">daten &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="op">-</span><span class="dv">99</span>, <span class="dv">5</span>, <span class="op">-</span><span class="dv">99</span>, <span class="dv">2</span>, <span class="op">-</span><span class="dv">99</span>, <span class="dv">4</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>)
daten</code></pre></div>
<pre><code> [1]   1 -99   5 -99   2 -99   4   1   2   3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">missing_values &lt;-<span class="st"> </span>daten <span class="op">==</span><span class="st"> </span><span class="op">-</span><span class="dv">99</span>
missing_values</code></pre></div>
<pre><code> [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE</code></pre>
<p>Die Variable <code>missing_values</code> kodiert jetzt, an welchen Positionen des Vektors <code>daten</code> sich eine <code>-99</code> befindet. Wir können diese Werte nun wie folgt durch <code>NA</code> ersetzen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">daten[missing_values] &lt;-<span class="st"> </span><span class="ot">NA</span>
daten</code></pre></div>
<pre><code> [1]  1 NA  5 NA  2 NA  4  1  2  3</code></pre>
<p>Semantisch ist dieser Vorgang gut zu verstehen: Setze alle Werte, die einen fehlenden Wert enthalten – d.h. mit -99 kodiert wurden – auf <code>NA</code>, damit <code>R</code> für weitere Berechnungen weiß, dass diese Werte als fehlend zu verstehen sind. Technisch umgesetzt wird dies mit einem <code>TRUE</code>/<code>FALSE</code> Vektor, den wir mithilfe der Anweisung <code>daten == -99</code> erstellt haben.</p>
<p> </p>
<p>Wir werden wohl selten “händisch” per Index oder logischem <code>TRUE</code>/<code>FALSE</code> Vektor eine Auswahl/Änderung von Daten durchführen. Aber in Zusammenarbeit mit den logischen Operatoren (<code>&gt;</code>, <code>&lt;</code>, <code>==</code>, <code>&amp;</code>, <code>|</code> etc.) ist die Auswahl von Elementen aus Vektoren – und auch die Auswahl von Daten aus Tabellen – eine häufige Anwendung. Diese werden wir bei der gezielten Auswahl von Zeilen aus Datentabellen (siehe Kapitel 3) wiederfinden und uns zunutze machen. Das gegebene Beispiel zum Umkodieren von fehlenden Werten werden wir in einer sehr ähnlichen Form umsetzen, da wir sonst die Daten des Narcissistic Personality Inventory nicht auswerten können. Bevor die Analyse starten kann, müssen fehlende Werte gekennzeichnet werden.</p>
</div>
</div>
<div id="praezedenz" class="section level2">
<h2><span class="header-section-number">2.5</span> Präzedenz</h2>
<p>Durch Klammerung können wir die <em>Präzedenz</em> von <code>R</code>-Befehlen steuern. Präzendenz bezieht sich auf die Reihenfolge, in der <code>R</code>-Befehle ausgeführt werden. Betrachten wir das folgende Beispiel:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="ot">TRUE</span> <span class="op">|</span><span class="st"> </span><span class="ot">TRUE</span> <span class="op">&amp;</span><span class="st"> </span><span class="ot">FALSE</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<p>Die Ausgabe ist <code>TRUE</code>. Daraus können wir schlussfolgern, dass die Befehle ODER und UND <strong>nicht</strong> von links nach rechts ausgeführt wurden. In dem Fall wäre nämlich zunächst <code>TRUE | TRUE</code> ausgeführt worden, was <code>TRUE</code> ergibt. Dieses Ergebnis (also <code>TRUE</code>) wäre dann per UND mit <code>FALSE</code> verknüpft worden, was insgesamt <code>FALSE</code> ausgegeben hätte. Wir haben aber <code>TRUE</code> bekommen. Warum?</p>
<p>Der Grund: <strong>Die UND-Operation hat eine höhere Präzedenz als die ODER-Operation</strong>. Wenn UND und ODER in einem logischen Ausdruck verbunden werden, wird zunächst die UND und dann die ODER-Operation ausgeführt, unabhängig davon, in welcher Reihenfolge wir die Befehle aufschreiben. Möchten wir erzwingen, dass die ODER-Operation zuerst durchgeführt wird, können wir – ganz analog zu mathematischen Berechnungen – Klammern verwenden:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(<span class="ot">TRUE</span> <span class="op">|</span><span class="st"> </span><span class="ot">TRUE</span>) <span class="op">&amp;</span><span class="st"> </span><span class="ot">FALSE</span></code></pre></div>
<pre><code>[1] FALSE</code></pre>
<p>Die Präzendenzregeln gelten ebenfalls, wenn die logischen Vektoren aus mehr als einem Element bestehen. Betrachten wir dazu die folgenden Beispiele:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">c</span>(<span class="ot">FALSE</span>, <span class="ot">TRUE</span>) <span class="op">|</span><span class="st"> </span><span class="kw">c</span>(<span class="ot">FALSE</span>, <span class="ot">FALSE</span>) <span class="op">&amp;</span><span class="st"> </span><span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>)</code></pre></div>
<pre><code>[1] FALSE  TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(<span class="kw">c</span>(<span class="ot">FALSE</span>, <span class="ot">TRUE</span>) <span class="op">|</span><span class="st"> </span><span class="kw">c</span>(<span class="ot">FALSE</span>, <span class="ot">FALSE</span>)) <span class="op">&amp;</span><span class="st"> </span><span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>)</code></pre></div>
<pre><code>[1] FALSE FALSE</code></pre>
<p>Wir werden logische Ausdrücke vor allem zur Fallauswahl in Datentabellen verwenden (siehe <a href="dataframes.html#datenzugriffe">Kapitel 3</a>). Dann kann es sehr wichtig sein, auf korrekte Klammerung zu achten. Andernfalls besteht die Gefahr, dass wir nicht genau die Fälle auswählen, die wir eigentlich auswählen wollen.</p>
<p>Betrachten wir ein weiteres Beispiel zur Steuerung von Präzedenz: Nehmen wir an, wir benötigen eine Sequenz aller Zahlen zwischen 1 und 10 – außer der 8.<a href="#fn17" class="footnoteRef" id="fnref17"><sup>17</sup></a> Ein naheliegender Befehl wäre folgender:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="dv">1</span><span class="op">:</span><span class="dv">10</span>[<span class="op">-</span><span class="dv">8</span>]</code></pre></div>
<pre><code> [1]  1  2  3  4  5  6  7  8  9 10</code></pre>
<p>Das hat aber nicht funktioniert, die Acht ist in der Ausgabe enthalten. Woran liegt das? <strong>Die Auswahl per eckiger Klammer hat eine höhere Präzedenz als der Doppelpunktoperator.</strong> Die Klammerungsoperation zur Auswahl aus einem Vektor wurde also nicht auf den Vektor <code>1:10</code>, sondern auf den Vektor <code>10</code> angewendet (Erinnerung: Einzelne Zahlen sind Vektoren). Das heißt, in diesem Beispiel wurde als Erstes das achte Element aus dem Vektor <code>10</code> ausgeschlossen, das aber gar nicht existiert. Stattdessen erhalten wir einfach wieder <code>10</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="dv">10</span>[<span class="op">-</span><span class="dv">8</span>]</code></pre></div>
<pre><code>[1] 10</code></pre>
<p>Durch Klammerung können wir das gewünschte Ergebnis erhalten:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)[<span class="op">-</span><span class="dv">8</span>]</code></pre></div>
<pre><code>[1]  1  2  3  4  5  6  7  9 10</code></pre>
<div class="block">
<p>
<strong>Merke</strong>: Im Zweifel verwenden wir Klammern lieber einmal zu viel als einmal zu wenig.
</p>
</div>

</div>
<div id="zusammenfassung" class="section level2">
<h2><span class="header-section-number">2.6</span> Zusammenfassung</h2>
<ul>
<li>Wir haben <code>R</code>s grundlegendste Datenstruktur, den Vektor, kennengelernt</li>
<li>Vektoren enthalten beliebig viele Elemente gleichartiger Daten, etwa
<ul>
<li>Zahlen (“numeric”)</li>
<li>Texte (“character”)</li>
<li>Kategorielle Daten (“factor”)</li>
<li><code>TRUE</code>/<code>FALSE</code> (“logical”)</li>
</ul></li>
<li>Mit dem <code>[·]</code>-Zugriff kann man Elemente aus Vektoren auswählen
<ol style="list-style-type: lower-alpha">
<li>indem man die Position der Elemente angibt, die man auswählen will (“Positivauswahl”)</li>
<li>indem man die Position der Elemente angibt, die man <strong>nicht</strong> auswählen will (“Negativauswahl”)</li>
<li>indem man einen <code>TRUE</code>/<code>FALSE</code> Vektor angibt</li>
</ol></li>
<li>Man kann mit logischen Vergleichen die Eigenschaften von Vektoren überprüfen
<ul>
<li>diese Operation lässt sich gut mit der <code>[·]</code>-Auswahl verbinden</li>
</ul></li>
</ul>
</div>
<div id="fragen-zum-vertiefenden-verstandnis" class="section level2">
<h2><span class="header-section-number">2.7</span> Fragen zum vertiefenden Verständnis</h2>
<ol style="list-style-type: decimal">
<li>Wie berechnet man den Standardfehler von <code>1:10</code>?</li>
<li>Was für Objekte nimmt die Funktion <code>c</code> entgegen, und was gibt sie zurück?</li>
<li>Was ergibt <code>1:6 + 1:2</code>? Was passiert? Warum gibt <code>1:4 + 1:3</code> eine Warnmeldung aus?</li>
<li>Nutzt <code>paste0</code>, den <code>:</code>-Operator und den <code>[·]</code>-Negativ-Zugriff, um den folgenden Vektor zu erstellen:</li>
</ol>
<pre><code>[1] &quot;item_2&quot;  &quot;item_4&quot;  &quot;item_5&quot;  &quot;item_6&quot;  &quot;item_7&quot;  &quot;item_8&quot;  &quot;item_10&quot;</code></pre>
<ol start="5" style="list-style-type: decimal">
<li>In <code>R</code> haben Elemente eines Vektors nur einen Datentyp. Der Befehl <code>c(1, 'moep')</code> vermischt eine Zahl und einen Text miteinander, aber ergibt keinen Fehler – was ist passiert?</li>
<li>Was sind plausible Ergebnisse von <code>sum(rnorm(100) &gt; 1.645)</code>? (Erst überlegen, dann mehrfach in der <code>R</code>-Konsole ausführen!)</li>
<li>Was sind die Ausgaben von <code>mode(2)</code> und <code>mode(mode(2))</code>. Warum?</li>
<li>Was ist der Unterschied zwischen <code>sum(c(TRUE, FALSE, TRUE))</code> und <code>length(c(TRUE, FALSE, TRUE))</code>?</li>
</ol>

</div>
</div>
<div class="footnotes">
<hr />
<ol start="4">
<li id="fn4"><p>Interessanterweise gibt es sogar Vektoren der Länge 0 – also Vektoren, die gar kein Element beinhalten. Das soll uns aber erst einmal nicht beschäftigen.<a href="vektoren.html#fnref4">↩</a></p></li>
<li id="fn5"><p><code>R</code> würde oft auch bei einelementigen Vektoren ein Ergebnis ausgeben, aber das ist zum Beispiel beim Mittelwert wenig sinnvoll.<a href="vektoren.html#fnref5">↩</a></p></li>
<li id="fn6"><p>Wir werden nur diese Fälle betrachten: Entweder wird ein ein-elementiger Vektor mit einem längeren Vektor verknüpft oder zwei gleich lange Vektoren werden miteinander verknüpft. Es ist auch möglich, andere Kombinationen von Vektorlängen zu paaren, was wir jedoch erst einmal vernachlässigen; interessierte Leser können die Befehle <code>c(1,2) * 1:4</code> und <code>c(1,2) * 1:3</code> in die <code>R</code>-Konsole eingeben und beobachten, was passiert.<a href="vektoren.html#fnref6">↩</a></p></li>
<li id="fn7"><p>Bis jetzt kennen wir nur das Vektor-Objekt. In <code>R</code> gibt es aber ganz verschiedene „Datencontainer“, die allgemein als Objekte bezeichnet werden.<a href="vektoren.html#fnref7">↩</a></p></li>
<li id="fn8"><p>Ich werde von dieser Regel in diesem Skript abweichen.<a href="vektoren.html#fnref8">↩</a></p></li>
<li id="fn9"><p>Leider sind Fehlermeldungen in <code>R</code> oftmals sehr kryptisch und gerade für Anfänger schwer verständlich.<a href="vektoren.html#fnref9">↩</a></p></li>
<li id="fn10"><p><a href="https://de.wikipedia.org/wiki/Boolesche_Algebra#Zweielementige_boolesche_Algebra" class="uri">https://de.wikipedia.org/wiki/Boolesche_Algebra#Zweielementige_boolesche_Algebra</a><a href="vektoren.html#fnref10">↩</a></p></li>
<li id="fn11"><p>Eigentlich ist <code>NA</code> kein eigener Datentyp. In <code>R</code> hat jeder Vektor <strong>nur genau einen</strong> Datentyp. Es ist beispielsweise nicht möglich, dass in einem Vektor gleichzeitig Werte vom Typ <code>numeric</code>, <code>character</code> und <code>factor</code> vorkommen. <code>NA</code>-Werte können jedoch in Kombination mit jedem Datentyp vorkommen. Sie kodieren dann die Abwesenheit eines Datums; dieses Datum hätte – wenn es nicht fehlen würde – den Datentyp des Vektors.<a href="vektoren.html#fnref11">↩</a></p></li>
<li id="fn12"><p>Ein Argument heißt optional, wenn wir dafür keinen Wert angeben müssen. Stattdessen hat es einen sogenannten Standardwert, der angenommen wird, wenn wir das Argument nicht selber angeben. Der Standardwert des Arguments <code>na.rm</code> in der Funktion <code>mean</code> ist <code>FALSE</code>.<a href="vektoren.html#fnref12">↩</a></p></li>
<li id="fn13"><p>Wenn logische Vektoren einer numerischen Berechnung übergeben werden, werden die <code>TRUE</code>/<code>FALSE</code> Elemente des Vektors automatisch in Zahlen, d.h. 1 und 0 umgewandelt. Deswegen funktioniert beispielsweise auch folgender Befehl: <code>TRUE + 1</code><a href="vektoren.html#fnref13">↩</a></p></li>
<li id="fn14"><p><code>pnorm</code> ist die kummulative Verteilungsfunktion der Normalverteilung. Sie sagt aus, wie viel % der Werte in einer Normalverteilung kleiner sind als der übergebene Wert. Um heraus zu finden, wie viele Werte <strong>größer</strong> als 1 sind, wird hier das Komplement, also <code>1 - pnorm(1)</code>, gebildet. (Das funktioniert, da die Gesamtdichte einer Wahrscheinlichkeitsverteilung immer 1 ist.)<a href="vektoren.html#fnref14">↩</a></p></li>
<li id="fn15"><p>Ich nenne diese Operation <code>[·]</code>-Zugriff , da zur Datenauswahl aus Vektoren hinter den Vektor eckigen Klammern gestellt werden. Die Klammern enthalten eine Angabe darüber, welche Elemente ich aus dem Vektor auswählen will. Etwa wählt <code>c(4, 2, 6)[1]</code> das erste Element aus dem Vektor <code>c(4, 2, 6)</code> aus, also 4. Der Punkt ist bloß ein Platzhalter in der <code>[·]</code>-Notation.<a href="vektoren.html#fnref15">↩</a></p></li>
<li id="fn16"><p>Das macht beispielsweise Sinn, damit bei der Eingabe explizit gemacht wird, dass der Wert fehlt. Andernfalls könnte das Datum bei der Eingabe auch vergessen worden sein.<a href="vektoren.html#fnref16">↩</a></p></li>
<li id="fn17"><p>Das Beispiel mag hier künstlich wirken, aber genau so etwas werden wir in <a href="psychometrie.html#trennschaerfe">Kapitel 4</a> machen.<a href="vektoren.html#fnref17">↩</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="einstieg.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="dataframes.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
},
"search": false
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
