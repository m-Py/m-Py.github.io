<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title></title>
  <meta name="description" content="<div style="white-space: pre-line;">Testtheorie mit R</div>">
  <meta name="generator" content="bookdown 0.7 and GitBook 2.6.7">

  <meta property="og:title" content="" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="" />
  
  
  




  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="dataframes.html">
<link rel="next" href="funktionen.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="1" data-path="einstieg.html"><a href="einstieg.html"><i class="fa fa-check"></i><b>1</b> Einstieg</a><ul>
<li class="chapter" data-level="1.1" data-path="einstieg.html"><a href="einstieg.html#uber-dieses-skript"><i class="fa fa-check"></i><b>1.1</b> Über dieses Skript</a><ul>
<li class="chapter" data-level="1.1.1" data-path="einstieg.html"><a href="einstieg.html#feedback-und-fehlermeldungen"><i class="fa fa-check"></i><b>1.1.1</b> Feedback und Fehlermeldungen</a></li>
<li class="chapter" data-level="1.1.2" data-path="einstieg.html"><a href="einstieg.html#danksagung"><i class="fa fa-check"></i><b>1.1.2</b> Danksagung</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="einstieg.html"><a href="einstieg.html#erste-schritte-mit-r"><i class="fa fa-check"></i><b>1.2</b> Erste Schritte mit <code>R</code></a><ul>
<li class="chapter" data-level="1.2.1" data-path="einstieg.html"><a href="einstieg.html#die-r-konsole"><i class="fa fa-check"></i><b>1.2.1</b> Die <code>R</code>-Konsole</a></li>
<li class="chapter" data-level="1.2.2" data-path="einstieg.html"><a href="einstieg.html#der-skript-editor"><i class="fa fa-check"></i><b>1.2.2</b> Der Skript-Editor</a></li>
<li class="chapter" data-level="1.2.3" data-path="einstieg.html"><a href="einstieg.html#kommentare"><i class="fa fa-check"></i><b>1.2.3</b> Kommentare</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="einstieg.html"><a href="einstieg.html#ausblick"><i class="fa fa-check"></i><b>1.3</b> Ausblick</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="vektoren.html"><a href="vektoren.html"><i class="fa fa-check"></i><b>2</b> Vektoren</a><ul>
<li class="chapter" data-level="2.1" data-path="vektoren.html"><a href="vektoren.html#variablen"><i class="fa fa-check"></i><b>2.1</b> Variablen</a><ul>
<li class="chapter" data-level="2.1.1" data-path="vektoren.html"><a href="vektoren.html#ausgabevsabspeichern"><i class="fa fa-check"></i><b>2.1.1</b> Ausgabe versus Abspeichern</a></li>
<li class="chapter" data-level="2.1.2" data-path="vektoren.html"><a href="vektoren.html#variablennamen"><i class="fa fa-check"></i><b>2.1.2</b> Variablennamen</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="vektoren.html"><a href="vektoren.html#datentypen-von-vektoren"><i class="fa fa-check"></i><b>2.2</b> Datentypen von Vektoren</a><ul>
<li class="chapter" data-level="2.2.1" data-path="vektoren.html"><a href="vektoren.html#character"><i class="fa fa-check"></i><b>2.2.1</b> <code>character</code></a></li>
<li class="chapter" data-level="2.2.2" data-path="vektoren.html"><a href="vektoren.html#logical"><i class="fa fa-check"></i><b>2.2.2</b> <code>logical</code></a></li>
<li class="chapter" data-level="2.2.3" data-path="vektoren.html"><a href="vektoren.html#factor"><i class="fa fa-check"></i><b>2.2.3</b> <code>factor</code></a></li>
<li class="chapter" data-level="2.2.4" data-path="vektoren.html"><a href="vektoren.html#na"><i class="fa fa-check"></i><b>2.2.4</b> <code>NA</code></a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="vektoren.html"><a href="vektoren.html#logische-vergleiche"><i class="fa fa-check"></i><b>2.3</b> Logische Vergleiche</a><ul>
<li class="chapter" data-level="2.3.1" data-path="vektoren.html"><a href="vektoren.html#der-in-operator"><i class="fa fa-check"></i><b>2.3.1</b> Der <code>%in%</code> Operator</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="vektoren.html"><a href="vektoren.html#zugriff-auf-vektorelemente"><i class="fa fa-check"></i><b>2.4</b> Zugriff auf Vektorelemente</a><ul>
<li class="chapter" data-level="2.4.1" data-path="vektoren.html"><a href="vektoren.html#veczugriff"><i class="fa fa-check"></i><b>2.4.1</b> Der <code>[·]</code>-Zugriff</a></li>
<li class="chapter" data-level="2.4.2" data-path="vektoren.html"><a href="vektoren.html#logischerZugriff"><i class="fa fa-check"></i><b>2.4.2</b> <code>[·]</code>-Zugriff mit einem logischen Vektor</a></li>
<li class="chapter" data-level="2.4.3" data-path="vektoren.html"><a href="vektoren.html#vektorAendern"><i class="fa fa-check"></i><b>2.4.3</b> <code>[·]</code>-Zugriff zum Ändern von Daten</a></li>
</ul></li>
<li class="chapter" data-level="2.5" data-path="vektoren.html"><a href="vektoren.html#zusammenfassung"><i class="fa fa-check"></i><b>2.5</b> Zusammenfassung</a></li>
<li class="chapter" data-level="2.6" data-path="vektoren.html"><a href="vektoren.html#fragen-zum-vertiefenden-verstandnis"><i class="fa fa-check"></i><b>2.6</b> Fragen zum vertiefenden Verständnis</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="dataframes.html"><a href="dataframes.html"><i class="fa fa-check"></i><b>3</b> <code>data.frames</code></a><ul>
<li class="chapter" data-level="3.1" data-path="dataframes.html"><a href="dataframes.html#die-funktion-data.frame"><i class="fa fa-check"></i><b>3.1</b> Die Funktion <code>data.frame</code></a></li>
<li class="chapter" data-level="3.2" data-path="dataframes.html"><a href="dataframes.html#datenzugriffe"><i class="fa fa-check"></i><b>3.2</b> Datenzugriffe</a><ul>
<li class="chapter" data-level="3.2.1" data-path="dataframes.html"><a href="dataframes.html#zugriff-auf-eine-einzelne-spalte-die--notation"><i class="fa fa-check"></i><b>3.2.1</b> Zugriff auf eine einzelne Spalte: die <code>$</code>-Notation</a></li>
<li class="chapter" data-level="3.2.2" data-path="dataframes.html"><a href="dataframes.html#zugriff-auf-spalten-und-zeilen-die--notation"><i class="fa fa-check"></i><b>3.2.2</b> Zugriff auf Spalten und Zeilen: die <code>[·,·]</code>-Notation</a></li>
<li class="chapter" data-level="3.2.3" data-path="dataframes.html"><a href="dataframes.html#doppelteckig"><i class="fa fa-check"></i><b>3.2.3</b> Weitere Zugriffsmöglichkeiten auf Spalten</a></li>
<li class="chapter" data-level="3.2.4" data-path="dataframes.html"><a href="dataframes.html#subset"><i class="fa fa-check"></i><b>3.2.4</b> Zugriff auf Spalten und Zeilen: die Funktion <code>subset</code></a></li>
<li class="chapter" data-level="3.2.5" data-path="dataframes.html"><a href="dataframes.html#nameindex"><i class="fa fa-check"></i><b>3.2.5</b> Zugriff nach Name und Index</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="dataframes.html"><a href="dataframes.html#convenient"><i class="fa fa-check"></i><b>3.3</b> Nützliche Funktionen zum Arbeiten mit <code>data.frames</code></a><ul>
<li class="chapter" data-level="3.3.1" data-path="dataframes.html"><a href="dataframes.html#tapply"><i class="fa fa-check"></i><b>3.3.1</b> <code>tapply</code></a></li>
<li class="chapter" data-level="3.3.2" data-path="dataframes.html"><a href="dataframes.html#nrow-und-ncol"><i class="fa fa-check"></i><b>3.3.2</b> <code>nrow</code> und <code>ncol</code></a></li>
<li class="chapter" data-level="3.3.3" data-path="dataframes.html"><a href="dataframes.html#head-und-tail"><i class="fa fa-check"></i><b>3.3.3</b> <code>head</code> und <code>tail</code></a></li>
<li class="chapter" data-level="3.3.4" data-path="dataframes.html"><a href="dataframes.html#sortieren-dplyrarrange"><i class="fa fa-check"></i><b>3.3.4</b> Sortieren: <code>dplyr::arrange</code></a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="dataframes.html"><a href="dataframes.html#zusammenfassung-1"><i class="fa fa-check"></i><b>3.4</b> Zusammenfassung</a></li>
<li class="chapter" data-level="3.5" data-path="dataframes.html"><a href="dataframes.html#fragen-zum-vertiefenden-verstandnis-1"><i class="fa fa-check"></i><b>3.5</b> Fragen zum vertiefenden Verständnis</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="psychometrie.html"><a href="psychometrie.html"><i class="fa fa-check"></i><b>4</b> Arbeiten mit psychometrischen Daten</a><ul>
<li class="chapter" data-level="4.1" data-path="psychometrie.html"><a href="psychometrie.html#kap4einstieg"><i class="fa fa-check"></i><b>4.1</b> Ausgedehntes Beispiel zum Einstieg</a><ul>
<li class="chapter" data-level="4.1.1" data-path="psychometrie.html"><a href="psychometrie.html#testscores"><i class="fa fa-check"></i><b>4.1.1</b> Testscores</a></li>
<li class="chapter" data-level="4.1.2" data-path="psychometrie.html"><a href="psychometrie.html#item-schwierigkeiten"><i class="fa fa-check"></i><b>4.1.2</b> Item-Schwierigkeiten</a></li>
<li class="chapter" data-level="4.1.3" data-path="psychometrie.html"><a href="psychometrie.html#item-interkorrelationen"><i class="fa fa-check"></i><b>4.1.3</b> Item-Interkorrelationen</a></li>
<li class="chapter" data-level="4.1.4" data-path="psychometrie.html"><a href="psychometrie.html#trennschaerfe"><i class="fa fa-check"></i><b>4.1.4</b> Item-Trennschärfen</a></li>
<li class="chapter" data-level="4.1.5" data-path="psychometrie.html"><a href="psychometrie.html#cronbachs-alpha"><i class="fa fa-check"></i><b>4.1.5</b> Cronbachs Alpha</a></li>
<li class="chapter" data-level="4.1.6" data-path="psychometrie.html"><a href="psychometrie.html#split-half-reliabilitat"><i class="fa fa-check"></i><b>4.1.6</b> Split-Half-Reliabilität</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="psychometrie.html"><a href="psychometrie.html#umgang-mit-echten-daten"><i class="fa fa-check"></i><b>4.2</b> Umgang mit echten Daten</a><ul>
<li class="chapter" data-level="4.2.1" data-path="psychometrie.html"><a href="psychometrie.html#umkodierung"><i class="fa fa-check"></i><b>4.2.1</b> Umkodierung von Variablen</a></li>
<li class="chapter" data-level="4.2.2" data-path="psychometrie.html"><a href="psychometrie.html#invertierung-von-antworten"><i class="fa fa-check"></i><b>4.2.2</b> Invertierung von Antworten</a></li>
<li class="chapter" data-level="4.2.3" data-path="psychometrie.html"><a href="psychometrie.html#umgang-mit-fehlenden-werten"><i class="fa fa-check"></i><b>4.2.3</b> Umgang mit fehlenden Werten</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="psychometrie.html"><a href="psychometrie.html#zusammenfassung-2"><i class="fa fa-check"></i><b>4.3</b> Zusammenfassung</a></li>
<li class="chapter" data-level="4.4" data-path="psychometrie.html"><a href="psychometrie.html#fragen-zum-vertiefenden-verstandnis-2"><i class="fa fa-check"></i><b>4.4</b> Fragen zum vertiefenden Verständnis</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="funktionen.html"><a href="funktionen.html"><i class="fa fa-check"></i><b>5</b> Funktionen</a><ul>
<li class="chapter" data-level="5.1" data-path="funktionen.html"><a href="funktionen.html#das-black-box-modell"><i class="fa fa-check"></i><b>5.1</b> Das Black-Box-Modell</a></li>
<li class="chapter" data-level="5.2" data-path="funktionen.html"><a href="funktionen.html#argumente"><i class="fa fa-check"></i><b>5.2</b> Argumente</a><ul>
<li class="chapter" data-level="5.2.1" data-path="funktionen.html"><a href="funktionen.html#help"><i class="fa fa-check"></i><b>5.2.1</b> Die <code>R</code>-Hilfe</a></li>
<li class="chapter" data-level="5.2.2" data-path="funktionen.html"><a href="funktionen.html#namenlose-argumente"><i class="fa fa-check"></i><b>5.2.2</b> Namenlose Argumente</a></li>
</ul></li>
<li class="chapter" data-level="5.3" data-path="funktionen.html"><a href="funktionen.html#ruckgabewerte"><i class="fa fa-check"></i><b>5.3</b> Rückgabewerte</a></li>
<li class="chapter" data-level="5.4" data-path="funktionen.html"><a href="funktionen.html#seiteneffekte"><i class="fa fa-check"></i><b>5.4</b> Seiteneffekte</a></li>
<li class="chapter" data-level="5.5" data-path="funktionen.html"><a href="funktionen.html#selbst-geschriebene-funktionen"><i class="fa fa-check"></i><b>5.5</b> Selbst geschriebene Funktionen</a><ul>
<li class="chapter" data-level="5.5.1" data-path="funktionen.html"><a href="funktionen.html#definition-der-eigenen-funktion"><i class="fa fa-check"></i><b>5.5.1</b> Definition der eigenen Funktion</a></li>
<li class="chapter" data-level="5.5.2" data-path="funktionen.html"><a href="funktionen.html#lokale-variablen"><i class="fa fa-check"></i><b>5.5.2</b> Lokale Variablen</a></li>
<li class="chapter" data-level="5.5.3" data-path="funktionen.html"><a href="funktionen.html#optionale-argumente"><i class="fa fa-check"></i><b>5.5.3</b> Optionale Argumente</a></li>
<li class="chapter" data-level="5.5.4" data-path="funktionen.html"><a href="funktionen.html#wann-schreibe-ich-meine-eigene-funktion"><i class="fa fa-check"></i><b>5.5.4</b> Wann schreibe ich meine eigene Funktion</a></li>
</ul></li>
<li class="chapter" data-level="5.6" data-path="funktionen.html"><a href="funktionen.html#fragen-zum-vertiefenden-verstandnis-3"><i class="fa fa-check"></i><b>5.6</b> Fragen zum vertiefenden Verständnis</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="schleifen.html"><a href="schleifen.html"><i class="fa fa-check"></i><b>6</b> Schleifen</a><ul>
<li class="chapter" data-level="6.1" data-path="schleifen.html"><a href="schleifen.html#sequentielle-bepunktung-von-testitems"><i class="fa fa-check"></i><b>6.1</b> Sequentielle Bepunktung von Testitems</a></li>
<li class="chapter" data-level="6.2" data-path="schleifen.html"><a href="schleifen.html#berechnung-von-part-whole-korrigierten-trennscharfen"><i class="fa fa-check"></i><b>6.2</b> Berechnung von part-whole korrigierten Trennschärfen</a></li>
<li class="chapter" data-level="6.3" data-path="schleifen.html"><a href="schleifen.html#datenspeicherung-in-einer-schleife"><i class="fa fa-check"></i><b>6.3</b> Datenspeicherung in einer Schleife</a><ul>
<li class="chapter" data-level="6.3.1" data-path="schleifen.html"><a href="schleifen.html#adressierung-per-name"><i class="fa fa-check"></i><b>6.3.1</b> Adressierung per Name</a></li>
<li class="chapter" data-level="6.3.2" data-path="schleifen.html"><a href="schleifen.html#vektorspeicherung-adressierung-per-index"><i class="fa fa-check"></i><b>6.3.2</b> Vektorspeicherung – Adressierung per Index</a></li>
</ul></li>
<li class="chapter" data-level="6.4" data-path="schleifen.html"><a href="schleifen.html#abstraktion-trennscharfe-als-funktion"><i class="fa fa-check"></i><b>6.4</b> Abstraktion – Trennschärfe als Funktion</a></li>
<li class="chapter" data-level="6.5" data-path="schleifen.html"><a href="schleifen.html#for-loops-are-evil-oder-nicht"><i class="fa fa-check"></i><b>6.5</b> for-loops are evil – oder nicht?</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="simulationen.html"><a href="simulationen.html"><i class="fa fa-check"></i><b>7</b> Simulationen</a></li>
<li class="chapter" data-level="8" data-path="anhang.html"><a href="anhang.html"><i class="fa fa-check"></i><b>8</b> Anhang</a><ul>
<li class="chapter" data-level="8.1" data-path="anhang.html"><a href="anhang.html#datenEinlesen"><i class="fa fa-check"></i><b>8.1</b> Daten einlesen</a></li>
<li class="chapter" data-level="8.2" data-path="anhang.html"><a href="anhang.html#das-environment-sauber-halten"><i class="fa fa-check"></i><b>8.2</b> Das Environment sauber halten</a><ul>
<li class="chapter" data-level="8.2.1" data-path="anhang.html"><a href="anhang.html#variablen-loschen"><i class="fa fa-check"></i><b>8.2.1</b> Variablen löschen</a></li>
<li class="chapter" data-level="8.2.2" data-path="anhang.html"><a href="anhang.html#mit-einem-sauberen-environment-starten"><i class="fa fa-check"></i><b>8.2.2</b> Mit einem sauberen Environment starten</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="" data-path="referenzen.html"><a href="referenzen.html"><i class="fa fa-check"></i>Referenzen</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./"><div style="white-space: pre-line;">Testtheorie mit R</div></a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="psychometrie" class="section level1">
<h1><span class="header-section-number">4</span> Arbeiten mit psychometrischen Daten</h1>
<p>Dieses Kapitel arbeitet einige Kennwerte der klassischen Testtheorie auf und bespricht wie wir diese in <code>R</code> berechnen können. Dabei werden folgende Konzepte behandelt:</p>
<ul>
<li>Testscores</li>
<li>Item-Schwierigkeit</li>
<li>Item-Trennschärfe</li>
<li>Item-Interkorrelation</li>
<li>Reliabilität
<ul>
<li>Interne Konsistenz (“Cronbachs Alpha”)</li>
<li>Split-Half/Odd-Even-Reliabilität</li>
</ul></li>
<li>Spearman-Brown-Formel</li>
</ul>
<p>Ein weiterer Teil des Kapitels beschäftigt sich mit der Aufbereitung von Rohdaten, die im Normalfall leider nicht in der Form vorliegen, die wir für unsere Analysen benötigen. Wir lernen</p>
<ul>
<li>Antworten umzukodieren</li>
<li>Antworten zu invertieren</li>
<li>Fälle mit fehlenden Werten auszuschließen</li>
</ul>
<div id="kap4einstieg" class="section level2">
<h2><span class="header-section-number">4.1</span> Ausgedehntes Beispiel zum Einstieg</h2>
<p>Es folgt ein Beispiel zur Berechnung einiger grundlegender psychometrischer Kennwerte. Angenommen, uns liegt eine Datentabelle vor, die die Punktzahlen der Antworten von 10 Schulkindern auf 5 Aufgaben einer Klassenarbeit beinhaltet. Diese kann man gut in einer <span class="math inline">\(10 \times 5\)</span> (Reihe <span class="math inline">\(\times\)</span> Spalten) Datentabelle darstellen. Ein Eintrag kodiert, ob das Kind (<em>Reihe</em>) die Aufgabe (<em>Spalte</em>) korrekt gelöst hat. Korrekte Antworten werden mit 1 kodiert, falsche Antworten mit 0 – ein typisches Datenformat in der psychologischen Diagnostik.</p>
<p>Um das fortführende Beispiel selbst nachzuvollziehen, müsst ihr den folgenden <code>data.frame</code> erstellen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">test_data &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">Item_1 =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>),
                        <span class="dt">Item_2 =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>),
                        <span class="dt">Item_3 =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>),
                        <span class="dt">Item_4 =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>),
                        <span class="dt">Item_5 =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>))</code></pre></div>
<p>Die Variable <code>test_data</code> enthält nun die folgende Tabelle:</p>
<p> </p>
<table>
<thead>
<tr class="header">
<th></th>
<th align="right">Item_1</th>
<th align="right">Item_2</th>
<th align="right">Item_3</th>
<th align="right">Item_4</th>
<th align="right">Item_5</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td>2</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td>3</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td>4</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td>5</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td>6</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td>7</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td>8</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td>9</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td>10</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
</tbody>
</table>
<p> </p>
<p> </p>
<p>Wenn uns Daten in diesem Format vorliegen, können wir auf viele Funktionen in <code>R</code> zurückgreifen, um grundlegende psychometrische Auswertungen durchzuführen. Dies sind etwa die Bestimmung der Schwierigkeit und der Trennschärfe von Items, sowie die Bestimmung einer Split-Half Reliabilität. Für fortgeschrittenere Auswertungen – wie etwa die Berechnung von Cronbachs Alpha oder einer Faktorenanalyse – werden wir auf Pakete zurückgreifen, die uns über die Basics in <code>R</code> hinaus weitere Funktionalitäten bieten. Aber auch für diese Analysen benötigen wir genau dieses Datenformat!</p>
<div class="block">
<p>
<strong>Merke</strong>: Das ist das Standard-Datenformat für all unsere psychometrischen Berechnungen: (a) Zeilen sind Fälle; (b) Spalten sind Items bzw. Messvariablen; (c) Zellen enthalten Datenpunkte, etwa die Korrektheit von Antworten (kodiert mit 1/0). Datenpunkte müssen nicht unbedingt – wie es in diesem Beispiel der Fall ist – dichotom sein, sondern können beispielsweise auch die Antworten in einem Persönlichkeitsfragebogen auf einer Likert-Skala repräsentieren.
</p>
</div>
<div id="testscores" class="section level3">
<h3><span class="header-section-number">4.1.1</span> Testscores</h3>
<p>Wir bestimmen zunächst die Testscores der 10 Kinder. Da jede Zeile ein Kind repräsentiert, ist der Gesamt-Testscore ist die Summe der Werte in jeder Reihe. Die Summe der Reihen eines <code>data.frames</code> (engl: <em>rows</em>) kann man mit der Funktion <code>rowSums</code> bestimmen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">rowSums</span>(test_data) <span class="co"># test_data ist die Tabelle von oben.</span></code></pre></div>
<pre><code> [1] 4 1 5 0 3 1 2 1 2 0</code></pre>
<p>Es ist manchmal praktisch Berechnungen, die pro Fall einen Wert ergeben, direkt an den ursprünglichen <code>data.frame</code> anzuhängen. Wie in Kapitel 3 erklärt, ist das mit der <code>$</code>-Notation möglich:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">test_data<span class="op">$</span>score &lt;-<span class="st"> </span><span class="kw">rowSums</span>(test_data)</code></pre></div>
</div>
<div id="item-schwierigkeiten" class="section level3">
<h3><span class="header-section-number">4.1.2</span> Item-Schwierigkeiten</h3>
<p>Die Schwierigkeit eines Items ist die mittlere Punktzahl aller Personen in diesem Item.<a href="#fn39" class="footnoteRef" id="fnref39"><sup>39</sup></a> Das ist somit also einfach der Mittelwert der Einträge in jeder Spalte (engl: <em>column</em>) in unserem Standardformat. Den Mittelwert pro Spalte kann ich mit der Funktion <code>colMeans</code> bestimmen (analog gibt es auch die Funktionen <code>colSums</code> und <code>rowMeans</code>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">colMeans</span>(test_data)</code></pre></div>
<pre><code>Item_1 Item_2 Item_3 Item_4 Item_5  score 
   0.6    0.1    0.6    0.3    0.3    1.9 </code></pre>
<p>Da ich gerade den Gesamtscore als Spalte an <code>test_data</code> angehängt habe, bekomme ich die mittlere Punktzahl der Schüler/innen in den 5 Testitems direkt mitgeliefert. Beachtet, dass ich hier eine numerische Funktion auf den ganzen <code>data.frame</code> angewendet habe. Hätte ich beispielsweise auch Spalten vom Typ <code>factor</code> oder <code>numeric</code> im <code>data.frame</code> gehabt, hätte ich Funktionen wie <code>rowSums</code> und <code>colMeans</code> nicht einfach auf den ganzen <code>data.frame</code> anwenden können.<a href="#fn40" class="footnoteRef" id="fnref40"><sup>40</sup></a></p>
</div>
<div id="item-interkorrelationen" class="section level3">
<h3><span class="header-section-number">4.1.3</span> Item-Interkorrelationen</h3>
<p>Als nächstes geben wir die Korrelationen zwischen allen Items als Korrelationsmatrix aus. Dies funktioniert mit der Funktion <code>cor</code>. Wenn <code>cor</code> als Argument einen <code>data.frame</code> erhält, wird eine Tabelle ausgegeben, die die Korrelation zwischen allen Spalten – d.h. Items – des <code>data.frames</code> enthält.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">round</span>(<span class="kw">cor</span>(test_data), <span class="dv">2</span>)</code></pre></div>
<table>
<thead>
<tr class="header">
<th></th>
<th align="right">Item_1</th>
<th align="right">Item_2</th>
<th align="right">Item_3</th>
<th align="right">Item_4</th>
<th align="right">Item_5</th>
<th align="right">score</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Item_1</td>
<td align="right">1.00</td>
<td align="right">0.27</td>
<td align="right">0.17</td>
<td align="right">0.09</td>
<td align="right">0.09</td>
<td align="right">0.47</td>
</tr>
<tr class="even">
<td>Item_2</td>
<td align="right">0.27</td>
<td align="right">1.00</td>
<td align="right">0.27</td>
<td align="right">0.51</td>
<td align="right">0.51</td>
<td align="right">0.65</td>
</tr>
<tr class="odd">
<td>Item_3</td>
<td align="right">0.17</td>
<td align="right">0.27</td>
<td align="right">1.00</td>
<td align="right">0.53</td>
<td align="right">0.53</td>
<td align="right">0.72</td>
</tr>
<tr class="even">
<td>Item_4</td>
<td align="right">0.09</td>
<td align="right">0.51</td>
<td align="right">0.53</td>
<td align="right">1.00</td>
<td align="right">1.00</td>
<td align="right">0.87</td>
</tr>
<tr class="odd">
<td>Item_5</td>
<td align="right">0.09</td>
<td align="right">0.51</td>
<td align="right">0.53</td>
<td align="right">1.00</td>
<td align="right">1.00</td>
<td align="right">0.87</td>
</tr>
<tr class="even">
<td>score</td>
<td align="right">0.47</td>
<td align="right">0.65</td>
<td align="right">0.72</td>
<td align="right">0.87</td>
<td align="right">0.87</td>
<td align="right">1.00</td>
</tr>
</tbody>
</table>
<p> </p>
<p> </p>
<p>Die Korrelationen wurden aus Darstellungszwecken auf zwei Nachkommastellen gerundet, was mit der Funktion <code>round</code> erreicht wurde.</p>
</div>
<div id="trennschaerfe" class="section level3">
<h3><span class="header-section-number">4.1.4</span> Item-Trennschärfen</h3>
<p>Interessant ist die letzte Spalte (bzw. genauso die letzte Zeile) der Tabelle der Item-Korrelationen. Diese gibt an, wie stark die Korrelation zwischen jedem Item und dem Testscore ausfällt. Dieser Kennwert ist die (unkorrigierte) Trennschärfe der Items; wir erhalten sie, da wir oben den Testscore als Spalte an unseren <code>data.frame</code> angehängt haben. Die Item-Trennschärfe macht eine Aussage darüber, wie stark das Abschneiden in einem Item mit dem Gesamt-Testscore zusammenhängt. Je höher die Trennschärfe, desto besser vermag das Item zwischen Schüler/innen mit viel und wenig Wissen (also einem hohen bzw. einem niedrigen Gesamt-Testscore) zu trennen. Die Trennschärfe ist ein Kennwert, der zur Beurteilung der Güte eines Items dienen kann.</p>
<p>Oftmals wird die “part-whole” korrigierte Trennschärfe berechnet, bei der zur Berechnung der Trennschärfe jedes Items der Itemscore dieses Items aus der Gesamtpunktzahl ausgelassen wird. Somit wird eine “Kriterienkontamination” vermieden, die zu einer Erhöhung der Trennschärfe führt. Diese Kriterienkontamination ergibt sich bei der unkorrigierten Trennschärfe daraus, dass der Itemscore selbst in das “Kriterium” – also den Gesamt-Testscore – eingeht.<a href="#fn41" class="footnoteRef" id="fnref41"><sup>41</sup></a> Eine Möglichkeit, die “part-whole” korrigierte Trennschärfe für eine Item (hier: Item 2) zu berechnen, bietet der folgende Code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Zunächst erstelle ich einen Vektor zur Auswahl der Items, die ich zur
## Berechnung des Testscores heranziehe. Dabei wird Item 2
## ausgelassen. An dieser Stelle müssen wir die Namen der Spalten
## kennen, die wir auswählen wollen. Diese lassen sich mit dem Befehl
## `names` herausfinden:

<span class="kw">names</span>(test_data)</code></pre></div>
<pre><code>[1] &quot;Item_1&quot; &quot;Item_2&quot; &quot;Item_3&quot; &quot;Item_4&quot; &quot;Item_5&quot; &quot;score&quot; </code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Wähle nun Antworten auf Items 1, 3, 4, 5 aus:
select_items   &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="st">&quot;Item_&quot;</span>, (<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>)[<span class="op">-</span><span class="dv">2</span>])
responses_no_item2 &lt;-<span class="st"> </span><span class="kw">subset</span>(test_data, <span class="dt">select =</span> select_items)

## Betrachte die Tabelle:
responses_no_item2</code></pre></div>
<pre><code>   Item_1 Item_3 Item_4 Item_5
1       1      1      1      1
2       1      0      0      0
3       1      1      1      1
4       0      0      0      0
5       0      1      1      1
6       0      1      0      0
7       1      1      0      0
8       1      0      0      0
9       1      1      0      0
10      0      0      0      0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Berechne den Testscore über Items 1, 3, 4 und 5:
corrected_score &lt;-<span class="st"> </span><span class="kw">rowSums</span>(responses_no_item2)</code></pre></div>
<p><code>corrected_score</code> ist nun der Testscore ohne Beachtung des zweiten Items. Das Vorgehen zur Berechnung der bereinigten Scores mithilfe der Funktionen <code>paste0</code>, <code>subset</code> und <code>rowSums</code> lässt sich allgemein mit beliebig vielen Items durchführen. Da wir an dieser Stelle nur eine Summe über vier Items bilden, hätte auch der folgende – simplere – Code funktioniert:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">corrected_score &lt;-<span class="st"> </span>test_data<span class="op">$</span>Item_<span class="dv">1</span> <span class="op">+</span><span class="st"> </span>test_data<span class="op">$</span>Item_<span class="dv">3</span> <span class="op">+</span>
<span class="st">    </span>test_data<span class="op">$</span>Item_<span class="dv">4</span> <span class="op">+</span><span class="st"> </span>test_data<span class="op">$</span>Item_<span class="dv">5</span></code></pre></div>
<p>Wie folgt können wir nun mithilfe der Funktion <code>cor</code> die “part-whole” korrigierte Trennschärfe für Item 2 bestimmen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cor</span>(test_data<span class="op">$</span>Item_<span class="dv">2</span>, corrected_score)</code></pre></div>
<pre><code>[1] 0.5238095</code></pre>
<p>Wie wir sehen, liegt die korrigierte Trennschärfe von 0.52 unter der unkorrigierten Trennschärfe von 0.65. Je weniger Items der Test hat, desto mehr Gewicht hat das einzelne Item für den Testscore, und umso stärker weichen korrigierte und unkorrigierte Trennschärfe voneinander ab. Bei nur 5 Items kann der Effekt substantiell sein.</p>
<p>Es ist zu beachten, dass die Funktion <code>cor</code> an dieser Stelle anders verwendet wird als oben: Hier übergebe ich der Funktion <code>cor</code> mit dem Befehl <code>cor(test_data$Item_2, corrected_score)</code> zwei Vektoren gleicher Länge. Ein Vektor enthält die Korrektheiten der Antworten auf Item 2, der andere Vektor enthält den um Item 2 bereinigten Testscore. Oben habe ich der Funktion <code>cor</code> nur ein Argument übergeben, nämlich den <code>data.frame</code> <code>test_data</code>. In dem Fall wurde eine Tabelle ausgegeben – eine <em>Korrelationsmatrix</em> –, die die Korrelationen zwischen allen Spalten enthält.</p>
<p>Ich empfehle den Code-Block zur Berechnung der korrigierten Trennschärfe genau zu studieren. Darin finden sich viele der Grundlagen aus Kapitel 2 und 3 wieder:</p>
<ul>
<li>Die Erstellung von Vektoren mit der <code>1:n</code>-Notation</li>
<li>Die Negativ-Auswahl von Elementen aus Vektoren mit der <code>[·]</code>-Notation</li>
<li>Die Generierung eines “character”-Vektors mithilfe der Funktion <code>paste0</code></li>
<li>Die Auswahl von Spalten in einem <code>data.frame</code> mit der Funktion <code>subset</code></li>
</ul>
<p>Wir merken, dass es mühsamer ist, die korrigierte Trennschärfe zu berechnen als die unkorrigierte. Die unkorrigierte Trennschärfe erhalte ich einfach, indem ich einen <code>data.frame</code> an die Funktion <code>cor</code> übergebe. Ich muss nur einen einzigen Funktionsaufruf—oder eine Zeile Code—investieren. Um jedoch die korrigierte Trennschärfe zu bestimmen, muss ich bei <em>n</em> Items <em>n</em> Mal einen korrigierten Gesamtscore berechnen. Für jedes Item muss ich dann jeweils die Item-Antworten mit diesem korrigierten Score korrelieren. Wenn wir das für jedes Item “händisch” machen, wäre das sehr aufwendig (beispielsweise könnten wir den Code oben <em>n</em> Mal kopieren und jeweils die Itemnummern anpassen – das wäre sehr fehleranfällig). Einer der Hauptgründe, aus denen wir <code>R</code> lernen, ist dass wir uns solche Arbeit nicht machen wollen. Stattdessen wollen wir lernen, wie wir repetitive Arbeiten automatisieren können. Im nächsten Kapitel werden wir Programmierelemente von <code>R</code> kennenlernen, die uns ermöglichen, ohne wesentlich mehr Aufwand für beliebig viele Items korrigierte Trennschärfen zu bestimmen. So sparen wir gleichzeitig Aufwand und arbeiten weniger fehleranfällig.</p>
</div>
<div id="cronbachs-alpha" class="section level3">
<h3><span class="header-section-number">4.1.5</span> Cronbachs Alpha</h3>
<p>Als Nächstes bestimmen wir “Cronbachs Alpha” als Maß für die interne Konsistenz der Antworten der Schüler/innen. Cronbachs Alpha ist ein Schätzer für die Reliabilität eines Tests. Im Falle eines Leistungstest mit dichotomer Bepunktung gibt es eine Antwort auf die Frage: Haben Kinder, die ein Item richtig beantworten, auch eine erhöhte Wahrscheinlichkeit, andere Items richtig zu beantworten? (Ebenso: haben Kinder, die ein Item falsch beantworten, auch eine erhöhte Wahrscheinlichkeit, andere Items falsch zu beantworten?). Je näher Cronbachs Alpha an 1 ist, desto stärker ist das der Fall – desto stärker ist die interne Konsistenz der Punktwerte. Ein Wert von 0 spricht dafür, dass gar keine Systematik in den Punktzahlen liegt – ob ich viele oder wenig Punkte bekommen habe, ist gänzlich zufällig.</p>
<p><code>R</code> bietet in der Grundversion keine Möglichkeit, Cronbachs Alpha zu bestimmen. Man könnte sich eine eigene Berechnung programmieren, die Cronbachs Alpha umsetzt.<a href="#fn42" class="footnoteRef" id="fnref42"><sup>42</sup></a> Wir machen uns aber zunutze, dass bereits andere <code>R</code>-Nutzer Cronbachs Alpha als Funktion umgesetzt haben, und diese in einem <em>Paket</em> zur Verfügung gestellt haben. Eine Umsetzung von Cronbachs Alpha findet sich im Paket <code>psychometric</code> <span class="citation">(Fletcher 2010)</span>. Mit der Funktion <code>library</code> kann ich Pakete laden, die nicht zur Grundausstattung von <code>R</code> gehören.<a href="#fn43" class="footnoteRef" id="fnref43"><sup>43</sup></a> Voraussetzung ist, dass ich das Paket auf meinem Rechner installiert habe.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Das Paket `psychometric` enthält eine Funktion, die Cronbachs Alpha
## berechnet
<span class="kw">library</span>(<span class="st">&quot;psychometric&quot;</span>)</code></pre></div>
<p>Falls das Paket nicht installiert ist, kann ich es mit dem folgenden Befehl installieren:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">install.packages</span>(<span class="st">&quot;psychometric&quot;</span>)</code></pre></div>
<p>Praktischerweise arbeitet die Funktion <code>alpha</code> aus dem <code>psychometric</code> Paket genau mit dem Standard-Datenformat, das uns vorliegt: Zeilen kennzeichnen Testteilnehmer, Spalten kennzeichnen Items. <strong>Wichtig ist aber nun</strong>: Wir haben soeben den Testscore als zusätzliche Spalte an die Testdatentabelle angehängt. Diese geht aber nicht in die Berechnung von Cronbachs Alpha ein, sondern nur die Punktzahlen für die Items. Deswegen entferne ich die Spalte <code>score</code> wie folgt wieder:<a href="#fn44" class="footnoteRef" id="fnref44"><sup>44</sup></a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">test_data<span class="op">$</span>score &lt;-<span class="st"> </span><span class="ot">NULL</span>

## Prüfe, dass die Spalte wirklich weg ist:
<span class="kw">names</span>(test_data)</code></pre></div>
<pre><code>[1] &quot;Item_1&quot; &quot;Item_2&quot; &quot;Item_3&quot; &quot;Item_4&quot; &quot;Item_5&quot;</code></pre>
<p>Nachdem wir das Paket <code>psychometric</code> geladen haben, können wir Cronbachs Alpha mit der Funktion <code>alpha</code> bestimmen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alpha</span>(test_data) <span class="co"># erfordert Laden des Pakets psychometric</span></code></pre></div>
<pre><code>[1] 0.753012</code></pre>
</div>
<div id="split-half-reliabilitat" class="section level3">
<h3><span class="header-section-number">4.1.6</span> Split-Half-Reliabilität</h3>
<p>Cronbachs Alpha ist ein Schätzer für die Reliabilität eines Tests.<a href="#fn45" class="footnoteRef" id="fnref45"><sup>45</sup></a> Andere mögliche Schätzer sind die Retest-Reliabilität und die Split-Half-Reliabilität. Diese basieren auf der Berechnung einer Korrelation zwischen zwei Punktwerten. Für die Bestimmung der Retest-Reliabilität lassen wir Testteilnehmer zweimal denselben Test bearbeiten und korrelieren die Punktwerte, die sich zu den zwei Testzeitpunkten ergeben.</p>
<p>Noch leichter ist die Bestimmung der Split-Half-Reliabilität, welche nicht das mehrmalige Bearbeiten desselben Tests erfordert. Dabei teilen wir die Items des Tests in zwei Gruppen ein und bilden Summenwerte für die beiden Testhälften, welche wir dann miteinander korrelieren. Wir müssen dabei berücksichtigen, dass wir nur die Hälfte des Tests zur Schätzung der Reliabilität verwenden. Dies kann mithilfe der <em>Spearman-Brown-Formel</em> korrigiert werden.</p>
<p>Die Spearman-Brown-Formel schätzt die Reliabilität eines Tests für den hypothetischen Fall, dass man diesen um einen bestimmten Faktor verlängern würde (d.h. man würde die bestehenden Items replizieren). Man kann sie verwenden, um den Reliabilitätsschätzer einer Split-Half-Korrelation zu korrigieren, da in diesen nur die Hälfte der Items eingehen. Die Spearman-Brown Formel ist diese:</p>
<p> </p>
<p><span class="math display">\[r&#39; = \frac{r \, n}{1 + (n - 1) r}\]</span></p>
<p> </p>
<p>Hierbei ist <em>r’</em> die um die Testlänge korrigierte Reliabilität. <em>r</em> ist der derzeitige Reliabilitätsschätzer, also beispielsweise die Korrelation von zwei Testhälften. <em>n</em> ist der Faktor, um den der Test hypothetisch verlängert wird.</p>
<p>Für die Schätzung der Split-Half-Reliabilität muss man einen Verlängerungsfaktor von 2 annehmen, da man die Reliabilität nur mit einem halbierten Test schätzt (im Vergleich dazu geht bei der Bestimmung der Retest-Reliabilität zweimal der gesamte Test in die Korrelation ein). Folgender Code berechnet eine Split-Half-Reliabilität:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Wähle (a) die ersten drei und (b) die letzten zwei Items aus:

first_half  &lt;-<span class="st"> </span><span class="kw">subset</span>(test_data, <span class="dt">select =</span> <span class="kw">paste0</span>(<span class="st">&quot;Item_&quot;</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>))
second_half &lt;-<span class="st"> </span><span class="kw">subset</span>(test_data, <span class="dt">select =</span> <span class="kw">paste0</span>(<span class="st">&quot;Item_&quot;</span>, <span class="dv">4</span><span class="op">:</span><span class="dv">5</span>))

## Berechne die Korrelation zwischen den beiden Testhälften
cor_halfs &lt;-<span class="st"> </span><span class="kw">cor</span>(<span class="kw">rowSums</span>(first_half), <span class="kw">rowSums</span>(second_half))
cor_halfs</code></pre></div>
<pre><code>[1] 0.5091751</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Führe die Spearman-Brown Korrektur durch:

## Hier ist ein erstes Beispiel einer selbst geschriebenen Funktion. Es
## reicht, das Konzept zur Kenntnis zu nehmen -- es wird in Kap. 5
## wieder aufgegriffen:

## SPEARMAN-BROWN Funktion. Nimmt zwei Argumente an: (a) einen
## Reliabilitäts-Schätzer; (b) einen Verlängerungsfaktor

spearman_brown &lt;-<span class="st"> </span><span class="cf">function</span>(reliability, factor) {
    numerator  &lt;-<span class="st"> </span>reliability <span class="op">*</span><span class="st"> </span>factor
    denominator &lt;-<span class="st"> </span><span class="dv">1</span> <span class="op">+</span><span class="st"> </span>(factor<span class="op">-</span><span class="dv">1</span>) <span class="op">*</span><span class="st"> </span>reliability
    corrected_reliability &lt;-<span class="st"> </span>numerator <span class="op">/</span><span class="st"> </span>denominator
    <span class="kw">return</span>(corrected_reliability)
}

## Rufe die selbst geschriebene SPEARMAN-BROWN Funktion auf. Unser
## initialer Schätzer der Reliabilität ist die Korrelation zwischen den
## zwei Testhälften.  Der Verlängerungsfaktor ist 2, da wir die
## Reliabilität für die doppelte Testlänge schätzen wollen:
split_half &lt;-<span class="st"> </span><span class="kw">spearman_brown</span>(cor_halfs, <span class="dv">2</span>)
split_half</code></pre></div>
<pre><code>[1] 0.6747727</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Vergleiche mit Cronbachs Alpha:
<span class="kw">alpha</span>(test_data)</code></pre></div>
<pre><code>[1] 0.753012</code></pre>
<p>Wie wir sehen, liegt die Spearman-Brown-korrigierte Split-Half-Reliabilität näher an Cronbachs Alpha als die unkorrigierte Korrelation der zwei Testhälften. Das liegt daran, dass die Korrelation der zwei Testhälften die Reliabilität systematisch unterschätzt, da dieser Schätzer nur auf der Hälfte der Items beruht. Es ist sogar so, dass Cronbachs Alpha genau der Mittelwert aller möglichen Spearman-Brown korrigierten Split-Half-Koeffizienten ist.</p>
<p>Alternativ hätten wir auch die Odd-Even-Reliabilität berechnen können, die die Testitems in gerade und ungerade Items einteilt, also hier zwei Testscores einerseits für die Items 1, 3 und 5, und andererseits für die Items 2 und 4 berechnet. Diese lässt sich mit nur wenig Änderungen am Code oben umsetzen – ich schlage vor, dies als Übung zu machen.</p>
</div>
</div>
<div id="umgang-mit-echten-daten" class="section level2">
<h2><span class="header-section-number">4.2</span> Umgang mit echten Daten</h2>
<p>Unser Ziel ist die Auswertung echter Daten von Persönlichkeits-Inventaren wie den BIG-5 und dem Narcissistic Personality Inventory. Leider liegen in echten Daten die Werte oftmals nicht in der Form vor, die wir brauchen. In dem vorherigen Beispiel habe ich die Daten selber generiert und konnte deswegen direkt mit der Analyse starten. Echte Daten jedoch enthalten in Rohform unter Umständen gar nicht die Informationen, die ich benötige oder haben fehlende Werte. Deswegen werden wir uns als nächstes mit den folgenden Themen beschäftigen:</p>
<ol style="list-style-type: decimal">
<li>Umkodierung von Antworten</li>
<li>Invertierung von Antworten</li>
<li>Umgang mit fehlenden Werten</li>
</ol>
<div id="umkodierung" class="section level3">
<h3><span class="header-section-number">4.2.1</span> Umkodierung von Variablen</h3>
<p>Eine wichtige Voraussetzung für eine psychometrische Analyse war im Beispiel oben bereits gegeben: Jeder Wert kodierte genau die Information, die wir brauchten – nämlich ob Schüler/innen eine Aufgabe korrekt gelöst haben oder nicht (dargestellt durch <code>1</code> und <code>0</code>). In echten Daten muss die relevante Information jedoch häufig erst noch aus den dokumentierten Werten “abgeleitet” werden. Die Antwort der Schüler/innen im Test könnte beispielsweise ein Kreuz in einem Multiple-Choice-Item sein:</p>
<blockquote>
<p>Aus wie vielen Bundesländern besteht die Bundesrepublik Deutschland?</p>
</blockquote>
<blockquote>
<ol style="list-style-type: decimal">
<li>14</li>
<li>16</li>
<li>19</li>
<li>21</li>
</ol>
</blockquote>
<p>Ob ein Kreuz bei (1), (2), (3) oder (4) gesetzt wird, ist für die Auswertung nicht von Belang. Relevant ist, ob die Frage richtig beantwortet wurde – wir benötigen also die folgende Umkodierung der Daten:</p>
<blockquote>
<p><code>1</code> <span class="math inline">\(\to\)</span> <code>0</code> <code>2</code> <span class="math inline">\(\to\)</span> <code>1</code> <code>3</code> <span class="math inline">\(\to\)</span> <code>0</code> <code>4</code> <span class="math inline">\(\to\)</span> <code>0</code></p>
</blockquote>
<p>In psychometrischem Jargon: Für diese Aufgabe ist der Wert <code>2</code> der <em>Schlüssel</em> (engl.: <em>key</em>). Ein Schlüssel kodiert den Eingabewert der richtigen Antwort.<a href="#fn46" class="footnoteRef" id="fnref46"><sup>46</sup></a> Wir lernen jetzt, wie wir solche Umkodierungen in <code>R</code> umsetzen. Die Stärke einer Programmiersprache wie <code>R</code>: Wenn wir einmal gelernt haben, wie wir für eine Item-Schlüssel-Kombination Daten als richtig und falsch umkodieren, können wir mit nur ein wenig mehr Aufwand diesen Prozess für beliebig viele Items wiederholen. Das <em>Narcissistic Personality Inventory</em> etwa hat 40 Items und wir haben keine Lust, 40 Mal eine Umkodierung “händisch” neu durchzuführen.</p>
<p> </p>
<p><strong>Die Funktion <code>ifelse</code></strong></p>
<p> </p>
<p>Mit der Funktion <code>ifelse</code> lassen sich Transformationen, die anhand eines Schlüssels Korrektheit kodieren, bequem durchführen. Das folgende Beispiel basiert auf dem obigen Multiple-Choice-Item:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Hypothetische Antworten auf das Bundesland Multiple-Choice-Item:</span>
bundesland_answers &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">2</span>)
bundesland_key     &lt;-<span class="st"> </span><span class="dv">2</span>

bundesland_score   &lt;-<span class="st"> </span><span class="kw">ifelse</span>(<span class="dt">test =</span> bundesland_answers <span class="op">==</span><span class="st"> </span>bundesland_key,
                             <span class="dt">yes =</span> <span class="dv">1</span>, <span class="dt">no =</span> <span class="dv">0</span>)
bundesland_score</code></pre></div>
<pre><code>[1] 0 1 0 0 1 0 1</code></pre>
<p>Was ist hier passiert? Ich habe im Vektor <code>bundesland_answers</code> hypothetische Antworten generiert; die Variable <code>bundesland_key</code> enthält den Schlüssel, d.h. die korrekte Antwort. Mithilfe der Funktion <code>ifelse</code> gleiche ich die Antworten mit dem Schlüssel ab. <code>ifelse</code> nimmt drei Argumente entgegen. Diese heißen <code>test</code>, <code>yes</code>, und <code>no</code>:<a href="#fn47" class="footnoteRef" id="fnref47"><sup>47</sup></a></p>
<ul>
<li><code>test</code>: Vergleicht jede Antwort mit dem Schlüssel, hier: <code>bundesland_answers == bundesland_key</code>. Ergebnis dieses Vergleichs ist der folgende logische Vektor (im Allgemeinen kann <code>test</code> einen beliebigen logischen Vektor als Argument annehmen):</li>
</ul>
<pre><code>[1] FALSE  TRUE FALSE FALSE  TRUE FALSE  TRUE</code></pre>
<ul>
<li><code>yes</code>: Der Wert, der angenommen werden soll für Elemente, für die der <code>test</code> <code>TRUE</code> ergab (hier: <code>1</code>)</li>
<li><code>no</code>: Der Wert, der angenommen werden soll für Elemente, für die der <code>test</code> <code>FALSE</code> ergab (hier: <code>0</code>)
<ul>
<li>praktisch: ich muss nicht angeben, welche falschen Werte alle möglich sind; es reicht aus, den richtigen Wert anzugeben, alle anderen sind automatisch falsch</li>
</ul></li>
</ul>
<p>Nach der Umkodierung können wir beispielsweise die Schwierigkeit des Bundesland-Items mit der <code>mean</code> Funktion berechnen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mean</span>(bundesland_score)</code></pre></div>
<pre><code>[1] 0.4285714</code></pre>
<p>In diesem Fall hätten 43% der Testteilnehmer das Bundesland-Item korrekt beantwortet. Diese Information konnten wir aus den ursprünglichen Antwortkategorien 1, 2, 3 und 4 nicht herleiten.</p>
<p><code>ifelse</code> ist eine sehr nützliche Funktion, mit der wir Antworten umkodieren können. Später lernen wir, wie wir mithilfe von <code>ifelse</code> ganze Tests und nicht nur einzelne Items bepunkten können. Bevor wir das jedoch effizient machen können, werden wir im nächsten Kapitel noch ein paar Grundlagen zur Programmierung mit <code>R</code> lernen.</p>
</div>
<div id="invertierung-von-antworten" class="section level3">
<h3><span class="header-section-number">4.2.2</span> Invertierung von Antworten</h3>
<p>Eine mögliche Umkodierung von Antworten ist das Abgleichen mit einem Schlüssel, etwa zur Feststellung der Korrektheit von Antworten. Eine weitere häufig auftretende Variante ist die <em>Invertierung</em> von Antworten. Betrachten wir folgende zwei Items, die in einer Big-5 Kurzskala den Aspekt Extraversion messen:</p>
<blockquote>
<ol style="list-style-type: decimal">
<li>Ich bin eher zurückhaltend, reserviert.</li>
<li>Ich gehe aus mir heraus, bin gesellig.</li>
</ol>
</blockquote>
<p>Beide Items werden auf einer Likertskala mit fünf Abstufungen gemessen, das heißt es werden Punktzahlen von 1 bis 5 vergeben. Das Problem ist, dass in Item 1 ein hoher Punktwert für wenig Extraversion steht, in Item 2 ein hoher Punktwert hingegen für eine hohe Ausprägung in Extraversion. Generell wollen wir einen <em>Summenwert</em> berechnen, also einen Wert, der die Extraversion eines jeden Testteilnehmers kodiert – und zwar über beide Items hinweg. Im vorliegenden Fall macht es aber keinen Sinn, die Punktzahlen beider Items zu addieren. Die höchste Ausprägung in Extraversion würde sich dann ergeben, wenn ein Item extravertiert beantwortet wird, aber das andere introvertiert. Damit die Punktzahlen in beiden Items “in dieselbe Richtung” zu verstehen sind, wollen wir die Antworten auf Item 1 <em>invertieren</em>, sodass auch hier eine hohe Punktzahl für eine hohe Merkmalsausprägung in Extraversion steht. Das heißt, wir wollen die folgende Abbildung durchführen:</p>
<blockquote>
<p><code>1</code> <span class="math inline">\(\to\)</span> <code>5</code> <code>2</code> <span class="math inline">\(\to\)</span> <code>4</code> <code>3</code> <span class="math inline">\(\to\)</span> <code>3</code> <code>4</code> <span class="math inline">\(\to\)</span> <code>2</code> <code>5</code> <span class="math inline">\(\to\)</span> <code>1</code></p>
</blockquote>
<p>Wir könnten dies mit mehrfacher Anwendung von <code>ifelse</code> hinbekommen, was jedoch mühsam wäre. Es gibt eine mathematische Umformung, welche wir auch mit nur wenig Code umsetzen können:</p>
<blockquote>
<p>Invertierter Wert = Ursprungswert * (-1) + Höchster Skalenwert + 1</p>
</blockquote>
<p>Diese funktioniert, wenn unsere Punktzahlen zwischen 1 und dem höchstmöglichen Skalenwert liegen. Probieren wir es mit ein paar hypothetischen Antworten aus:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">big5 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">item1 =</span> <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">5</span>),
                   <span class="dt">item2 =</span> <span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">3</span>, <span class="dv">2</span>))

## Betrachte den data.frame:
big5</code></pre></div>
<pre><code>  item1 item2
1     2     5
2     3     3
3     2     3
4     1     4
5     4     3
6     2     5
7     1     3
8     5     2</code></pre>
<p>Wir können uns mit der <code>cor</code> Funktion die Korrelation zwischen den zwei Items ausgeben lassen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">round</span>(<span class="kw">cor</span>(big5), <span class="dv">2</span>)</code></pre></div>
<pre><code>      item1 item2
item1  1.00 -0.57
item2 -0.57  1.00</code></pre>
<p>Ich habe die Antwortwerte absichtlich so gewählt, dass sich hier ein typisches Muster ergibt: Antworten auf unterschiedlich gepolte Items – die zur selbem Skala gehören – korrelieren typischerweise negativ miteinander. Das heißt: Hohe Antwortwerte im einen Item gehen tendenziell mit niedrigen Werten im anderen Item einher – wenn die unterschiedlich gepolten Items dasselbe Konstrukt erfassen. Durch die Invertierung erhalten wir Daten, die positiv miteinander korrelieren. Folgender Code führt die Invertierung durch:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 5 ist der höchst-mögliche Skalenwert</span>
big5<span class="op">$</span>item1_inv &lt;-<span class="st"> </span>big5<span class="op">$</span>item1 <span class="op">*</span><span class="st"> </span>(<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span><span class="st"> </span><span class="dv">6</span></code></pre></div>
<p>Schauen wir uns die Daten an, um zu prüfen, ob die Transformation funktioniert hat:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">subset</span>(big5, <span class="dt">select =</span> <span class="kw">c</span>(<span class="st">&quot;item1&quot;</span>, <span class="st">&quot;item1_inv&quot;</span>))</code></pre></div>
<pre><code>  item1 item1_inv
1     2         4
2     3         3
3     2         4
4     1         5
5     4         2
6     2         4
7     1         5
8     5         1</code></pre>
<p>Das hat geklappt! Schauen wir uns nun auch noch einmal die Inter-Itemkorrelationen an:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">round</span>(<span class="kw">cor</span>(big5), <span class="dv">2</span>)</code></pre></div>
<pre><code>          item1 item2 item1_inv
item1      1.00 -0.57     -1.00
item2     -0.57  1.00      0.57
item1_inv -1.00  0.57      1.00</code></pre>
<p>Wie wir sehen, korrelieren die Spalten <code>item2</code> und <code>item1_inv</code> genau wie <code>item2</code> und <code>item1</code> – nur mit positivem Vorzeichen. Ebenfalls interessant: <code>item1</code> und <code>item1_inv</code> korrelieren perfekt negativ – und das ist genau das, was wir mit der Invertierung erreichen wollten: Einen Punktwert errechnen, der genau in die entgegengesetzte Richtung zu interpretieren ist wie der ursprüngliche Wert.</p>
</div>
<div id="umgang-mit-fehlenden-werten" class="section level3">
<h3><span class="header-section-number">4.2.3</span> Umgang mit fehlenden Werten</h3>
<blockquote>
<p>Real data have missing values. Missing values are an integral part of the R language. Many functions have arguments that control how missing values are to be handled. – Patrick Burns<a href="#fn48" class="footnoteRef" id="fnref48"><sup>48</sup></a></p>
</blockquote>
<p>Wir lernen nun den rudimentären Umgang mit fehlenden Werten in <code>R</code> kennen. Dabei könnte man vermutlich beliebig sophistiziert vorgehen, jedoch werden wir nur einen basalen und wichtigen Spezialfall kennenlernen:</p>
<ol style="list-style-type: decimal">
<li>Wir wandeln alle Werte in <code>NA</code> um, die als fehlend zu klassifizieren sind</li>
<li>Danach schließen wir alle Fälle mit fehlenden Werten aus</li>
</ol>
<p>Für dieses Beispiel laden wir Daten des Narcissistic Personality Inventory <span class="citation">(NPI; Raskin and Terry 1988)</span> ein. Die Daten von mehr als 11,000 Bearbeitungen des NPI sind erfreulicherweise über das “Open Source Psychometrics Project” unter <a href="https://openpsychometrics.org/_rawdata" class="uri">https://openpsychometrics.org/_rawdata</a> abrufbar. Wenn wir die Daten heruntergeladen haben und die Datei “data.csv” in unserem RStudio-Projektordner liegt (siehe <a href="anhang.html#datenEinlesen">Anhang</a>), können wir den Datensatz wie folgt einlesen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Lese Daten ein
npi &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;data.csv&quot;</span>)</code></pre></div>
<p>Wie folgt verschaffen wir uns einen Überblick über die Daten:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">nrow</span>(npi) <span class="co"># Wie viele Fälle</span></code></pre></div>
<pre><code>[1] 11243</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ncol</span>(npi) <span class="co"># Wie viele Spalten</span></code></pre></div>
<pre><code>[1] 44</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(npi) <span class="co"># wie heißen die Messvariablen</span></code></pre></div>
<pre><code> [1] &quot;score&quot;  &quot;Q1&quot;     &quot;Q2&quot;     &quot;Q3&quot;     &quot;Q4&quot;     &quot;Q5&quot;     &quot;Q6&quot;    
 [8] &quot;Q7&quot;     &quot;Q8&quot;     &quot;Q9&quot;     &quot;Q10&quot;    &quot;Q11&quot;    &quot;Q12&quot;    &quot;Q13&quot;   
[15] &quot;Q14&quot;    &quot;Q15&quot;    &quot;Q16&quot;    &quot;Q17&quot;    &quot;Q18&quot;    &quot;Q19&quot;    &quot;Q20&quot;   
[22] &quot;Q21&quot;    &quot;Q22&quot;    &quot;Q23&quot;    &quot;Q24&quot;    &quot;Q25&quot;    &quot;Q26&quot;    &quot;Q27&quot;   
[29] &quot;Q28&quot;    &quot;Q29&quot;    &quot;Q30&quot;    &quot;Q31&quot;    &quot;Q32&quot;    &quot;Q33&quot;    &quot;Q34&quot;   
[36] &quot;Q35&quot;    &quot;Q36&quot;    &quot;Q37&quot;    &quot;Q38&quot;    &quot;Q39&quot;    &quot;Q40&quot;    &quot;elapse&quot;
[43] &quot;gender&quot; &quot;age&quot;   </code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(npi, <span class="dt">n =</span> <span class="dv">3</span>) <span class="co"># Wie sehen die Daten aus</span></code></pre></div>
<pre><code>  score Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9 Q10 Q11 Q12 Q13 Q14 Q15 Q16 Q17 Q18 Q19
1    18  2  2  2  2  1  2  1  2  2   2   1   1   2   1   1   1   2   1   1
2     6  2  2  2  1  2  2  1  2  1   1   2   2   2   1   2   2   1   1   2
3    27  1  2  2  1  2  1  2  1  2   2   2   1   1   1   1   1   2   2   1
  Q20 Q21 Q22 Q23 Q24 Q25 Q26 Q27 Q28 Q29 Q30 Q31 Q32 Q33 Q34 Q35 Q36 Q37
1   1   1   1   1   2   2   2   1   2   2   2   1   2   1   1   1   2   2
2   1   2   2   1   2   2   2   2   1   2   2   2   1   2   2   1   2   2
3   1   2   2   2   2   1   2   1   1   2   1   2   2   1   1   2   1   1
  Q38 Q39 Q40 elapse gender age
1   2   1   2    211      1  50
2   2   2   1    149      1  40
3   2   1   2    168      1  28</code></pre>
<p>Wir bemerken, dass keine Variable als “Fallnummer” fungiert. Generell ist es <strong>immer</strong> wichtig, dass jeder Datensatz durch eine eindeutige Fallnummer zu identifizieren ist. Da eine solche in den eingelesenen Daten jedoch nicht enthalten ist, fügen wir selber eine Fallnummer hinzu:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">npi<span class="op">$</span>casenum &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(npi)</code></pre></div>
<p>Eine weitere nützliche Funktion zum Betrachten von <code>data.frames</code> ist die Funktion <code>summary</code>, die uns einen schnellen Überblick über die Werte in allen Spalten des <code>data.frames</code> bietet:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(npi)</code></pre></div>
<p>Die Funktion <code>summary</code> ergibt für jede Spalte eine Tabelle. Wegen der Länge des Outputs von <code>summary(npi)</code> ist nicht der gesamte Output im Skript abgebildet.<a href="#fn49" class="footnoteRef" id="fnref49"><sup>49</sup></a> Für die Variable <code>score</code> erhalten wir folgende Informationen zum Narzissmus-Gesamtscore:</p>
<p> </p>
<p> </p>
<table>
<thead>
<tr class="header">
<th align="left">score</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Min. : 0.0</td>
</tr>
<tr class="even">
<td align="left">1st Qu.: 7.0</td>
</tr>
<tr class="odd">
<td align="left">Median :12.0</td>
</tr>
<tr class="even">
<td align="left">Mean :13.3</td>
</tr>
<tr class="odd">
<td align="left">3rd Qu.:18.0</td>
</tr>
<tr class="even">
<td align="left">Max. :40.0</td>
</tr>
</tbody>
</table>
<p> </p>
<p> </p>
<p><strong>Identifikation von fehlenden Werten im NPI Datensatz</strong></p>
<p> </p>
<p>Das NPI besteht aus 40 Items. Aus dem <em>Codebuch</em> des NPI Datensatzes<a href="#fn50" class="footnoteRef" id="fnref50"><sup>50</sup></a> wissen wir, dass Antworten auf die NPI Items die Werte 1 und 2 annehmen können. Die Antwort auf jedes Item des NPI besteht aus einer “forced choice” zwischen zwei Aussagen; eine davon steht für Narzissmus. Item 1 besteht beispielsweise aus den folgenden beiden Aussagen:</p>
<blockquote>
<ol style="list-style-type: decimal">
<li>I have a natural talent for influencing people.</li>
<li>I am not good at influencing people.</li>
</ol>
</blockquote>
<p>Die Wahl von Aussage 1 wird mit 1 kodiert, die Wahl von Aussage 2 mit 2. Nachgeschaltet wird folgende Umkodierung vorgenommen, die die Item-Scores berechnet: Wird die “narzisstische Aussage” ausgewählt (hier Aussage 1: “I have a natural talent for influencing people.”), wird das Item mit 1 bepunktet. Wird die Aussage gewählt, die nicht für Narzissmus steht (hier Aussage 2: “I am not good at influencing people.”), wird eine 0 vergeben. Wie wir zu Beginn des Abschnitts gelernt haben, könnten wir Item 1 deswegen wie folgt bepunkten:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">npi<span class="op">$</span>Q1_score &lt;-<span class="st"> </span><span class="kw">ifelse</span>(npi<span class="op">$</span>Q1 <span class="op">==</span><span class="st"> </span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>)</code></pre></div>
<p><strong>Aber Vorsicht: so würden wir einen Fehler machen</strong>! Die Spalte <code>npi$Q1</code> enthält nicht nur die Werte 1 und 2, sondern auch 0-Werte, wie wir mit dem Befehl <code>table(npi$Q1)</code> prüfen können:<a href="#fn51" class="footnoteRef" id="fnref51"><sup>51</sup></a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(npi<span class="op">$</span>Q1)</code></pre></div>
<pre><code>
   0    1    2 
  17 6872 4354 </code></pre>
<p>Wie wir sehen, wurden die Antwortkategorien 0, 1 und 2 vergeben. Es kommt sogar 17 Mal die Antwortkategorie 0 vor – <strong>obwohl Antworten nur die Werte 1 und 2 annehmen dürfen</strong>. Wie kommt das? Die Antwort ist: Bei der Bearbeitung des NPI-Fragebogens – welche im Rahmen einer Online-Studie stattfand – konnten Teilnehmer/innen Items unbeantwortet lassen. Fehlende Werte in den Antworten wurden mit einer 0 kodiert.<a href="#fn52" class="footnoteRef" id="fnref52"><sup>52</sup></a></p>
<p> </p>
<p><strong>Ausschluss von Fällen mit fehlenden Werten</strong></p>
<p> </p>
<p>Wir wollen als nächstes alle Fälle ausschließen, bei denen mindestens ein fehlender Wert in den Antworten auf die 40 NPI Items vorliegt, d.h. für mindestens eine der Spalten <code>npi$Q1</code>, …, <code>npi$Q40</code> der Wert 0 ist. Erst danach können wir die Itemscores berechnen.</p>
<p>Zu diesem Zweck speichern wir zunächst die Antworten auf die 40 Items und die Fallnummer in einem neuen <code>data.frame</code> ab. Anhand dieses <code>data.frames</code> werden wir die Fallausschlüsse durchführen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">item_responses &lt;-<span class="st"> </span><span class="kw">subset</span>(npi, <span class="dt">select =</span> <span class="kw">c</span>(<span class="st">&quot;casenum&quot;</span>, <span class="kw">paste0</span>(<span class="st">&quot;Q&quot;</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">40</span>)))</code></pre></div>
<p>Wir können jetzt 0-Werte in <code>NA</code> umkodieren, indem wir ein Vorgehen verwenden, das wir in <a href="vektoren.html#vektorAendern">Kapitel 2</a> für Vektoren kennengelernt haben. Dieses Vorgehen funktioniert bei <code>data.frames</code> tatsächlich genauso:<a href="#fn53" class="footnoteRef" id="fnref53"><sup>53</sup></a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">item_responses[item_responses <span class="op">==</span><span class="st"> </span><span class="dv">0</span>] &lt;-<span class="st"> </span><span class="ot">NA</span></code></pre></div>
<p>Für einzelne Spalten kann man mithilfe der Funktion <code>is.na</code> überprüfen, ob diese fehlende Werte enthalten. <code>is.na</code> ergibt einen logischen Vektor, der kodiert, ob jedes Element des übergebenen Vektors – also etwa eine Spalte, die wir mit der <code>$</code>-Notation ausgelesen haben – <code>NA</code> ist. Mit diesem Wissen können wir etwa für einzelne Items überprüfen, wie viele Personen keine Antwort angegeben haben:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sum</span>(<span class="kw">is.na</span>(item_responses<span class="op">$</span>Q1))</code></pre></div>
<pre><code>[1] 17</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sum</span>(<span class="kw">is.na</span>(item_responses<span class="op">$</span>Q40))</code></pre></div>
<pre><code>[1] 34</code></pre>
<p><strong>Wichtig</strong>: Man <strong>muss</strong> <code>is.na</code> verwenden, um zu prüfen, ob Werte <code>NA</code> sind; Folgendes geht schief:<a href="#fn54" class="footnoteRef" id="fnref54"><sup>54</sup></a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Nutze head, um nicht alle 11,000 Vergleiche auszugeben
<span class="kw">head</span>(item_responses<span class="op">$</span>Q1 <span class="op">==</span><span class="st"> </span><span class="ot">NA</span>)</code></pre></div>
<pre><code>[1] NA NA NA NA NA NA</code></pre>
<p>Um insgesamt einen Überblick über die Verteilung der fehlenden Fälle zu erhalten, bietet sich eine erneute Anwendung der Funktion <code>summary</code> an. Diese gibt nämlich direkt für jede Spalte eines <code>data.frames</code> die Zahl der fehlenden Fälle an. Folgende Information gibt es zum ersten Item:</p>
<p> </p>
<table>
<thead>
<tr class="header">
<th align="left">Q1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Min. :1.000</td>
</tr>
<tr class="even">
<td align="left">1st Qu.:1.000</td>
</tr>
<tr class="odd">
<td align="left">Median :1.000</td>
</tr>
<tr class="even">
<td align="left">Mean :1.388</td>
</tr>
<tr class="odd">
<td align="left">3rd Qu.:2.000</td>
</tr>
<tr class="even">
<td align="left">Max. :2.000</td>
</tr>
<tr class="odd">
<td align="left">NA’s :17</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Jetzt, da wir fehlende Antworten per <code>NA</code> als fehlend gekennzeichnet haben, gibt es verschiedene Möglichkeiten, die zugehörigen Fälle auszuschließen. Eine Möglichkeit wäre eine Aneinanderreihung von vielen ODER-Verknüpfungen, an die wir eine Auswahl mit <code>subset</code> anschließen. Dies könnte wie folgt funktionieren:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Identifiziere Fälle, die in irgendeinem Item einen
## fehlenden Wert haben (hier nur exemplarisch, kein
## legaler R-Code, da Items 4 bis 39 nicht ausgeschrieben
## sind):
irgendwo_na &lt;-<span class="st"> </span><span class="kw">is.na</span>(item_responses<span class="op">$</span>Q1) <span class="op">|</span>
<span class="st">    </span><span class="kw">is.na</span>(item_responses<span class="op">$</span>Q2) <span class="op">|</span>
<span class="st">    </span><span class="kw">is.na</span>(item_responses<span class="op">$</span>Q3) <span class="op">|</span>
<span class="st">    </span>... <span class="op">|</span>
<span class="st">    </span><span class="kw">is.na</span>(item_responses<span class="op">$</span>Q40)

## Negation durchführen, um die Fälle zu erwischen, die
## *keinen* fehlenden Wert enthalten
nirgendwo_na &lt;-<span class="st"> </span><span class="op">!</span>irgendwo_na

## Wähle diese Fälle aus:
item_responses &lt;-<span class="st"> </span><span class="kw">subset</span>(item_responses, nirgendwo_na)</code></pre></div>
<p>Durch die Verknüpfung der ODER-Operatoren werden alle Fälle identifiziert, die mindestens eine fehlende Antwort enthalten. Diese Aneinanderreihung ist jedoch mühselig und fehleranfällig. Diese Arbeit wollen wir uns nicht machen.</p>
<p>Eine weitere Methode, fehlende Werte zu identifizieren nutzt aus, dass die Funktion <code>rowSums</code><a href="#fn55" class="footnoteRef" id="fnref55"><sup>55</sup></a> <code>NA</code> ausgibt, wenn mindestens ein Wert aus einer Zeile <code>NA</code> enthält – zumindest wenn wir nicht das optionale Argument <code>na.rm</code> auf <code>TRUE</code> setzen. Dies ist analog zu der Funktion <code>sum</code>, die für einen einzelnen Vektor eine Summe bestimmt. Die Funktion <code>sum</code> gibt ebenfalls <code>NA</code> aus, wenn mindestens ein Element des übergebenen Vektors <code>NA</code> ist und <code>na.rm</code> nicht auf <code>TRUE</code> gesetzt wurde. Die Funktion <code>rowSums</code> erweitert also auch im Hinblick auf den Umgang mit fehlenden Werten das Verhalten von <code>sum</code> auf alle Zeilen eines <code>data.frames</code>. Aus diesem Grund funktioniert das hier:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Identifiziere Fälle, die in irgendeinem Item einen
## fehlenden Wert haben:
irgendwo_na &lt;-<span class="st"> </span><span class="kw">is.na</span>(<span class="kw">rowSums</span>(item_responses))</code></pre></div>
<p>Am bequemsten ist es jedoch, wenn wir die Funktion <code>na.omit</code> nutzen, die uns einfach so alle Fälle ausschließt, die fehlende Werte enthalten:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">item_responses &lt;-<span class="st"> </span><span class="kw">na.omit</span>(item_responses)</code></pre></div>
<p>Die Funktion <code>na.omit</code> gibt einen <code>data.frame</code> aus, der keine der Zeilen enthält, in denen mindestens ein <code>NA</code>-Wert vorlag. So müssen wir nicht selber die Zeilen identifizieren, die fehlende Werte enthalten.</p>
<p>Vergleichen wir nun den ursprünglichen <code>data.frame</code> <code>npi</code> mit der “bereinigten” Tabelle:<a href="#fn56" class="footnoteRef" id="fnref56"><sup>56</sup></a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">nrow</span>(npi)</code></pre></div>
<pre><code>[1] 11243</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">nrow</span>(item_responses)</code></pre></div>
<pre><code>[1] 10440</code></pre>
<p>Wie wir sehen, haben wir 803 Fälle wegen fehlender Werte ausgeschlossen. Etwas unschön ist, dass in unseren bereinigten Daten einige Variablen – wie das Geschlecht und das Alter – fehlen. Das liegt daran, dass wir für den Ausschluss von Fällen nur die Item-Antworten berücksichtigt haben, die wir zuvor im <code>data.frame</code> <code>item_responses</code> abgespeichert haben. Vergleichen wir:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(npi)</code></pre></div>
<pre><code> [1] &quot;score&quot;   &quot;Q1&quot;      &quot;Q2&quot;      &quot;Q3&quot;      &quot;Q4&quot;      &quot;Q5&quot;      &quot;Q6&quot;     
 [8] &quot;Q7&quot;      &quot;Q8&quot;      &quot;Q9&quot;      &quot;Q10&quot;     &quot;Q11&quot;     &quot;Q12&quot;     &quot;Q13&quot;    
[15] &quot;Q14&quot;     &quot;Q15&quot;     &quot;Q16&quot;     &quot;Q17&quot;     &quot;Q18&quot;     &quot;Q19&quot;     &quot;Q20&quot;    
[22] &quot;Q21&quot;     &quot;Q22&quot;     &quot;Q23&quot;     &quot;Q24&quot;     &quot;Q25&quot;     &quot;Q26&quot;     &quot;Q27&quot;    
[29] &quot;Q28&quot;     &quot;Q29&quot;     &quot;Q30&quot;     &quot;Q31&quot;     &quot;Q32&quot;     &quot;Q33&quot;     &quot;Q34&quot;    
[36] &quot;Q35&quot;     &quot;Q36&quot;     &quot;Q37&quot;     &quot;Q38&quot;     &quot;Q39&quot;     &quot;Q40&quot;     &quot;elapse&quot; 
[43] &quot;gender&quot;  &quot;age&quot;     &quot;casenum&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(item_responses)</code></pre></div>
<pre><code> [1] &quot;casenum&quot; &quot;Q1&quot;      &quot;Q2&quot;      &quot;Q3&quot;      &quot;Q4&quot;      &quot;Q5&quot;      &quot;Q6&quot;     
 [8] &quot;Q7&quot;      &quot;Q8&quot;      &quot;Q9&quot;      &quot;Q10&quot;     &quot;Q11&quot;     &quot;Q12&quot;     &quot;Q13&quot;    
[15] &quot;Q14&quot;     &quot;Q15&quot;     &quot;Q16&quot;     &quot;Q17&quot;     &quot;Q18&quot;     &quot;Q19&quot;     &quot;Q20&quot;    
[22] &quot;Q21&quot;     &quot;Q22&quot;     &quot;Q23&quot;     &quot;Q24&quot;     &quot;Q25&quot;     &quot;Q26&quot;     &quot;Q27&quot;    
[29] &quot;Q28&quot;     &quot;Q29&quot;     &quot;Q30&quot;     &quot;Q31&quot;     &quot;Q32&quot;     &quot;Q33&quot;     &quot;Q34&quot;    
[36] &quot;Q35&quot;     &quot;Q36&quot;     &quot;Q37&quot;     &quot;Q38&quot;     &quot;Q39&quot;     &quot;Q40&quot;    </code></pre>
<p>Um einen <code>data.frame</code> zu erhalten, in dem alle Informationen zu den vollständigen Fällen enthalten sind, machen wir uns zunutze, dass die relevanten Informationen noch im Urspungs-<code>data.frame</code> <code>npi</code> abgespeichert sind. Wie folgt können wir mit der Funktion <code>merge</code> die ursprüngliche Tabelle <code>npi</code> mit der um fehlende Fälle bereinigten Tabelle <code>item_responses</code> zusammenführen.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">npi_clean &lt;-<span class="st"> </span><span class="kw">merge</span>(npi, item_responses)</code></pre></div>
<p>Wir erhalten in der Variablen <code>npi_clean</code> einen Datensatz, der nur Fälle mit vollständigen Antworten enthält – und für diese Fälle auch alle Werte abspeichert. Prüfe:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">nrow</span>(npi_clean)</code></pre></div>
<pre><code>[1] 10440</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(npi_clean)</code></pre></div>
<pre><code> [1] &quot;Q1&quot;      &quot;Q2&quot;      &quot;Q3&quot;      &quot;Q4&quot;      &quot;Q5&quot;      &quot;Q6&quot;      &quot;Q7&quot;     
 [8] &quot;Q8&quot;      &quot;Q9&quot;      &quot;Q10&quot;     &quot;Q11&quot;     &quot;Q12&quot;     &quot;Q13&quot;     &quot;Q14&quot;    
[15] &quot;Q15&quot;     &quot;Q16&quot;     &quot;Q17&quot;     &quot;Q18&quot;     &quot;Q19&quot;     &quot;Q20&quot;     &quot;Q21&quot;    
[22] &quot;Q22&quot;     &quot;Q23&quot;     &quot;Q24&quot;     &quot;Q25&quot;     &quot;Q26&quot;     &quot;Q27&quot;     &quot;Q28&quot;    
[29] &quot;Q29&quot;     &quot;Q30&quot;     &quot;Q31&quot;     &quot;Q32&quot;     &quot;Q33&quot;     &quot;Q34&quot;     &quot;Q35&quot;    
[36] &quot;Q36&quot;     &quot;Q37&quot;     &quot;Q38&quot;     &quot;Q39&quot;     &quot;Q40&quot;     &quot;casenum&quot; &quot;score&quot;  
[43] &quot;elapse&quot;  &quot;gender&quot;  &quot;age&quot;    </code></pre>
<p>Die Funktionsweise der Funktion <code>merge</code> soll hier nicht tiefergehend betrachtet werden. Es reicht zu wissen, dass sie Fälle aus zwei <code>data.frames</code> anhand ihrer Werte zuordnet.<a href="#fn57" class="footnoteRef" id="fnref57"><sup>57</sup></a> Dabei werden Fälle weggelassen, die keinen “Partner” haben – also hier Fälle, zu denen nur in einer Tabelle eine Fallnummer vorliegt. Die Fälle ohne Partner sind hierbei genau die Fälle, die aus <code>npi_clean</code> wegen fehlender Werte ausgeschlossen wurden.</p>
<p>Die Anwendung der Funktion <code>merge</code> hat die Reihenfolge unserer Daten durcheinander gebracht. Es ist nicht so wichtig, warum das so ist, aber wir wollen diesen Nebeneffekt wieder rückgängig machen. Deswegen nutzen wir die Funktion <code>arrange</code> aus dem Paket <code>dplyr</code>, um die Daten wieder anhand der Fallnummer zu sortieren:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">&quot;dplyr&quot;</span>) <span class="co"># falls noch nicht geladen</span>
npi_clean &lt;-<span class="st"> </span><span class="kw">arrange</span>(npi_clean, casenum)</code></pre></div>
<p>Voilá – <code>npi_clean</code> ist der Datensatz, mit dem wir nun psychometrische Berechnungen durchführen können.<a href="#fn58" class="footnoteRef" id="fnref58"><sup>58</sup></a> Dabei ist unser nächstes Ziel für alle 40 Items eine dichotome Bepunktung durchzuführen. Wir wissen bereits, wie wir das machen könnten, nämlich indem wir mit <code>ifelse</code> die Antworten auf jedes Item mit dem Schlüssel abgleichen. Der Schlüssel für den das NPI kodiert für jedes der 40 Items den Wert, der für Narzissmus steht. Dies wäre wie folgt möglich:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Hier kein legaler R-Code, nur exemplarisch:</span>
npi_key &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, ..., <span class="dv">2</span>) <span class="co"># 40 Schlüsselemente</span>

npi<span class="op">$</span>Q1_score &lt;-<span class="st"> </span><span class="kw">ifelse</span>(npi<span class="op">$</span>Q1 <span class="op">==</span><span class="st"> </span>npi_key[<span class="dv">1</span>], <span class="dv">1</span>, <span class="dv">0</span>)
npi<span class="op">$</span>Q2_score &lt;-<span class="st"> </span><span class="kw">ifelse</span>(npi<span class="op">$</span>Q2 <span class="op">==</span><span class="st"> </span>npi_key[<span class="dv">2</span>], <span class="dv">1</span>, <span class="dv">0</span>)

...
...
...

npi<span class="op">$</span>Q40_score &lt;-<span class="st"> </span><span class="kw">ifelse</span>(npi<span class="op">$</span>Q40 <span class="op">==</span><span class="st"> </span>npi_key[<span class="dv">40</span>], <span class="dv">1</span>, <span class="dv">0</span>)</code></pre></div>
<p>Da wir nicht denselben Code – mit leichten Abwandlungen – 40 Mal wiederholen wollen, werden wir in Kapitel 6 lernen, diese Umkodierungen effizient durchzuführen. Anschließend werden wir die psychometrischen Eigenschaften des NPI untersuchen.</p>
</div>
</div>
<div id="zusammenfassung-2" class="section level2">
<h2><span class="header-section-number">4.3</span> Zusammenfassung</h2>
<ul>
<li>Wir haben das Standard-Datenformat der psychometrischen Datenauswertung kennengelernt: Zeilen repräsentieren Fälle, Spalten repräsentieren Items</li>
<li>Wir haben einige grundlegende psychometrische Berechnungen durchgeführt</li>
<li>Wir haben gelernt, wie wir Antworten umkodieren und invertieren können</li>
<li>Wir haben gelernt, wie wir Fälle mit fehlenden Werten identifizieren und aus <code>data.frames</code> ausschließen können</li>
</ul>
</div>
<div id="fragen-zum-vertiefenden-verstandnis-2" class="section level2">
<h2><span class="header-section-number">4.4</span> Fragen zum vertiefenden Verständnis</h2>
<ol style="list-style-type: decimal">
<li><p>Gegeben ist der Antwortvektor <code>c(1, 2, 2, 1, 4, 5, 2, 2, 2, 3)</code> und der Schlüssel <code>2</code>. Wie kann ich die Item-Schwierigkeit ohne Anwendung der Funktion <code>ifelse()</code> bestimmen? Was ist die Item-Schwierigkeit?</p></li>
<li><p>Gegeben ist der Antwortvektor <code>c(2, 3, 2, 4, 5, 6, 2, 3)</code>, der die Antworten auf das Item eines Persönlichkeitsinventars enthält. Die Antworten wurden auf einer Likertskala gegeben, die zwischen 1 und 6 kodiert war. Da das Item negativ gepolt ist, müssen die Antworten vor der Analyse invertiert werden. Was ist der Mittelwert der umgepolten Antworten (d.h. die Item-Schwierigkeit)?</p></li>
</ol>
</div>
</div>
<div class="footnotes">
<hr />
<ol start="39">
<li id="fn39"><p>Auch bei Items, die nicht Korrektheit kodieren, kann man von Item-Schwierigkeit sprechen. Beispielsweise wäre dann die Item-Schwierigkeit die mittlere Zustimmungsrate für ein Item in einem Persönlichkeitsinventar, in dem Antworten auf einer 5-stufigen Likert-Skala gegeben werden.<a href="psychometrie.html#fnref39">↩</a></p></li>
<li id="fn40"><p>In dem Fall könnte man mit <code>subset</code> nur die gewünschten Spalten auswählen.<a href="psychometrie.html#fnref40">↩</a></p></li>
<li id="fn41"><p>Praktisch gesehen werden unkorrigierte und korrigierte Trennschärfe dieselbe relative Rangreihe zwischen den Items hinsichtlich ihrer Diskriminationsgüte abbilden.<a href="psychometrie.html#fnref41">↩</a></p></li>
<li id="fn42"><p>Das wäre sogar eine gute Übung. Die Formel findet sich unter <a href="https://de.wikipedia.org/wiki/Cronbachs_Alpha" class="uri">https://de.wikipedia.org/wiki/Cronbachs_Alpha</a><a href="psychometrie.html#fnref42">↩</a></p></li>
<li id="fn43"><p>Die Erweiterbarkeit mit Paketen ist eine der großen Stärken von <code>R</code>.<a href="psychometrie.html#fnref43">↩</a></p></li>
<li id="fn44"><p>Wir haben gelernt, dass wir Variablen mit der Funktion <code>rm</code> löschen können. <code>rm</code> können wir aber nicht nutzen, wenn wir Spalten aus <code>data.frames</code> entfernen wollen. Das liegt daran, dass die Spalte selber keine Variable ist, sondern zu einem <code>data.frame</code> gehört. Deswegen muss man Spalten mit dem Befehl <code>data.frame$spalte &lt;- NULL</code> entfernen. <code>NULL</code> ist in <code>R</code> ein Wert, der für “Nicht-Existenz” steht.<a href="psychometrie.html#fnref44">↩</a></p></li>
<li id="fn45"><p>Eigentlich sprechen wir von der Reliabilität von Testpunkten und nicht von der Reliabilität von Tests.<a href="psychometrie.html#fnref45">↩</a></p></li>
<li id="fn46"><p>Im Allgemeinen muss ein Schlüssel nicht Korrektheit anzeigen, sondern kann auch Merkmalsausprägung in einem Persönlichkeitsinventar kodieren. Wir werden das im Narcissistic Personality Inventory kennenlernen.<a href="psychometrie.html#fnref46">↩</a></p></li>
<li id="fn47"><p>Wie wir gesehen haben, können wir Argumente in Funktionen per Name und per Position ansteuern.<a href="psychometrie.html#fnref47">↩</a></p></li>
<li id="fn48"><p><a href="http://www.burns-stat.com/documents/tutorials/why-use-the-r-language/" class="uri">http://www.burns-stat.com/documents/tutorials/why-use-the-r-language/</a><a href="psychometrie.html#fnref48">↩</a></p></li>
<li id="fn49"><p>Ich schlage vor, die Funktion selber auf den Datensatz aufzurufen, um die Zusammenfassung für alle Spalten zu betrachten.<a href="psychometrie.html#fnref49">↩</a></p></li>
<li id="fn50"><p>Dieses wird gemeinsam mit den Daten des “Open Source Psychometrics Project” <a href="https://openpsychometrics.org/_rawdata" class="uri">https://openpsychometrics.org/_rawdata</a> runtergeladen.<a href="psychometrie.html#fnref50">↩</a></p></li>
<li id="fn51"><p><strong>Merke</strong>: Es ist wichtig, sich einen Überblick über Daten zu verschaffen und unplausible und fehlende Werte zu identifizieren. Die Funktionen <code>summary</code> und <code>table</code> sind dabei hilfreich.<a href="psychometrie.html#fnref51">↩</a></p></li>
<li id="fn52"><p>Ich halte dies für kein gutes Vorgehen. Der Wert 0 ist nicht ausreichend unterschiedlich von anderen “legalen” Werten in den anderen Spalten. Der Gesamt-Testscore (<code>npi$score</code>) kann beispielsweise wirklich den Wert 0 annehmen, wenn Teilnehmer/innen kein einziges Mal der narzisstischen Aussage zugestimmt haben – und dies kam tatsächlich 73 Mal vor. Der Wert <code>-99</code> wäre beispielsweise ein besserer Wert gewesen, um fehlende Werte zu kodieren.<a href="psychometrie.html#fnref52">↩</a></p></li>
<li id="fn53"><p>Der Befehl sieht recht harmlos aus, aber tatsächlich steckt hier etwas mehr drin als wir bislang behandelt haben. Wir nehmen zunächst einmal einfach hin, dass man die Umkodierung von fehlenden Werten in <code>data.frames</code> genauso durchführen kann wie in Vektoren. Beachtet, dass hier ein Zugriff auf <code>data.frames</code> mit eckigen Klammern stattfindet (siehe <a href="#fortgeschritten">Kapitel 3.5</a>; tatsächlich ist dieser Zugriff aber sogar noch etwas spezieller als der in Kapitel 3.5 beschriebene – hier ist das Objekt in den eckigen Klammern eine <em>Matrix</em> vom Typ “logical”).<a href="psychometrie.html#fnref53">↩</a></p></li>
<li id="fn54"><p>Ein logischer Vergleich mit <code>NA</code> ergibt immer <code>NA</code>, da beim fehlenden Wert keine Aussage darüber gemacht werden kann, ob er einem anderen Wert entspricht. Man kennt ihn ja nicht. Auch der Befehl <code>TRUE &amp; NA</code> ergibt <code>NA</code>.<a href="psychometrie.html#fnref54">↩</a></p></li>
<li id="fn55"><p>siehe Abschnitt <a href="psychometrie.html#kap4einstieg">Ausgedehntes Beispiel zum Einstieg</a><a href="psychometrie.html#fnref55">↩</a></p></li>
<li id="fn56"><p>Es ist immer wichtig, solche Plausibilitätsüberprüfungen durchzuführen, nachdem man Daten geändert hat.<a href="psychometrie.html#fnref56">↩</a></p></li>
<li id="fn57"><p>Hierfür war es wichtig, dass wir vorher eine eindeutige Fallnummer vergeben haben. Anhand dieser Fallnummer können wir nun die Fälle beider Tabellen eindeutig einander zuordnen.<a href="psychometrie.html#fnref57">↩</a></p></li>
<li id="fn58"><p>Es ist zu bemerken, dass wir noch nicht alle Variablen auf ihre Plausibilität überprüft haben. Die Spalte <code>age</code> enthält ebenfalls noch fehlende sowie auch gänzlich unplausible Werte (etwa 366 oder 509). Auch die Spalte <code>elapse</code>, die die Bearbeitungszeit abspeichert, enthält teilweise unplausible Werte; das Maximum der gespeicherten Bearbeitungszeit liegt bei über 40 Jahren. Doch darauf soll erst einmal nicht unser Augenmerk liegen.<a href="psychometrie.html#fnref58">↩</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="dataframes.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="funktionen.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
},
"search": false
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
