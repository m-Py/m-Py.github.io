<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title></title>
  <meta name="description" content="Testtheorie mit R">
  <meta name="generator" content="bookdown  and GitBook 2.6.7">

  <meta property="og:title" content="" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="" />
  
  
  




  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="psychometrie.html">
<link rel="next" href="funktionen.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="1" data-path="einstieg.html"><a href="einstieg.html"><i class="fa fa-check"></i><b>1</b> Einstieg</a><ul>
<li class="chapter" data-level="1.1" data-path="einstieg.html"><a href="einstieg.html#uber-dieses-skript"><i class="fa fa-check"></i><b>1.1</b> Über dieses Skript</a><ul>
<li class="chapter" data-level="1.1.1" data-path="einstieg.html"><a href="einstieg.html#feedback-und-fehlermeldungen"><i class="fa fa-check"></i><b>1.1.1</b> Feedback und Fehlermeldungen</a></li>
<li class="chapter" data-level="1.1.2" data-path="einstieg.html"><a href="einstieg.html#danksagung"><i class="fa fa-check"></i><b>1.1.2</b> Danksagung</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="einstieg.html"><a href="einstieg.html#erste-schritte-mit-r"><i class="fa fa-check"></i><b>1.2</b> Erste Schritte mit <code>R</code></a><ul>
<li class="chapter" data-level="1.2.1" data-path="einstieg.html"><a href="einstieg.html#die-r-konsole"><i class="fa fa-check"></i><b>1.2.1</b> Die <code>R</code>-Konsole</a></li>
<li class="chapter" data-level="1.2.2" data-path="einstieg.html"><a href="einstieg.html#der-skript-editor"><i class="fa fa-check"></i><b>1.2.2</b> Der Skript-Editor</a></li>
<li class="chapter" data-level="1.2.3" data-path="einstieg.html"><a href="einstieg.html#kommentare"><i class="fa fa-check"></i><b>1.2.3</b> Kommentare</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="einstieg.html"><a href="einstieg.html#ausblick"><i class="fa fa-check"></i><b>1.3</b> Ausblick</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="vektoren.html"><a href="vektoren.html"><i class="fa fa-check"></i><b>2</b> Vektoren</a><ul>
<li class="chapter" data-level="2.1" data-path="vektoren.html"><a href="vektoren.html#variablen"><i class="fa fa-check"></i><b>2.1</b> Variablen</a><ul>
<li class="chapter" data-level="2.1.1" data-path="vektoren.html"><a href="vektoren.html#ausgabevsabspeichern"><i class="fa fa-check"></i><b>2.1.1</b> Ausgabe versus Abspeichern</a></li>
<li class="chapter" data-level="2.1.2" data-path="vektoren.html"><a href="vektoren.html#variablennamen"><i class="fa fa-check"></i><b>2.1.2</b> Variablennamen</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="vektoren.html"><a href="vektoren.html#datentypen-von-vektoren"><i class="fa fa-check"></i><b>2.2</b> Datentypen von Vektoren</a><ul>
<li class="chapter" data-level="2.2.1" data-path="vektoren.html"><a href="vektoren.html#character"><i class="fa fa-check"></i><b>2.2.1</b> <code>character</code></a></li>
<li class="chapter" data-level="2.2.2" data-path="vektoren.html"><a href="vektoren.html#logical"><i class="fa fa-check"></i><b>2.2.2</b> <code>logical</code></a></li>
<li class="chapter" data-level="2.2.3" data-path="vektoren.html"><a href="vektoren.html#factor"><i class="fa fa-check"></i><b>2.2.3</b> <code>factor</code></a></li>
<li class="chapter" data-level="2.2.4" data-path="vektoren.html"><a href="vektoren.html#na"><i class="fa fa-check"></i><b>2.2.4</b> <code>NA</code></a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="vektoren.html"><a href="vektoren.html#logischevergleiche"><i class="fa fa-check"></i><b>2.3</b> Logische Vergleiche</a><ul>
<li class="chapter" data-level="2.3.1" data-path="vektoren.html"><a href="vektoren.html#anwendungsbeispiel-uberprufe-das-gesetz-der-groen-zahlen"><i class="fa fa-check"></i><b>2.3.1</b> Anwendungsbeispiel: Überprüfe das Gesetz der großen Zahlen</a></li>
<li class="chapter" data-level="2.3.2" data-path="vektoren.html"><a href="vektoren.html#der-in-operator"><i class="fa fa-check"></i><b>2.3.2</b> Der <code>%in%</code> Operator</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="vektoren.html"><a href="vektoren.html#zugriff-auf-vektorelemente"><i class="fa fa-check"></i><b>2.4</b> Zugriff auf Vektorelemente</a><ul>
<li class="chapter" data-level="2.4.1" data-path="vektoren.html"><a href="vektoren.html#veczugriff"><i class="fa fa-check"></i><b>2.4.1</b> Der <code>[·]</code>-Zugriff</a></li>
<li class="chapter" data-level="2.4.2" data-path="vektoren.html"><a href="vektoren.html#logischerZugriff"><i class="fa fa-check"></i><b>2.4.2</b> <code>[·]</code>-Zugriff mit einem logischen Vektor</a></li>
<li class="chapter" data-level="2.4.3" data-path="vektoren.html"><a href="vektoren.html#vektorAendern"><i class="fa fa-check"></i><b>2.4.3</b> <code>[·]</code>-Zugriff zum Ändern von Daten</a></li>
</ul></li>
<li class="chapter" data-level="2.5" data-path="vektoren.html"><a href="vektoren.html#praezedenz"><i class="fa fa-check"></i><b>2.5</b> Präzedenz</a></li>
<li class="chapter" data-level="2.6" data-path="vektoren.html"><a href="vektoren.html#zusammenfassung"><i class="fa fa-check"></i><b>2.6</b> Zusammenfassung</a></li>
<li class="chapter" data-level="2.7" data-path="vektoren.html"><a href="vektoren.html#fragen-zum-vertiefenden-verstandnis"><i class="fa fa-check"></i><b>2.7</b> Fragen zum vertiefenden Verständnis</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="dataframes.html"><a href="dataframes.html"><i class="fa fa-check"></i><b>3</b> <code>data.frames</code></a><ul>
<li class="chapter" data-level="3.1" data-path="dataframes.html"><a href="dataframes.html#die-funktion-data.frame"><i class="fa fa-check"></i><b>3.1</b> Die Funktion <code>data.frame</code></a></li>
<li class="chapter" data-level="3.2" data-path="dataframes.html"><a href="dataframes.html#zugriff-auf-eine-einzelne-spalte-die--notation"><i class="fa fa-check"></i><b>3.2</b> Zugriff auf eine einzelne Spalte: die <code>$</code>-Notation</a></li>
<li class="chapter" data-level="3.3" data-path="dataframes.html"><a href="dataframes.html#datenzugriffe"><i class="fa fa-check"></i><b>3.3</b> Zugriff auf Spalten und Zeilen: die <code>[·,·]</code>-Notation</a></li>
<li class="chapter" data-level="3.4" data-path="dataframes.html"><a href="dataframes.html#subset"><i class="fa fa-check"></i><b>3.4</b> Die Funktion <code>subset</code></a><ul>
<li class="chapter" data-level="3.4.1" data-path="dataframes.html"><a href="dataframes.html#zeileneinfach"><i class="fa fa-check"></i><b>3.4.1</b> Vereinfachte Zeilenauswahl</a></li>
<li class="chapter" data-level="3.4.2" data-path="dataframes.html"><a href="dataframes.html#teaserfunktionen"><i class="fa fa-check"></i><b>3.4.2</b> Funktionsargumente</a></li>
<li class="chapter" data-level="3.4.3" data-path="dataframes.html"><a href="dataframes.html#spalteneinfach"><i class="fa fa-check"></i><b>3.4.3</b> Sonderregeln zur Auswahl von Spalten</a></li>
</ul></li>
<li class="chapter" data-level="3.5" data-path="dataframes.html"><a href="dataframes.html#doppelteckig"><i class="fa fa-check"></i><b>3.5</b> Weitere Zugriffe auf <code>data.frames</code></a><ul>
<li class="chapter" data-level="3.5.1" data-path="dataframes.html"><a href="dataframes.html#der--zugriff"><i class="fa fa-check"></i><b>3.5.1</b> Der <code>[[·]]</code>-Zugriff</a></li>
<li class="chapter" data-level="3.5.2" data-path="dataframes.html"><a href="dataframes.html#der--zugriff-1"><i class="fa fa-check"></i><b>3.5.2</b> Der <code>[·]</code>-Zugriff</a></li>
<li class="chapter" data-level="3.5.3" data-path="dataframes.html"><a href="dataframes.html#nameindex"><i class="fa fa-check"></i><b>3.5.3</b> Zugriff nach Name und Index</a></li>
</ul></li>
<li class="chapter" data-level="3.6" data-path="dataframes.html"><a href="dataframes.html#convenient"><i class="fa fa-check"></i><b>3.6</b> Nützliche Funktionen zum Arbeiten mit <code>data.frames</code></a><ul>
<li class="chapter" data-level="3.6.1" data-path="dataframes.html"><a href="dataframes.html#tapply"><i class="fa fa-check"></i><b>3.6.1</b> <code>tapply</code></a></li>
<li class="chapter" data-level="3.6.2" data-path="dataframes.html"><a href="dataframes.html#nrow-und-ncol"><i class="fa fa-check"></i><b>3.6.2</b> <code>nrow</code> und <code>ncol</code></a></li>
<li class="chapter" data-level="3.6.3" data-path="dataframes.html"><a href="dataframes.html#head-und-tail"><i class="fa fa-check"></i><b>3.6.3</b> <code>head</code> und <code>tail</code></a></li>
<li class="chapter" data-level="3.6.4" data-path="dataframes.html"><a href="dataframes.html#sortieren-dplyrarrange"><i class="fa fa-check"></i><b>3.6.4</b> Sortieren: <code>dplyr::arrange</code></a></li>
</ul></li>
<li class="chapter" data-level="3.7" data-path="dataframes.html"><a href="dataframes.html#zusammenfassung-1"><i class="fa fa-check"></i><b>3.7</b> Zusammenfassung</a></li>
<li class="chapter" data-level="3.8" data-path="dataframes.html"><a href="dataframes.html#fragen-zum-vertiefenden-verstandnis-1"><i class="fa fa-check"></i><b>3.8</b> Fragen zum vertiefenden Verständnis</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="psychometrie.html"><a href="psychometrie.html"><i class="fa fa-check"></i><b>4</b> Erste psychometrische Auswertungen</a><ul>
<li class="chapter" data-level="4.1" data-path="psychometrie.html"><a href="psychometrie.html#testscores"><i class="fa fa-check"></i><b>4.1</b> Testscores</a></li>
<li class="chapter" data-level="4.2" data-path="psychometrie.html"><a href="psychometrie.html#item-schwierigkeiten"><i class="fa fa-check"></i><b>4.2</b> Item-Schwierigkeiten</a><ul>
<li class="chapter" data-level="4.2.1" data-path="psychometrie.html"><a href="psychometrie.html#item-interkorrelationen"><i class="fa fa-check"></i><b>4.2.1</b> Item-Interkorrelationen</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="psychometrie.html"><a href="psychometrie.html#trennschaerfe"><i class="fa fa-check"></i><b>4.3</b> Item-Trennschärfen</a></li>
<li class="chapter" data-level="4.4" data-path="psychometrie.html"><a href="psychometrie.html#cronbachs-alpha"><i class="fa fa-check"></i><b>4.4</b> Cronbachs Alpha</a></li>
<li class="chapter" data-level="4.5" data-path="psychometrie.html"><a href="psychometrie.html#split-half-reliabilitat"><i class="fa fa-check"></i><b>4.5</b> Split-Half-Reliabilität</a></li>
<li class="chapter" data-level="4.6" data-path="psychometrie.html"><a href="psychometrie.html#fragen-zum-vertiefenden-verstandnis-2"><i class="fa fa-check"></i><b>4.6</b> Fragen zum vertiefenden Verständnis</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="aufarbeitung-von-fragebogendaten.html"><a href="aufarbeitung-von-fragebogendaten.html"><i class="fa fa-check"></i><b>5</b> Aufarbeitung von Fragebogendaten</a><ul>
<li class="chapter" data-level="5.1" data-path="aufarbeitung-von-fragebogendaten.html"><a href="aufarbeitung-von-fragebogendaten.html#umkodierung"><i class="fa fa-check"></i><b>5.1</b> Umkodierung von Antworten</a><ul>
<li class="chapter" data-level="5.1.1" data-path="aufarbeitung-von-fragebogendaten.html"><a href="aufarbeitung-von-fragebogendaten.html#die-funktion-ifelse"><i class="fa fa-check"></i><b>5.1.1</b> Die Funktion <code>ifelse</code></a></li>
</ul></li>
<li class="chapter" data-level="5.2" data-path="aufarbeitung-von-fragebogendaten.html"><a href="aufarbeitung-von-fragebogendaten.html#invertierung-von-antworten"><i class="fa fa-check"></i><b>5.2</b> Invertierung von Antworten</a></li>
<li class="chapter" data-level="5.3" data-path="aufarbeitung-von-fragebogendaten.html"><a href="aufarbeitung-von-fragebogendaten.html#umgang-mit-fehlenden-werten"><i class="fa fa-check"></i><b>5.3</b> Umgang mit fehlenden Werten</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="funktionen.html"><a href="funktionen.html"><i class="fa fa-check"></i><b>6</b> Funktionen</a><ul>
<li class="chapter" data-level="6.1" data-path="funktionen.html"><a href="funktionen.html#das-black-box-modell"><i class="fa fa-check"></i><b>6.1</b> Das Black-Box-Modell</a></li>
<li class="chapter" data-level="6.2" data-path="funktionen.html"><a href="funktionen.html#argumente"><i class="fa fa-check"></i><b>6.2</b> Argumente</a><ul>
<li class="chapter" data-level="6.2.1" data-path="funktionen.html"><a href="funktionen.html#help"><i class="fa fa-check"></i><b>6.2.1</b> Die <code>R</code>-Hilfe</a></li>
<li class="chapter" data-level="6.2.2" data-path="funktionen.html"><a href="funktionen.html#namenlose-argumente"><i class="fa fa-check"></i><b>6.2.2</b> Namenlose Argumente</a></li>
</ul></li>
<li class="chapter" data-level="6.3" data-path="funktionen.html"><a href="funktionen.html#ruckgabewerte"><i class="fa fa-check"></i><b>6.3</b> Rückgabewerte</a></li>
<li class="chapter" data-level="6.4" data-path="funktionen.html"><a href="funktionen.html#seiteneffekte"><i class="fa fa-check"></i><b>6.4</b> Seiteneffekte</a></li>
<li class="chapter" data-level="6.5" data-path="funktionen.html"><a href="funktionen.html#selbst-geschriebene-funktionen"><i class="fa fa-check"></i><b>6.5</b> Selbst geschriebene Funktionen</a><ul>
<li class="chapter" data-level="6.5.1" data-path="funktionen.html"><a href="funktionen.html#definition-der-eigenen-funktion"><i class="fa fa-check"></i><b>6.5.1</b> Definition der eigenen Funktion</a></li>
<li class="chapter" data-level="6.5.2" data-path="funktionen.html"><a href="funktionen.html#lokale-variablen"><i class="fa fa-check"></i><b>6.5.2</b> Lokale Variablen</a></li>
<li class="chapter" data-level="6.5.3" data-path="funktionen.html"><a href="funktionen.html#optionale-argumente"><i class="fa fa-check"></i><b>6.5.3</b> Optionale Argumente</a></li>
<li class="chapter" data-level="6.5.4" data-path="funktionen.html"><a href="funktionen.html#wann-schreibe-ich-meine-eigene-funktion"><i class="fa fa-check"></i><b>6.5.4</b> Wann schreibe ich meine eigene Funktion</a></li>
</ul></li>
<li class="chapter" data-level="6.6" data-path="funktionen.html"><a href="funktionen.html#fragen-zum-vertiefenden-verstandnis-3"><i class="fa fa-check"></i><b>6.6</b> Fragen zum vertiefenden Verständnis</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="schleifen.html"><a href="schleifen.html"><i class="fa fa-check"></i><b>7</b> Schleifen</a><ul>
<li class="chapter" data-level="7.1" data-path="schleifen.html"><a href="schleifen.html#sequentielle-bepunktung-von-testitems"><i class="fa fa-check"></i><b>7.1</b> Sequentielle Bepunktung von Testitems</a></li>
<li class="chapter" data-level="7.2" data-path="schleifen.html"><a href="schleifen.html#berechnung-von-part-whole-korrigierten-trennscharfen"><i class="fa fa-check"></i><b>7.2</b> Berechnung von part-whole korrigierten Trennschärfen</a></li>
<li class="chapter" data-level="7.3" data-path="schleifen.html"><a href="schleifen.html#datenspeicherung-in-einer-schleife"><i class="fa fa-check"></i><b>7.3</b> Datenspeicherung in einer Schleife</a><ul>
<li class="chapter" data-level="7.3.1" data-path="schleifen.html"><a href="schleifen.html#adressierung-per-name"><i class="fa fa-check"></i><b>7.3.1</b> Adressierung per Name</a></li>
<li class="chapter" data-level="7.3.2" data-path="schleifen.html"><a href="schleifen.html#vektorspeicherung-adressierung-per-index"><i class="fa fa-check"></i><b>7.3.2</b> Vektorspeicherung – Adressierung per Index</a></li>
</ul></li>
<li class="chapter" data-level="7.4" data-path="schleifen.html"><a href="schleifen.html#for-loops-are-evil-oder-nicht"><i class="fa fa-check"></i><b>7.4</b> for-loops are evil – oder nicht?</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="anhang.html"><a href="anhang.html"><i class="fa fa-check"></i><b>8</b> Anhang</a><ul>
<li class="chapter" data-level="8.1" data-path="anhang.html"><a href="anhang.html#datenEinlesen"><i class="fa fa-check"></i><b>8.1</b> Daten einlesen</a></li>
<li class="chapter" data-level="8.2" data-path="anhang.html"><a href="anhang.html#das-environment-sauber-halten"><i class="fa fa-check"></i><b>8.2</b> Das Environment sauber halten</a><ul>
<li class="chapter" data-level="8.2.1" data-path="anhang.html"><a href="anhang.html#variablen-loschen"><i class="fa fa-check"></i><b>8.2.1</b> Variablen löschen</a></li>
<li class="chapter" data-level="8.2.2" data-path="anhang.html"><a href="anhang.html#mit-einem-sauberen-environment-starten"><i class="fa fa-check"></i><b>8.2.2</b> Mit einem sauberen Environment starten</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="9" data-path="referenzen.html"><a href="referenzen.html"><i class="fa fa-check"></i><b>9</b> Referenzen</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./"><div style="white-space: pre-line;">Testtheorie mit R</div></a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="aufarbeitung-von-fragebogendaten" class="section level1">
<h1><span class="header-section-number">5</span> Aufarbeitung von Fragebogendaten</h1>
<p>Unser Ziel ist die Auswertung echter Daten von Persönlichkeits-Fragebögen wie den BIG-5 und dem Narcissistic Personality Inventory. Leider liegen in echten Daten die Werte oftmals nicht in der Form vor, die wir brauchen. Daten enthalten in Rohform unter Umständen gar nicht die Informationen, die wir benötigen, oder haben fehlende Werte. Deswegen werden wir uns als nächstes mit den folgenden Themen beschäftigen:</p>
<ol style="list-style-type: decimal">
<li>Umkodierung von Antworten</li>
<li>Invertierung von Antworten</li>
<li>Umgang mit fehlenden Werten</li>
</ol>
<div id="umkodierung" class="section level2">
<h2><span class="header-section-number">5.1</span> Umkodierung von Antworten</h2>
<p>Eine wichtige Voraussetzung für eine psychometrische Analyse war im Beispiel in Kapitel 4 bereits gegeben: Jeder Wert kodierte genau die Information, die wir brauchten – nämlich ob Schüler/innen eine Aufgabe korrekt gelöst hatten oder nicht (dargestellt durch <code>1</code> und <code>0</code>). In echten Daten muss die relevante Information jedoch häufig erst noch aus den dokumentierten Werten „abgeleitet“ werden. Die Antwort der Schüler/innen im Test könnte beispielsweise ein Kreuz in einem Multiple-Choice-Item sein:</p>
<blockquote>
<p>Aus wie vielen Bundesländern besteht die Bundesrepublik Deutschland?</p>
</blockquote>
<blockquote>
<ol style="list-style-type: decimal">
<li>14</li>
<li>16</li>
<li>19</li>
<li>21</li>
</ol>
</blockquote>
<p>Ob ein Kreuz bei (1), (2), (3) oder (4) gesetzt wird, ist für die Auswertung nicht von Belang. Relevant ist, ob die Frage richtig beantwortet wurde – wir benötigen also die folgende Umkodierung der Daten:</p>
<ul>
<li><code>1</code> <span class="math inline">\(\to\)</span> <code>0</code></li>
<li><code>2</code> <span class="math inline">\(\to\)</span> <code>1</code></li>
<li><code>3</code> <span class="math inline">\(\to\)</span> <code>0</code></li>
<li><code>4</code> <span class="math inline">\(\to\)</span> <code>0</code></li>
</ul>
<p>In psychometrischem Jargon: Für diese Aufgabe ist der Wert <code>2</code> der <em>Schlüssel</em> (engl.: <em>key</em>). Ein Schlüssel kodiert den Eingabewert der richtigen Antwort.<a href="#fn27" class="footnoteRef" id="fnref27"><sup>27</sup></a> Wir lernen jetzt, wie wir solche Umkodierungen in <code>R</code> umsetzen. Die Stärke einer Programmiersprache wie <code>R</code>: Wenn wir einmal gelernt haben, wie wir für eine Item-Schlüssel-Kombination Daten als richtig und falsch umkodieren, können wir mit nur ein wenig mehr Aufwand diesen Prozess für beliebig viele Items wiederholen. Das <em>Narcissistic Personality Inventory</em> etwa hat 40 Items und wir haben keine Lust, 40 Mal eine Umkodierung „händisch“ neu durchzuführen.</p>
<div id="die-funktion-ifelse" class="section level3">
<h3><span class="header-section-number">5.1.1</span> Die Funktion <code>ifelse</code></h3>
<p>Mit der Funktion <code>ifelse</code> lassen sich Transformationen, die anhand eines Schlüssels Korrektheit kodieren, bequem durchführen. Das folgende Beispiel basiert auf dem obigen Multiple-Choice-Item:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Hypothetische Antworten auf das Bundesland Multiple-Choice-Item:</span>
bundesland_answers &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">2</span>)
bundesland_key     &lt;-<span class="st"> </span><span class="dv">2</span>

bundesland_score   &lt;-<span class="st"> </span><span class="kw">ifelse</span>(<span class="dt">test =</span> bundesland_answers <span class="op">==</span><span class="st"> </span>bundesland_key,
                             <span class="dt">yes =</span> <span class="dv">1</span>, <span class="dt">no =</span> <span class="dv">0</span>)
bundesland_score</code></pre></div>
<pre><code>[1] 0 1 0 0 1 0 1</code></pre>
<p>Was ist hier passiert? Ich habe im Vektor <code>bundesland_answers</code> hypothetische Antworten generiert; die Variable <code>bundesland_key</code> enthält den Schlüssel, d.h. die korrekte Antwort. Mithilfe der Funktion <code>ifelse</code> gleiche ich die Antworten mit dem Schlüssel ab. <code>ifelse</code> nimmt drei Argumente entgegen. Diese heißen <code>test</code>, <code>yes</code>, und <code>no</code>:<a href="#fn28" class="footnoteRef" id="fnref28"><sup>28</sup></a></p>
<ul>
<li><code>test</code>: Vergleicht jede Antwort mit dem Schlüssel, hier: <code>bundesland_answers == bundesland_key</code>. Ergebnis dieses Vergleichs ist der folgende logische Vektor (im Allgemeinen kann <code>test</code> einen beliebigen logischen Vektor als Argument annehmen):</li>
</ul>
<pre><code>[1] FALSE  TRUE FALSE FALSE  TRUE FALSE  TRUE</code></pre>
<ul>
<li><code>yes</code>: Der Wert, der angenommen werden soll für Elemente, für die der <code>test</code> <code>TRUE</code> ergab (hier: <code>1</code>)</li>
<li><code>no</code>: Der Wert, der angenommen werden soll für Elemente, für die der <code>test</code> <code>FALSE</code> ergab (hier: <code>0</code>). Praktisch: ich muss nicht angeben, welche falschen Werte alle möglich sind; es reicht aus, den richtigen Wert anzugeben, alle anderen sind automatisch falsch</li>
</ul>
<p>Nach der Umkodierung können wir beispielsweise die Schwierigkeit des Bundesland-Items mit der <code>mean</code> Funktion berechnen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mean</span>(bundesland_score)</code></pre></div>
<pre><code>[1] 0.4285714</code></pre>
<p>In diesem Fall hätten 43% der Testteilnehmer das Bundesland-Item korrekt beantwortet. Diese Information konnten wir aus den ursprünglichen Antwortkategorien 1, 2, 3 und 4 nicht herleiten.</p>
<p>Die Funktion <code>ifelse</code> ist sehr nützlich, mit der wir Antworten umkodieren können. Später lernen wir, wie wir mithilfe von <code>ifelse</code> ganze Tests und nicht nur einzelne Items bepunkten können. Bevor wir das jedoch effizient machen können, werden wir im nächsten Kapitel noch ein paar Grundlagen zur Programmierung mit <code>R</code> lernen.</p>
</div>
</div>
<div id="invertierung-von-antworten" class="section level2">
<h2><span class="header-section-number">5.2</span> Invertierung von Antworten</h2>
<p>Eine mögliche Umkodierung von Antworten ist das Abgleichen mit einem Schlüssel, etwa zur Feststellung der Korrektheit von Antworten. Eine weitere häufig auftretende Variante ist die <em>Invertierung</em> von Antworten. Betrachten wir folgende zwei Items, die in einer Big-5 Kurzskala den Aspekt Extraversion messen:</p>
<blockquote>
<ol style="list-style-type: decimal">
<li>Ich bin eher zurückhaltend, reserviert.</li>
<li>Ich gehe aus mir heraus, bin gesellig.</li>
</ol>
</blockquote>
<p>Beide Items werden auf einer Likertskala mit fünf Abstufungen gemessen, das heißt es werden Punktzahlen von 1 bis 5 vergeben. Das Problem ist, dass in Item 1 ein hoher Punktwert für wenig Extraversion steht, in Item 2 ein hoher Punktwert hingegen für eine hohe Ausprägung in Extraversion. Generell wollen wir einen <em>Summenwert</em> berechnen, also einen Wert, der die Extraversion eines jeden Testteilnehmers kodiert – und zwar über beide Items hinweg. Im vorliegenden Fall macht es aber keinen Sinn, die Punktzahlen beider Items zu addieren. Die höchste Ausprägung in Extraversion würde sich dann ergeben, wenn ein Item extravertiert beantwortet wird, aber das andere introvertiert. Damit die Punktzahlen in beiden Items „in dieselbe Richtung“ zu verstehen sind, wollen wir die Antworten auf Item 1 <em>invertieren</em>, sodass auch hier eine hohe Punktzahl für eine hohe Merkmalsausprägung in Extraversion steht. Das heißt, wir wollen die folgende Abbildung durchführen:</p>
<ul>
<li><code>1</code> <span class="math inline">\(\to\)</span> <code>5</code></li>
<li><code>2</code> <span class="math inline">\(\to\)</span> <code>4</code></li>
<li><code>3</code> <span class="math inline">\(\to\)</span> <code>3</code></li>
<li><code>4</code> <span class="math inline">\(\to\)</span> <code>2</code></li>
<li><code>5</code> <span class="math inline">\(\to\)</span> <code>1</code></li>
</ul>
<p>Wir könnten dies mit mehrfacher Anwendung von <code>ifelse</code> hinbekommen, was jedoch mühsam wäre. Es gibt eine mathematische Umformung, welche wir auch mit nur wenig Code umsetzen können:</p>
<blockquote>
<p>Invertierter Wert = Ursprungswert * (-1) + Höchster Skalenwert + 1</p>
</blockquote>
<p>Diese funktioniert, wenn unsere Punktzahlen zwischen 1 und dem höchstmöglichen Skalenwert liegen. Probieren wir es mit ein paar hypothetischen Antworten aus:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">big5 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">item1 =</span> <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">5</span>),
                   <span class="dt">item2 =</span> <span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">3</span>, <span class="dv">2</span>))

## Betrachte den data.frame:
big5</code></pre></div>
<pre><code>  item1 item2
1     2     5
2     3     3
3     2     3
4     1     4
5     4     3
6     2     5
7     1     3
8     5     2</code></pre>
<p>Wir können uns mit der <code>cor</code> Funktion die Korrelation zwischen den zwei Items ausgeben lassen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">round</span>(<span class="kw">cor</span>(big5), <span class="dv">2</span>)</code></pre></div>
<pre><code>      item1 item2
item1  1.00 -0.57
item2 -0.57  1.00</code></pre>
<p>Ich habe die Antwortwerte absichtlich so gewählt, dass sich hier ein typisches Muster ergibt: Antworten auf unterschiedlich gepolte Items – die zur selbem Skala gehören – korrelieren typischerweise negativ miteinander. Das heißt: Hohe Antwortwerte im einen Item gehen tendenziell mit niedrigen Werten im anderen Item einher – wenn die unterschiedlich gepolten Items dasselbe Konstrukt erfassen. Durch die Invertierung erhalten wir Daten, die positiv miteinander korrelieren. Folgender Code führt die Invertierung durch:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 5 ist der höchst-mögliche Skalenwert</span>
big5<span class="op">$</span>item1_inv &lt;-<span class="st"> </span>big5<span class="op">$</span>item1 <span class="op">*</span><span class="st"> </span>(<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span><span class="st"> </span><span class="dv">6</span></code></pre></div>
<p>Schauen wir uns die Daten an, um zu prüfen, ob die Transformation funktioniert hat:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">big5[, <span class="kw">c</span>(<span class="st">&quot;item1&quot;</span>, <span class="st">&quot;item1_inv&quot;</span>)]</code></pre></div>
<pre><code>  item1 item1_inv
1     2         4
2     3         3
3     2         4
4     1         5
5     4         2
6     2         4
7     1         5
8     5         1</code></pre>
<p>Das hat geklappt! Schauen wir uns nun auch noch einmal die Inter-Itemkorrelationen an:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">round</span>(<span class="kw">cor</span>(big5), <span class="dv">2</span>)</code></pre></div>
<pre><code>          item1 item2 item1_inv
item1      1.00 -0.57     -1.00
item2     -0.57  1.00      0.57
item1_inv -1.00  0.57      1.00</code></pre>
<p>Wie wir sehen, korrelieren die Spalten <code>item2</code> und <code>item1_inv</code> genau wie <code>item2</code> und <code>item1</code> – nur mit positivem Vorzeichen. Ebenfalls interessant: <code>item1</code> und <code>item1_inv</code> korrelieren perfekt negativ – und das ist genau das, was wir mit der Invertierung erreichen wollten: Einen Punktwert errechnen, der genau in die entgegengesetzte Richtung zu interpretieren ist wie der ursprüngliche Wert.</p>
</div>
<div id="umgang-mit-fehlenden-werten" class="section level2">
<h2><span class="header-section-number">5.3</span> Umgang mit fehlenden Werten</h2>
<blockquote>
<p>Real data have missing values. Missing values are an integral part of the R language. Many functions have arguments that control how missing values are to be handled. – Patrick Burns<a href="#fn29" class="footnoteRef" id="fnref29"><sup>29</sup></a></p>
</blockquote>
<p>Wir lernen nun den rudimentären Umgang mit fehlenden Werten in <code>R</code> kennen. Dabei könnte man vermutlich beliebig sophistiziert vorgehen, jedoch werden wir nur einen basalen und wichtigen Spezialfall kennenlernen:</p>
<ol style="list-style-type: decimal">
<li>Wir wandeln alle Werte in <code>NA</code> um, die als fehlend zu klassifizieren sind</li>
<li>Danach schließen wir alle Fälle mit fehlenden Werten aus</li>
</ol>
<p>Für dieses Beispiel laden wir Daten des Narcissistic Personality Inventory <span class="citation">(NPI; Raskin &amp; Terry, 1988)</span> ein. Die Daten von mehr als 11,000 Bearbeitungen des NPI sind erfreulicherweise über das „Open Source Psychometrics Project“ unter <a href="https://openpsychometrics.org/_rawdata" class="uri">https://openpsychometrics.org/_rawdata</a> abrufbar. Wenn wir die Daten heruntergeladen haben und die Datei „data.csv“ in unserem RStudio-Projektordner liegt (siehe <a href="anhang.html#datenEinlesen">Anhang</a>), können wir den Datensatz wie folgt einlesen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Lese Daten ein
npi &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;data.csv&quot;</span>)</code></pre></div>
<p>Wie folgt verschaffen wir uns einen Überblick über die Daten:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">nrow</span>(npi) <span class="co"># Wie viele Fälle</span></code></pre></div>
<pre><code>[1] 11243</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ncol</span>(npi) <span class="co"># Wie viele Spalten</span></code></pre></div>
<pre><code>[1] 44</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(npi) <span class="co"># wie heißen die Messvariablen</span></code></pre></div>
<pre><code> [1] &quot;score&quot;  &quot;Q1&quot;     &quot;Q2&quot;     &quot;Q3&quot;     &quot;Q4&quot;     &quot;Q5&quot;     &quot;Q6&quot;    
 [8] &quot;Q7&quot;     &quot;Q8&quot;     &quot;Q9&quot;     &quot;Q10&quot;    &quot;Q11&quot;    &quot;Q12&quot;    &quot;Q13&quot;   
[15] &quot;Q14&quot;    &quot;Q15&quot;    &quot;Q16&quot;    &quot;Q17&quot;    &quot;Q18&quot;    &quot;Q19&quot;    &quot;Q20&quot;   
[22] &quot;Q21&quot;    &quot;Q22&quot;    &quot;Q23&quot;    &quot;Q24&quot;    &quot;Q25&quot;    &quot;Q26&quot;    &quot;Q27&quot;   
[29] &quot;Q28&quot;    &quot;Q29&quot;    &quot;Q30&quot;    &quot;Q31&quot;    &quot;Q32&quot;    &quot;Q33&quot;    &quot;Q34&quot;   
[36] &quot;Q35&quot;    &quot;Q36&quot;    &quot;Q37&quot;    &quot;Q38&quot;    &quot;Q39&quot;    &quot;Q40&quot;    &quot;elapse&quot;
[43] &quot;gender&quot; &quot;age&quot;   </code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(npi, <span class="dt">n =</span> <span class="dv">3</span>) <span class="co"># Wie sehen die Daten aus</span></code></pre></div>
<pre><code>  score Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9 Q10 Q11 Q12 Q13 Q14 Q15 Q16 Q17 Q18 Q19
1    18  2  2  2  2  1  2  1  2  2   2   1   1   2   1   1   1   2   1   1
2     6  2  2  2  1  2  2  1  2  1   1   2   2   2   1   2   2   1   1   2
3    27  1  2  2  1  2  1  2  1  2   2   2   1   1   1   1   1   2   2   1
  Q20 Q21 Q22 Q23 Q24 Q25 Q26 Q27 Q28 Q29 Q30 Q31 Q32 Q33 Q34 Q35 Q36 Q37
1   1   1   1   1   2   2   2   1   2   2   2   1   2   1   1   1   2   2
2   1   2   2   1   2   2   2   2   1   2   2   2   1   2   2   1   2   2
3   1   2   2   2   2   1   2   1   1   2   1   2   2   1   1   2   1   1
  Q38 Q39 Q40 elapse gender age
1   2   1   2    211      1  50
2   2   2   1    149      1  40
3   2   1   2    168      1  28</code></pre>
<p>Wir bemerken, dass keine Variable als “Fallnummer” fungiert. Generell ist es <strong>immer</strong> wichtig, dass jeder Datensatz durch eine eindeutige Fallnummer zu identifizieren ist. Da eine solche in den eingelesenen Daten jedoch nicht enthalten ist, fügen wir selber eine Fallnummer hinzu:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">npi<span class="op">$</span>casenum &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(npi)</code></pre></div>
<p>Eine weitere nützliche Funktion zum Betrachten von <code>data.frames</code> ist die Funktion <code>summary</code>, die uns einen schnellen Überblick über die Werte in allen Spalten des <code>data.frames</code> bietet:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(npi)</code></pre></div>
<p>Die Funktion <code>summary</code> ergibt für jede Spalte eine Tabelle. Wegen der Länge des Outputs von <code>summary(npi)</code> ist nicht der gesamte Output im Skript abgebildet.<a href="#fn30" class="footnoteRef" id="fnref30"><sup>30</sup></a> Für die Variable <code>score</code> erhalten wir folgende Informationen zum Narzissmus-Gesamtscore:</p>
<table>
<thead>
<tr class="header">
<th align="left">score</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Min. : 0.0</td>
</tr>
<tr class="even">
<td align="left">1st Qu.: 7.0</td>
</tr>
<tr class="odd">
<td align="left">Median :12.0</td>
</tr>
<tr class="even">
<td align="left">Mean :13.3</td>
</tr>
<tr class="odd">
<td align="left">3rd Qu.:18.0</td>
</tr>
<tr class="even">
<td align="left">Max. :40.0</td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong>Identifikation von fehlenden Werten im NPI Datensatz</strong></p>
<p>Das NPI besteht aus 40 Items. Aus dem <em>Codebuch</em> des NPI Datensatzes<a href="#fn31" class="footnoteRef" id="fnref31"><sup>31</sup></a> wissen wir, dass Antworten auf die NPI Items die Werte 1 und 2 annehmen können. Die Antwort auf jedes Item des NPI besteht aus einer „forced choice“ zwischen zwei Aussagen; eine davon steht für Narzissmus. Item 1 besteht beispielsweise aus den folgenden beiden Aussagen:</p>
<blockquote>
<ol style="list-style-type: decimal">
<li>I have a natural talent for influencing people.</li>
<li>I am not good at influencing people.</li>
</ol>
</blockquote>
<p>Die Wahl von Aussage 1 wird mit 1 kodiert, die Wahl von Aussage 2 mit 2. Nachgeschaltet wird folgende Umkodierung vorgenommen, die die Item-Scores berechnet: Wird die „narzisstische Aussage“ ausgewählt (hier Aussage 1: „I have a natural talent for influencing people.“), wird das Item mit 1 bepunktet. Wird die Aussage gewählt, die nicht für Narzissmus steht (hier Aussage 2: „I am not good at influencing people.“), wird eine 0 vergeben. Wie wir zu Beginn des Abschnitts gelernt haben, könnten wir Item 1 deswegen wie folgt bepunkten:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">npi<span class="op">$</span>Q1_score &lt;-<span class="st"> </span><span class="kw">ifelse</span>(npi<span class="op">$</span>Q1 <span class="op">==</span><span class="st"> </span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>)</code></pre></div>
<p><strong>Aber Vorsicht: so würden wir einen Fehler machen</strong>! Die Spalte <code>npi$Q1</code> enthält nicht nur die Werte 1 und 2, sondern auch 0-Werte, wie wir mit dem Befehl <code>table(npi$Q1)</code> prüfen können:<a href="#fn32" class="footnoteRef" id="fnref32"><sup>32</sup></a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(npi<span class="op">$</span>Q1)</code></pre></div>
<pre><code>
   0    1    2 
  17 6872 4354 </code></pre>
<p>Wie wir sehen, wurden die Antwortkategorien 0, 1 und 2 vergeben. Es kommt sogar 17 Mal die Antwortkategorie 0 vor – <strong>obwohl Antworten nur die Werte 1 und 2 annehmen dürfen</strong>. Wie kommt das? Die Antwort ist: Bei der Bearbeitung des NPI-Fragebogens – welche im Rahmen einer Online-Studie stattfand – konnten Teilnehmer/innen Items unbeantwortet lassen. Fehlende Werte in den Antworten wurden mit einer 0 kodiert.<a href="#fn33" class="footnoteRef" id="fnref33"><sup>33</sup></a></p>
<p> </p>
<p><strong>Ausschluss von Fällen mit fehlenden Werten</strong></p>
<p> </p>
<p>Wir wollen als nächstes alle Fälle ausschließen, bei denen mindestens ein fehlender Wert in den Antworten auf die 40 NPI Items vorliegt, d.h. für mindestens eine der Spalten <code>npi$Q1</code>, …, <code>npi$Q40</code> der Wert 0 ist. Erst danach können wir die Itemscores berechnen.</p>
<p>Zu diesem Zweck speichern wir zunächst die Antworten auf die 40 Items und die Fallnummer in einem neuen <code>data.frame</code> ab. Anhand dieses <code>data.frames</code> werden wir die Fallausschlüsse durchführen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">item_responses &lt;-<span class="st"> </span>npi[, <span class="kw">c</span>(<span class="st">&quot;casenum&quot;</span>, <span class="kw">paste0</span>(<span class="st">&quot;Q&quot;</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">40</span>))]</code></pre></div>
<p>Wir können jetzt 0-Werte in <code>NA</code> umkodieren, indem wir ein Vorgehen verwenden, das wir in <a href="vektoren.html#vektorAendern">Kapitel 2</a> für Vektoren kennengelernt haben. Dieses Vorgehen funktioniert bei <code>data.frames</code> tatsächlich genauso:<a href="#fn34" class="footnoteRef" id="fnref34"><sup>34</sup></a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">item_responses[item_responses <span class="op">==</span><span class="st"> </span><span class="dv">0</span>] &lt;-<span class="st"> </span><span class="ot">NA</span></code></pre></div>
<p>Für einzelne Spalten kann man mithilfe der Funktion <code>is.na</code> überprüfen, ob diese fehlende Werte enthalten. <code>is.na</code> ergibt einen logischen Vektor, der kodiert, ob jedes Element des übergebenen Vektors – also etwa eine Spalte, die wir mit der <code>$</code>-Notation ausgelesen haben – <code>NA</code> ist. Mit diesem Wissen können wir etwa für einzelne Items überprüfen, wie viele Personen keine Antwort angegeben haben:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sum</span>(<span class="kw">is.na</span>(item_responses<span class="op">$</span>Q1))</code></pre></div>
<pre><code>[1] 17</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sum</span>(<span class="kw">is.na</span>(item_responses<span class="op">$</span>Q40))</code></pre></div>
<pre><code>[1] 34</code></pre>
<p><strong>Wichtig</strong>: Man <strong>muss</strong> <code>is.na</code> verwenden, um zu prüfen, ob Werte <code>NA</code> sind; Folgendes geht schief:<a href="#fn35" class="footnoteRef" id="fnref35"><sup>35</sup></a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Nutze head, um nicht alle 11,000 Vergleiche auszugeben
<span class="kw">head</span>(item_responses<span class="op">$</span>Q1 <span class="op">==</span><span class="st"> </span><span class="ot">NA</span>)</code></pre></div>
<pre><code>[1] NA NA NA NA NA NA</code></pre>
<p>Um insgesamt einen Überblick über die Verteilung der fehlenden Fälle zu erhalten, bietet sich eine erneute Anwendung der Funktion <code>summary</code> an. Diese gibt nämlich direkt für jede Spalte eines <code>data.frames</code> die Zahl der fehlenden Fälle an. Folgende Information gibt es zum ersten Item:</p>
<p> </p>
<table>
<thead>
<tr class="header">
<th align="left">Q1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Min. :1.000</td>
</tr>
<tr class="even">
<td align="left">1st Qu.:1.000</td>
</tr>
<tr class="odd">
<td align="left">Median :1.000</td>
</tr>
<tr class="even">
<td align="left">Mean :1.388</td>
</tr>
<tr class="odd">
<td align="left">3rd Qu.:2.000</td>
</tr>
<tr class="even">
<td align="left">Max. :2.000</td>
</tr>
<tr class="odd">
<td align="left">NA’s :17</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Jetzt, da wir fehlende Antworten per <code>NA</code> als fehlend gekennzeichnet haben, gibt es verschiedene Möglichkeiten, die zugehörigen Fälle auszuschließen. Eine Möglichkeit wäre eine Aneinanderreihung von vielen ODER-Verknüpfungen, an die wir eine Auswahl mit <code>subset</code> oder der <code>[·,·]</code>-Notation anschließen. Dies könnte wie folgt funktionieren:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Identifiziere Fälle, die in irgendeinem Item einen
## fehlenden Wert haben (hier nur exemplarisch, kein
## legaler R-Code, da Items 4 bis 39 nicht ausgeschrieben
## sind):
irgendwo_na &lt;-<span class="st"> </span><span class="kw">is.na</span>(item_responses<span class="op">$</span>Q1) <span class="op">|</span>
<span class="st">    </span><span class="kw">is.na</span>(item_responses<span class="op">$</span>Q2) <span class="op">|</span>
<span class="st">    </span><span class="kw">is.na</span>(item_responses<span class="op">$</span>Q3) <span class="op">|</span>
<span class="st">    </span>... <span class="op">|</span>
<span class="st">    </span><span class="kw">is.na</span>(item_responses<span class="op">$</span>Q40)

## Negation durchführen, um die Fälle zu erwischen, die
## *keinen* fehlenden Wert enthalten
nirgendwo_na &lt;-<span class="st"> </span><span class="op">!</span>irgendwo_na

## Wähle diese Fälle aus:
item_responses &lt;-<span class="st"> </span>item_responses[, nirgendwo_na]</code></pre></div>
<p>Durch die Verknüpfung der ODER-Operatoren werden alle Fälle identifiziert, die mindestens eine fehlende Antwort enthalten. Diese Aneinanderreihung ist jedoch mühselig und fehleranfällig. Diese Arbeit wollen wir uns nicht machen.</p>
<p>Eine weitere Methode, fehlende Werte zu identifizieren nutzt aus, dass die Funktion <code>rowSums</code><a href="#fn36" class="footnoteRef" id="fnref36"><sup>36</sup></a> <code>NA</code> ausgibt, wenn mindestens ein Wert aus einer Zeile <code>NA</code> enthält – zumindest wenn wir nicht das optionale Argument <code>na.rm</code> auf <code>TRUE</code> setzen. Dies ist analog zu der Funktion <code>sum</code>, die für einen einzelnen Vektor eine Summe bestimmt. Die Funktion <code>sum</code> gibt ebenfalls <code>NA</code> aus, wenn mindestens ein Element des übergebenen Vektors <code>NA</code> ist und <code>na.rm</code> nicht auf <code>TRUE</code> gesetzt wurde. Die Funktion <code>rowSums</code> erweitert also auch im Hinblick auf den Umgang mit fehlenden Werten das Verhalten von <code>sum</code> auf alle Zeilen eines <code>data.frames</code>. Aus diesem Grund funktioniert das hier:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Identifiziere Fälle, die in irgendeinem Item einen
## fehlenden Wert haben:
irgendwo_na &lt;-<span class="st"> </span><span class="kw">is.na</span>(<span class="kw">rowSums</span>(item_responses))</code></pre></div>
<p>Am bequemsten ist es jedoch, wenn wir die Funktion <code>na.omit</code> nutzen, die uns einfach so alle Fälle ausschließt, die fehlende Werte enthalten:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">item_responses &lt;-<span class="st"> </span><span class="kw">na.omit</span>(item_responses)</code></pre></div>
<p>Die Funktion <code>na.omit</code> gibt einen <code>data.frame</code> aus, der keine der Zeilen enthält, in denen mindestens ein <code>NA</code>-Wert vorlag. So müssen wir nicht selber die Zeilen identifizieren, die fehlende Werte enthalten.</p>
<p>Vergleichen wir nun den ursprünglichen <code>data.frame</code> <code>npi</code> mit der „bereinigten“ Tabelle:<a href="#fn37" class="footnoteRef" id="fnref37"><sup>37</sup></a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">nrow</span>(npi)</code></pre></div>
<pre><code>[1] 11243</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">nrow</span>(item_responses)</code></pre></div>
<pre><code>[1] 10440</code></pre>
<p>Wie wir sehen, haben wir 803 Fälle wegen fehlender Werte ausgeschlossen. Etwas unschön ist, dass in unseren bereinigten Daten einige Variablen – wie das Geschlecht und das Alter – fehlen. Das liegt daran, dass wir für den Ausschluss von Fällen nur die Item-Antworten berücksichtigt haben, die wir zuvor im <code>data.frame</code> <code>item_responses</code> abgespeichert haben. Vergleichen wir:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(npi)</code></pre></div>
<pre><code> [1] &quot;score&quot;   &quot;Q1&quot;      &quot;Q2&quot;      &quot;Q3&quot;      &quot;Q4&quot;      &quot;Q5&quot;      &quot;Q6&quot;     
 [8] &quot;Q7&quot;      &quot;Q8&quot;      &quot;Q9&quot;      &quot;Q10&quot;     &quot;Q11&quot;     &quot;Q12&quot;     &quot;Q13&quot;    
[15] &quot;Q14&quot;     &quot;Q15&quot;     &quot;Q16&quot;     &quot;Q17&quot;     &quot;Q18&quot;     &quot;Q19&quot;     &quot;Q20&quot;    
[22] &quot;Q21&quot;     &quot;Q22&quot;     &quot;Q23&quot;     &quot;Q24&quot;     &quot;Q25&quot;     &quot;Q26&quot;     &quot;Q27&quot;    
[29] &quot;Q28&quot;     &quot;Q29&quot;     &quot;Q30&quot;     &quot;Q31&quot;     &quot;Q32&quot;     &quot;Q33&quot;     &quot;Q34&quot;    
[36] &quot;Q35&quot;     &quot;Q36&quot;     &quot;Q37&quot;     &quot;Q38&quot;     &quot;Q39&quot;     &quot;Q40&quot;     &quot;elapse&quot; 
[43] &quot;gender&quot;  &quot;age&quot;     &quot;casenum&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(item_responses)</code></pre></div>
<pre><code> [1] &quot;casenum&quot; &quot;Q1&quot;      &quot;Q2&quot;      &quot;Q3&quot;      &quot;Q4&quot;      &quot;Q5&quot;      &quot;Q6&quot;     
 [8] &quot;Q7&quot;      &quot;Q8&quot;      &quot;Q9&quot;      &quot;Q10&quot;     &quot;Q11&quot;     &quot;Q12&quot;     &quot;Q13&quot;    
[15] &quot;Q14&quot;     &quot;Q15&quot;     &quot;Q16&quot;     &quot;Q17&quot;     &quot;Q18&quot;     &quot;Q19&quot;     &quot;Q20&quot;    
[22] &quot;Q21&quot;     &quot;Q22&quot;     &quot;Q23&quot;     &quot;Q24&quot;     &quot;Q25&quot;     &quot;Q26&quot;     &quot;Q27&quot;    
[29] &quot;Q28&quot;     &quot;Q29&quot;     &quot;Q30&quot;     &quot;Q31&quot;     &quot;Q32&quot;     &quot;Q33&quot;     &quot;Q34&quot;    
[36] &quot;Q35&quot;     &quot;Q36&quot;     &quot;Q37&quot;     &quot;Q38&quot;     &quot;Q39&quot;     &quot;Q40&quot;    </code></pre>
<p>Um einen <code>data.frame</code> zu erhalten, in dem alle Informationen zu den vollständigen Fällen enthalten sind, machen wir uns zunutze, dass die relevanten Informationen noch im Urspungs-<code>data.frame</code> <code>npi</code> abgespeichert sind. Wie folgt können wir mit der Funktion <code>merge</code> die ursprüngliche Tabelle <code>npi</code> mit der um fehlende Fälle bereinigten Tabelle <code>item_responses</code> zusammenführen.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">npi_clean &lt;-<span class="st"> </span><span class="kw">merge</span>(npi, item_responses)</code></pre></div>
<p>Wir erhalten in der Variablen <code>npi_clean</code> einen Datensatz, der nur Fälle mit vollständigen Antworten enthält – und für diese Fälle auch alle Werte abspeichert. Prüfe:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">nrow</span>(npi_clean)</code></pre></div>
<pre><code>[1] 10440</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(npi_clean)</code></pre></div>
<pre><code> [1] &quot;Q1&quot;      &quot;Q2&quot;      &quot;Q3&quot;      &quot;Q4&quot;      &quot;Q5&quot;      &quot;Q6&quot;      &quot;Q7&quot;     
 [8] &quot;Q8&quot;      &quot;Q9&quot;      &quot;Q10&quot;     &quot;Q11&quot;     &quot;Q12&quot;     &quot;Q13&quot;     &quot;Q14&quot;    
[15] &quot;Q15&quot;     &quot;Q16&quot;     &quot;Q17&quot;     &quot;Q18&quot;     &quot;Q19&quot;     &quot;Q20&quot;     &quot;Q21&quot;    
[22] &quot;Q22&quot;     &quot;Q23&quot;     &quot;Q24&quot;     &quot;Q25&quot;     &quot;Q26&quot;     &quot;Q27&quot;     &quot;Q28&quot;    
[29] &quot;Q29&quot;     &quot;Q30&quot;     &quot;Q31&quot;     &quot;Q32&quot;     &quot;Q33&quot;     &quot;Q34&quot;     &quot;Q35&quot;    
[36] &quot;Q36&quot;     &quot;Q37&quot;     &quot;Q38&quot;     &quot;Q39&quot;     &quot;Q40&quot;     &quot;casenum&quot; &quot;score&quot;  
[43] &quot;elapse&quot;  &quot;gender&quot;  &quot;age&quot;    </code></pre>
<p>Die Funktionsweise der Funktion <code>merge</code> soll hier nicht tiefergehend betrachtet werden. Es reicht zu wissen, dass sie Fälle aus zwei <code>data.frames</code> anhand ihrer Werte zuordnet.<a href="#fn38" class="footnoteRef" id="fnref38"><sup>38</sup></a> Dabei werden Fälle weggelassen, die keinen „Partner“ haben – also hier Fälle, zu denen nur in einer Tabelle eine Fallnummer vorliegt. Die Fälle ohne Partner sind hierbei genau die Fälle, die aus <code>npi_clean</code> wegen fehlender Werte ausgeschlossen wurden.</p>
<p>Die Anwendung der Funktion <code>merge</code> hat die Reihenfolge unserer Daten durcheinander gebracht. Es ist nicht so wichtig, warum das so ist, aber wir wollen diesen Nebeneffekt wieder rückgängig machen. Deswegen nutzen wir die Funktion <code>arrange</code> aus dem Paket <code>dplyr</code>, um die Daten wieder anhand der Fallnummer zu sortieren:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">&quot;dplyr&quot;</span>) <span class="co"># falls noch nicht geladen</span>
npi_clean &lt;-<span class="st"> </span><span class="kw">arrange</span>(npi_clean, casenum)</code></pre></div>
<p>Voilá – <code>npi_clean</code> ist der Datensatz, mit dem wir nun psychometrische Berechnungen durchführen können.<a href="#fn39" class="footnoteRef" id="fnref39"><sup>39</sup></a> Dabei ist unser nächstes Ziel für alle 40 Items eine dichotome Bepunktung durchzuführen. Wir wissen bereits, wie wir das machen könnten, nämlich indem wir mit <code>ifelse</code> die Antworten auf jedes Item mit dem Schlüssel abgleichen. Der Schlüssel für den das NPI kodiert für jedes der 40 Items den Wert, der für Narzissmus steht. Dies wäre wie folgt möglich:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Hier kein legaler R-Code, nur exemplarisch:</span>
npi_key &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, ..., <span class="dv">2</span>) <span class="co"># 40 Schlüsselemente</span>

npi<span class="op">$</span>Q1_score &lt;-<span class="st"> </span><span class="kw">ifelse</span>(npi<span class="op">$</span>Q1 <span class="op">==</span><span class="st"> </span>npi_key[<span class="dv">1</span>], <span class="dv">1</span>, <span class="dv">0</span>)
npi<span class="op">$</span>Q2_score &lt;-<span class="st"> </span><span class="kw">ifelse</span>(npi<span class="op">$</span>Q2 <span class="op">==</span><span class="st"> </span>npi_key[<span class="dv">2</span>], <span class="dv">1</span>, <span class="dv">0</span>)

...
...
...

npi<span class="op">$</span>Q40_score &lt;-<span class="st"> </span><span class="kw">ifelse</span>(npi<span class="op">$</span>Q40 <span class="op">==</span><span class="st"> </span>npi_key[<span class="dv">40</span>], <span class="dv">1</span>, <span class="dv">0</span>)</code></pre></div>
<p>Da wir nicht denselben Code – mit leichten Abwandlungen – 40 Mal wiederholen wollen, werden wir in Kapitel 7 lernen, diese Umkodierungen effizient durchzuführen.</p>

</div>
</div>
<div class="footnotes">
<hr />
<ol start="27">
<li id="fn27"><p>Im Allgemeinen muss ein Schlüssel nicht Korrektheit anzeigen, sondern kann auch Merkmalsausprägung in einem Persönlichkeitsinventar kodieren. Wir werden das im Narcissistic Personality Inventory kennenlernen.<a href="aufarbeitung-von-fragebogendaten.html#fnref27">↩</a></p></li>
<li id="fn28"><p>Wie wir gesehen haben, können wir Argumente in Funktionen per Name und per Position ansteuern.<a href="aufarbeitung-von-fragebogendaten.html#fnref28">↩</a></p></li>
<li id="fn29"><p><a href="http://www.burns-stat.com/documents/tutorials/why-use-the-r-language/" class="uri">http://www.burns-stat.com/documents/tutorials/why-use-the-r-language/</a><a href="aufarbeitung-von-fragebogendaten.html#fnref29">↩</a></p></li>
<li id="fn30"><p>Ich schlage vor, die Funktion selber auf den Datensatz aufzurufen, um die Zusammenfassung für alle Spalten zu betrachten.<a href="aufarbeitung-von-fragebogendaten.html#fnref30">↩</a></p></li>
<li id="fn31"><p>Dieses wird gemeinsam mit den Daten des „Open Source Psychometrics Project“ <a href="https://openpsychometrics.org/_rawdata" class="uri">https://openpsychometrics.org/_rawdata</a> runtergeladen.<a href="aufarbeitung-von-fragebogendaten.html#fnref31">↩</a></p></li>
<li id="fn32"><p><strong>Merke</strong>: Es ist wichtig, sich einen Überblick über Daten zu verschaffen und unplausible und fehlende Werte zu identifizieren. Die Funktionen <code>summary</code> und <code>table</code> sind dabei hilfreich.<a href="aufarbeitung-von-fragebogendaten.html#fnref32">↩</a></p></li>
<li id="fn33"><p>Ich halte dies für kein gutes Vorgehen. Der Wert 0 ist nicht ausreichend unterschiedlich von anderen „legalen Werten“ in den anderen Spalten. Der Gesamt-Testscore (<code>npi$score</code>) kann beispielsweise wirklich den Wert 0 annehmen, wenn Teilnehmer/innen kein einziges Mal der narzisstischen Aussage zugestimmt haben – und dies kam tatsächlich 73 Mal vor. Der Wert <code>-99</code> wäre beispielsweise ein besserer Wert gewesen, um fehlende Werte zu kodieren.<a href="aufarbeitung-von-fragebogendaten.html#fnref33">↩</a></p></li>
<li id="fn34"><p>Der Befehl sieht recht harmlos aus, aber tatsächlich steckt hier etwas mehr drin als wir bislang behandelt haben. Wir nehmen zunächst einmal einfach hin, dass man die Umkodierung von fehlenden Werten in <code>data.frames</code> genauso durchführen kann wie in Vektoren. Beachtet, dass hier ein Zugriff auf <code>data.frames</code> mit eckigen Klammern stattfindet (siehe <a href="#fortgeschritten">Kapitel 3.5</a>; tatsächlich ist dieser Zugriff aber sogar noch etwas spezieller als der in Kapitel 3.5 beschriebene – hier ist das Objekt in den eckigen Klammern eine <em>Matrix</em> vom Typ „logical“).<a href="aufarbeitung-von-fragebogendaten.html#fnref34">↩</a></p></li>
<li id="fn35"><p>Ein logischer Vergleich mit <code>NA</code> ergibt immer <code>NA</code>, da beim fehlenden Wert keine Aussage darüber gemacht werden kann, ob er einem anderen Wert entspricht. Man kennt ihn ja nicht. Auch der Befehl <code>TRUE &amp; NA</code> ergibt <code>NA</code>.<a href="aufarbeitung-von-fragebogendaten.html#fnref35">↩</a></p></li>
<li id="fn36"><p>siehe das <a href="#kap4einstieg">ausgedehnte Beispiel zum Einstieg</a><a href="aufarbeitung-von-fragebogendaten.html#fnref36">↩</a></p></li>
<li id="fn37"><p>Es ist immer wichtig, solche Plausibilitätsüberprüfungen durchzuführen, nachdem man Daten geändert hat.<a href="aufarbeitung-von-fragebogendaten.html#fnref37">↩</a></p></li>
<li id="fn38"><p>Hierfür war es wichtig, dass wir vorher eine eindeutige Fallnummer vergeben haben. Anhand dieser Fallnummer können wir nun die Fälle beider Tabellen eindeutig einander zuordnen.<a href="aufarbeitung-von-fragebogendaten.html#fnref38">↩</a></p></li>
<li id="fn39"><p>Es ist zu bemerken, dass wir noch nicht alle Variablen auf ihre Plausibilität überprüft haben. Die Spalte <code>age</code> enthält ebenfalls noch fehlende sowie auch gänzlich unplausible Werte (etwa 366 oder 509). Auch die Spalte <code>elapse</code>, die die Bearbeitungszeit abspeichert, enthält teilweise unplausible Werte; das Maximum der gespeicherten Bearbeitungszeit liegt bei über 40 Jahren. Doch darauf soll erst einmal nicht unser Augenmerk liegen.<a href="aufarbeitung-von-fragebogendaten.html#fnref39">↩</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="psychometrie.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="funktionen.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
},
"search": false
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
