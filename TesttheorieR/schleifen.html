<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title></title>
  <meta name="description" content="Testtheorie mit R">
  <meta name="generator" content="bookdown  and GitBook 2.6.7">

  <meta property="og:title" content="" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="" />
  
  
  




  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="funktionen.html">
<link rel="next" href="simulationen.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="1" data-path="einstieg.html"><a href="einstieg.html"><i class="fa fa-check"></i><b>1</b> Einstieg</a><ul>
<li class="chapter" data-level="1.1" data-path="einstieg.html"><a href="einstieg.html#uber-dieses-skript"><i class="fa fa-check"></i><b>1.1</b> Über dieses Skript</a><ul>
<li class="chapter" data-level="1.1.1" data-path="einstieg.html"><a href="einstieg.html#feedback-und-fehlermeldungen"><i class="fa fa-check"></i><b>1.1.1</b> Feedback und Fehlermeldungen</a></li>
<li class="chapter" data-level="1.1.2" data-path="einstieg.html"><a href="einstieg.html#danksagung"><i class="fa fa-check"></i><b>1.1.2</b> Danksagung</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="einstieg.html"><a href="einstieg.html#erste-schritte-mit-r"><i class="fa fa-check"></i><b>1.2</b> Erste Schritte mit <code>R</code></a><ul>
<li class="chapter" data-level="1.2.1" data-path="einstieg.html"><a href="einstieg.html#die-r-konsole"><i class="fa fa-check"></i><b>1.2.1</b> Die <code>R</code>-Konsole</a></li>
<li class="chapter" data-level="1.2.2" data-path="einstieg.html"><a href="einstieg.html#der-skript-editor"><i class="fa fa-check"></i><b>1.2.2</b> Der Skript-Editor</a></li>
<li class="chapter" data-level="1.2.3" data-path="einstieg.html"><a href="einstieg.html#kommentare"><i class="fa fa-check"></i><b>1.2.3</b> Kommentare</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="einstieg.html"><a href="einstieg.html#ausblick"><i class="fa fa-check"></i><b>1.3</b> Ausblick</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="vektoren.html"><a href="vektoren.html"><i class="fa fa-check"></i><b>2</b> Vektoren</a><ul>
<li class="chapter" data-level="2.1" data-path="vektoren.html"><a href="vektoren.html#variablen"><i class="fa fa-check"></i><b>2.1</b> Variablen</a><ul>
<li class="chapter" data-level="2.1.1" data-path="vektoren.html"><a href="vektoren.html#ausgabevsabspeichern"><i class="fa fa-check"></i><b>2.1.1</b> Ausgabe versus Abspeichern</a></li>
<li class="chapter" data-level="2.1.2" data-path="vektoren.html"><a href="vektoren.html#variablennamen"><i class="fa fa-check"></i><b>2.1.2</b> Variablennamen</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="vektoren.html"><a href="vektoren.html#datentypen-von-vektoren"><i class="fa fa-check"></i><b>2.2</b> Datentypen von Vektoren</a><ul>
<li class="chapter" data-level="2.2.1" data-path="vektoren.html"><a href="vektoren.html#character"><i class="fa fa-check"></i><b>2.2.1</b> <code>character</code></a></li>
<li class="chapter" data-level="2.2.2" data-path="vektoren.html"><a href="vektoren.html#logical"><i class="fa fa-check"></i><b>2.2.2</b> <code>logical</code></a></li>
<li class="chapter" data-level="2.2.3" data-path="vektoren.html"><a href="vektoren.html#factor"><i class="fa fa-check"></i><b>2.2.3</b> <code>factor</code></a></li>
<li class="chapter" data-level="2.2.4" data-path="vektoren.html"><a href="vektoren.html#na"><i class="fa fa-check"></i><b>2.2.4</b> <code>NA</code></a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="vektoren.html"><a href="vektoren.html#logischevergleiche"><i class="fa fa-check"></i><b>2.3</b> Logische Vergleiche</a><ul>
<li class="chapter" data-level="2.3.1" data-path="vektoren.html"><a href="vektoren.html#anwendungsbeispiel-uberprufe-das-gesetz-der-groen-zahlen"><i class="fa fa-check"></i><b>2.3.1</b> Anwendungsbeispiel: Überprüfe das Gesetz der großen Zahlen</a></li>
<li class="chapter" data-level="2.3.2" data-path="vektoren.html"><a href="vektoren.html#der-in-operator"><i class="fa fa-check"></i><b>2.3.2</b> Der <code>%in%</code> Operator</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="vektoren.html"><a href="vektoren.html#zugriff-auf-vektorelemente"><i class="fa fa-check"></i><b>2.4</b> Zugriff auf Vektorelemente</a><ul>
<li class="chapter" data-level="2.4.1" data-path="vektoren.html"><a href="vektoren.html#veczugriff"><i class="fa fa-check"></i><b>2.4.1</b> Der <code>[·]</code>-Zugriff</a></li>
<li class="chapter" data-level="2.4.2" data-path="vektoren.html"><a href="vektoren.html#logischerZugriff"><i class="fa fa-check"></i><b>2.4.2</b> <code>[·]</code>-Zugriff mit einem logischen Vektor</a></li>
<li class="chapter" data-level="2.4.3" data-path="vektoren.html"><a href="vektoren.html#vektorAendern"><i class="fa fa-check"></i><b>2.4.3</b> <code>[·]</code>-Zugriff zum Ändern von Daten</a></li>
</ul></li>
<li class="chapter" data-level="2.5" data-path="vektoren.html"><a href="vektoren.html#praezedenz"><i class="fa fa-check"></i><b>2.5</b> Präzedenz</a></li>
<li class="chapter" data-level="2.6" data-path="vektoren.html"><a href="vektoren.html#zusammenfassung"><i class="fa fa-check"></i><b>2.6</b> Zusammenfassung</a></li>
<li class="chapter" data-level="2.7" data-path="vektoren.html"><a href="vektoren.html#fragen-zum-vertiefenden-verstandnis"><i class="fa fa-check"></i><b>2.7</b> Fragen zum vertiefenden Verständnis</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="dataframes.html"><a href="dataframes.html"><i class="fa fa-check"></i><b>3</b> <code>data.frames</code></a><ul>
<li class="chapter" data-level="3.1" data-path="dataframes.html"><a href="dataframes.html#die-funktion-data.frame"><i class="fa fa-check"></i><b>3.1</b> Die Funktion <code>data.frame</code></a></li>
<li class="chapter" data-level="3.2" data-path="dataframes.html"><a href="dataframes.html#zugriff-auf-eine-einzelne-spalte-die--notation"><i class="fa fa-check"></i><b>3.2</b> Zugriff auf eine einzelne Spalte: die <code>$</code>-Notation</a></li>
<li class="chapter" data-level="3.3" data-path="dataframes.html"><a href="dataframes.html#datenzugriffe"><i class="fa fa-check"></i><b>3.3</b> Zugriff auf Spalten und Zeilen: die <code>[·,·]</code>-Notation</a></li>
<li class="chapter" data-level="3.4" data-path="dataframes.html"><a href="dataframes.html#subset"><i class="fa fa-check"></i><b>3.4</b> Die Funktion <code>subset</code></a><ul>
<li class="chapter" data-level="3.4.1" data-path="dataframes.html"><a href="dataframes.html#zeileneinfach"><i class="fa fa-check"></i><b>3.4.1</b> Vereinfachte Zeilenauswahl</a></li>
<li class="chapter" data-level="3.4.2" data-path="dataframes.html"><a href="dataframes.html#teaserfunktionen"><i class="fa fa-check"></i><b>3.4.2</b> Funktionsargumente</a></li>
<li class="chapter" data-level="3.4.3" data-path="dataframes.html"><a href="dataframes.html#spalteneinfach"><i class="fa fa-check"></i><b>3.4.3</b> Sonderregeln zur Auswahl von Spalten</a></li>
</ul></li>
<li class="chapter" data-level="3.5" data-path="dataframes.html"><a href="dataframes.html#doppelteckig"><i class="fa fa-check"></i><b>3.5</b> Weitere Zugriffe auf <code>data.frames</code></a><ul>
<li class="chapter" data-level="3.5.1" data-path="dataframes.html"><a href="dataframes.html#der--zugriff"><i class="fa fa-check"></i><b>3.5.1</b> Der <code>[[·]]</code>-Zugriff</a></li>
<li class="chapter" data-level="3.5.2" data-path="dataframes.html"><a href="dataframes.html#der--zugriff-1"><i class="fa fa-check"></i><b>3.5.2</b> Der <code>[·]</code>-Zugriff</a></li>
<li class="chapter" data-level="3.5.3" data-path="dataframes.html"><a href="dataframes.html#nameindex"><i class="fa fa-check"></i><b>3.5.3</b> Zugriff nach Name und Index</a></li>
</ul></li>
<li class="chapter" data-level="3.6" data-path="dataframes.html"><a href="dataframes.html#convenient"><i class="fa fa-check"></i><b>3.6</b> Nützliche Funktionen zum Arbeiten mit <code>data.frames</code></a><ul>
<li class="chapter" data-level="3.6.1" data-path="dataframes.html"><a href="dataframes.html#tapply"><i class="fa fa-check"></i><b>3.6.1</b> <code>tapply</code></a></li>
<li class="chapter" data-level="3.6.2" data-path="dataframes.html"><a href="dataframes.html#nrow-und-ncol"><i class="fa fa-check"></i><b>3.6.2</b> <code>nrow</code> und <code>ncol</code></a></li>
<li class="chapter" data-level="3.6.3" data-path="dataframes.html"><a href="dataframes.html#head-und-tail"><i class="fa fa-check"></i><b>3.6.3</b> <code>head</code> und <code>tail</code></a></li>
<li class="chapter" data-level="3.6.4" data-path="dataframes.html"><a href="dataframes.html#sortieren-dplyrarrange"><i class="fa fa-check"></i><b>3.6.4</b> Sortieren: <code>dplyr::arrange</code></a></li>
</ul></li>
<li class="chapter" data-level="3.7" data-path="dataframes.html"><a href="dataframes.html#zusammenfassung-1"><i class="fa fa-check"></i><b>3.7</b> Zusammenfassung</a></li>
<li class="chapter" data-level="3.8" data-path="dataframes.html"><a href="dataframes.html#fragen-zum-vertiefenden-verstandnis-1"><i class="fa fa-check"></i><b>3.8</b> Fragen zum vertiefenden Verständnis</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="psychometrie.html"><a href="psychometrie.html"><i class="fa fa-check"></i><b>4</b> Arbeiten mit psychometrischen Daten</a><ul>
<li class="chapter" data-level="4.1" data-path="psychometrie.html"><a href="psychometrie.html#kap4einstieg"><i class="fa fa-check"></i><b>4.1</b> Ausgedehntes Beispiel zum Einstieg</a><ul>
<li class="chapter" data-level="4.1.1" data-path="psychometrie.html"><a href="psychometrie.html#testscores"><i class="fa fa-check"></i><b>4.1.1</b> Testscores</a></li>
<li class="chapter" data-level="4.1.2" data-path="psychometrie.html"><a href="psychometrie.html#item-schwierigkeiten"><i class="fa fa-check"></i><b>4.1.2</b> Item-Schwierigkeiten</a></li>
<li class="chapter" data-level="4.1.3" data-path="psychometrie.html"><a href="psychometrie.html#item-interkorrelationen"><i class="fa fa-check"></i><b>4.1.3</b> Item-Interkorrelationen</a></li>
<li class="chapter" data-level="4.1.4" data-path="psychometrie.html"><a href="psychometrie.html#trennschaerfe"><i class="fa fa-check"></i><b>4.1.4</b> Item-Trennschärfen</a></li>
<li class="chapter" data-level="4.1.5" data-path="psychometrie.html"><a href="psychometrie.html#cronbachs-alpha"><i class="fa fa-check"></i><b>4.1.5</b> Cronbachs Alpha</a></li>
<li class="chapter" data-level="4.1.6" data-path="psychometrie.html"><a href="psychometrie.html#split-half-reliabilitat"><i class="fa fa-check"></i><b>4.1.6</b> Split-Half-Reliabilität</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="psychometrie.html"><a href="psychometrie.html#umgang-mit-echten-daten"><i class="fa fa-check"></i><b>4.2</b> Umgang mit echten Daten</a><ul>
<li class="chapter" data-level="4.2.1" data-path="psychometrie.html"><a href="psychometrie.html#umkodierung"><i class="fa fa-check"></i><b>4.2.1</b> Umkodierung von Variablen</a></li>
<li class="chapter" data-level="4.2.2" data-path="psychometrie.html"><a href="psychometrie.html#invertierung-von-antworten"><i class="fa fa-check"></i><b>4.2.2</b> Invertierung von Antworten</a></li>
<li class="chapter" data-level="4.2.3" data-path="psychometrie.html"><a href="psychometrie.html#umgang-mit-fehlenden-werten"><i class="fa fa-check"></i><b>4.2.3</b> Umgang mit fehlenden Werten</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="psychometrie.html"><a href="psychometrie.html#zusammenfassung-2"><i class="fa fa-check"></i><b>4.3</b> Zusammenfassung</a></li>
<li class="chapter" data-level="4.4" data-path="psychometrie.html"><a href="psychometrie.html#fragen-zum-vertiefenden-verstandnis-2"><i class="fa fa-check"></i><b>4.4</b> Fragen zum vertiefenden Verständnis</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="funktionen.html"><a href="funktionen.html"><i class="fa fa-check"></i><b>5</b> Funktionen</a><ul>
<li class="chapter" data-level="5.1" data-path="funktionen.html"><a href="funktionen.html#das-black-box-modell"><i class="fa fa-check"></i><b>5.1</b> Das Black-Box-Modell</a></li>
<li class="chapter" data-level="5.2" data-path="funktionen.html"><a href="funktionen.html#argumente"><i class="fa fa-check"></i><b>5.2</b> Argumente</a><ul>
<li class="chapter" data-level="5.2.1" data-path="funktionen.html"><a href="funktionen.html#help"><i class="fa fa-check"></i><b>5.2.1</b> Die <code>R</code>-Hilfe</a></li>
<li class="chapter" data-level="5.2.2" data-path="funktionen.html"><a href="funktionen.html#namenlose-argumente"><i class="fa fa-check"></i><b>5.2.2</b> Namenlose Argumente</a></li>
</ul></li>
<li class="chapter" data-level="5.3" data-path="funktionen.html"><a href="funktionen.html#ruckgabewerte"><i class="fa fa-check"></i><b>5.3</b> Rückgabewerte</a></li>
<li class="chapter" data-level="5.4" data-path="funktionen.html"><a href="funktionen.html#seiteneffekte"><i class="fa fa-check"></i><b>5.4</b> Seiteneffekte</a></li>
<li class="chapter" data-level="5.5" data-path="funktionen.html"><a href="funktionen.html#selbst-geschriebene-funktionen"><i class="fa fa-check"></i><b>5.5</b> Selbst geschriebene Funktionen</a><ul>
<li class="chapter" data-level="5.5.1" data-path="funktionen.html"><a href="funktionen.html#definition-der-eigenen-funktion"><i class="fa fa-check"></i><b>5.5.1</b> Definition der eigenen Funktion</a></li>
<li class="chapter" data-level="5.5.2" data-path="funktionen.html"><a href="funktionen.html#lokale-variablen"><i class="fa fa-check"></i><b>5.5.2</b> Lokale Variablen</a></li>
<li class="chapter" data-level="5.5.3" data-path="funktionen.html"><a href="funktionen.html#optionale-argumente"><i class="fa fa-check"></i><b>5.5.3</b> Optionale Argumente</a></li>
<li class="chapter" data-level="5.5.4" data-path="funktionen.html"><a href="funktionen.html#wann-schreibe-ich-meine-eigene-funktion"><i class="fa fa-check"></i><b>5.5.4</b> Wann schreibe ich meine eigene Funktion</a></li>
</ul></li>
<li class="chapter" data-level="5.6" data-path="funktionen.html"><a href="funktionen.html#fragen-zum-vertiefenden-verstandnis-3"><i class="fa fa-check"></i><b>5.6</b> Fragen zum vertiefenden Verständnis</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="schleifen.html"><a href="schleifen.html"><i class="fa fa-check"></i><b>6</b> Schleifen</a><ul>
<li class="chapter" data-level="6.1" data-path="schleifen.html"><a href="schleifen.html#sequentielle-bepunktung-von-testitems"><i class="fa fa-check"></i><b>6.1</b> Sequentielle Bepunktung von Testitems</a></li>
<li class="chapter" data-level="6.2" data-path="schleifen.html"><a href="schleifen.html#berechnung-von-part-whole-korrigierten-trennscharfen"><i class="fa fa-check"></i><b>6.2</b> Berechnung von part-whole korrigierten Trennschärfen</a></li>
<li class="chapter" data-level="6.3" data-path="schleifen.html"><a href="schleifen.html#datenspeicherung-in-einer-schleife"><i class="fa fa-check"></i><b>6.3</b> Datenspeicherung in einer Schleife</a><ul>
<li class="chapter" data-level="6.3.1" data-path="schleifen.html"><a href="schleifen.html#adressierung-per-name"><i class="fa fa-check"></i><b>6.3.1</b> Adressierung per Name</a></li>
<li class="chapter" data-level="6.3.2" data-path="schleifen.html"><a href="schleifen.html#vektorspeicherung-adressierung-per-index"><i class="fa fa-check"></i><b>6.3.2</b> Vektorspeicherung – Adressierung per Index</a></li>
</ul></li>
<li class="chapter" data-level="6.4" data-path="schleifen.html"><a href="schleifen.html#for-loops-are-evil-oder-nicht"><i class="fa fa-check"></i><b>6.4</b> for-loops are evil – oder nicht?</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="simulationen.html"><a href="simulationen.html"><i class="fa fa-check"></i><b>7</b> Simulationen</a></li>
<li class="chapter" data-level="8" data-path="anhang.html"><a href="anhang.html"><i class="fa fa-check"></i><b>8</b> Anhang</a><ul>
<li class="chapter" data-level="8.1" data-path="anhang.html"><a href="anhang.html#datenEinlesen"><i class="fa fa-check"></i><b>8.1</b> Daten einlesen</a></li>
<li class="chapter" data-level="8.2" data-path="anhang.html"><a href="anhang.html#das-environment-sauber-halten"><i class="fa fa-check"></i><b>8.2</b> Das Environment sauber halten</a><ul>
<li class="chapter" data-level="8.2.1" data-path="anhang.html"><a href="anhang.html#variablen-loschen"><i class="fa fa-check"></i><b>8.2.1</b> Variablen löschen</a></li>
<li class="chapter" data-level="8.2.2" data-path="anhang.html"><a href="anhang.html#mit-einem-sauberen-environment-starten"><i class="fa fa-check"></i><b>8.2.2</b> Mit einem sauberen Environment starten</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="9" data-path="referenzen.html"><a href="referenzen.html"><i class="fa fa-check"></i><b>9</b> Referenzen</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./"><div style="white-space: pre-line;">Testtheorie mit R</div></a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="schleifen" class="section level1">
<h1><span class="header-section-number">6</span> Schleifen</h1>
<p>Ein Hinweis zu Beginn: Dieses Kapitel nutzt den <code>[[·]]</code>-Zugriff auf Spalten in <code>data.frames</code>. Wer damit noch nicht vertraut ist, sollte sich vor dem Weiterlesen zunächst den <a href="dataframes.html#doppelteckig">kurzen Abschnitt zum <code>[[·]]</code>-Zugriff</a> in Kapitel 3 ansehen.</p>
<p>Schleifen spielen in allen Programmiersprachen eine wichtige Rolle. Sie erlauben uns, eine Aufgabe mehrfach durchzuführen, ohne dass wir den Code für die Aufgabe mehrfach schreiben müssen. Beispielsweise müssen wir Umkodierungen von Items (vgl. <a href="psychometrie.html#umkodierung">Kapitel 4</a>) nicht für jedes einzelne Item neu eingeben – d.h. fehleranfällig copy-pasten –, sondern können sie mithilfe einer Schleife für alle Items auf einmal durchführen. Wie auch eigene Funktionen helfen uns Schleifen bei der Automatisierung unserer Arbeit. Sie helfen uns, <code>R</code> als Programmiersprache zu nutzen.</p>
<p>Im Allgemeinen und in <code>R</code> im Speziellen gibt es mehrere schleifenartige Gebilde; in diesem Kapitel lernen wir die wichtige <code>for</code>-Schleife kennen.<a href="#fn59" class="footnoteRef" id="fnref59"><sup>59</sup></a> Das logische Prinzip einer <code>for</code>-Schleifen ist recht simpel: Sie führt einen Code-Block mehrfach durch. In der Regel wird in den verschiedenen Durchläufen der Schleife variiert, auf welche Daten – also etwa auf welche Items eines Tests – zugegriffen wird, damit nicht in jedem Durchgang einfach dasselbe passiert. Dies ist die Syntax einer <code>for</code>-Schleife:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span> (Schleifenvariable <span class="cf">in</span> vector) {
  ... <span class="co"># hier steht beliebiger R-Code</span>
}</code></pre></div>
<p>Das sieht erst einmal etwas beunruhigend aus. Gehen wir die einzelnen Bestandteile der Schleife einmal durch; danach schauen wir uns eine <code>for</code>-Schleife in Aktion an.</p>
<p>Den Anfang der Schleife definieren wir mit dem Schlagwort <code>for</code>. Die eigentliche Musik spielt in der darauf folgenden Klammer <code>(Schleifenvariable in vector)</code>. Dabei ist <code>vector</code> ein beliebiger <code>R</code>-Vektor. Von der Länge dieses Vektors hängt ab, wie oft der Code im Körper der Schleife – eingeschlossen in den geschwungenen Klammern <code>{·}</code> – ausgeführt wird. Wir könnten der <code>for</code>-Schleife beispielsweise einen der folgenden Vektoren übergeben:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">c</span>(<span class="dv">83</span>, <span class="dv">45</span>, <span class="dv">12</span>, <span class="op">-</span><span class="dv">99</span>) <span class="co"># Die Schleife würde 4x laufen</span>
<span class="kw">c</span>(<span class="st">&quot;Cronbach&quot;</span>, <span class="st">&quot;Spearman&quot;</span>, <span class="st">&quot;Brown&quot;</span>)  <span class="co"># 3x</span>
<span class="dv">1</span><span class="op">:</span><span class="dv">10</span> <span class="co"># 10x</span>
<span class="kw">paste0</span>(<span class="st">&quot;item&quot;</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">50</span>) <span class="co"># 50x</span></code></pre></div>
<p>Wäre <code>vector</code> einer dieser vier Vektoren, würde die Schleife viermal, dreimal, zehnmal, oder 50 Mal durchgeführt werden. Um zu verstehen, warum es überhaupt Sinn macht, denselben Code-Block mehrfach durchzuführen, betrachten wir zusätzlich den Ausdruck <code>Schleifenvariable</code>, der die Magie der <code>for</code>-Schleife offenbart: <strong>Der <code>Schleifenvariable</code> wird in jedem Schleifendurchlauf schrittweise das nächste Element von <code>vector</code> zugeordnet.</strong> Auf die <code>Schleifenvariable</code> können wir also im Körper der Schleife zugreifen und ihr Inhalt ändert sich in jedem Durchlauf der Schleife. Betrachten wir folgendes Spielzeug-Beispiel, das das Konzept der <code>for</code>-Schleife verdeutlicht:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span> (name <span class="cf">in</span> <span class="kw">c</span>(<span class="st">&#39;Cronbach&#39;</span>, <span class="st">&#39;Spearman&#39;</span>, <span class="st">&#39;Brown&#39;</span>)) {
  <span class="kw">print</span>(name)
}</code></pre></div>
<pre><code>[1] &quot;Cronbach&quot;
[1] &quot;Spearman&quot;
[1] &quot;Brown&quot;</code></pre>
<p>Die Funktion <code>print</code> ist die explizite Anweisung, ein <code>R</code>-Objekt in der Konsole auszugeben. Wir sehen, dass uns die Schleife in ihren drei Durchläufen drei verschiedene Texte ausgibt, nämlich nacheinander den Inhalt des Vektors <code>c('Cronbach', 'Spearman', 'Brown')</code>. Da <code>print</code> auf die Variable <code>name</code> angewendet wurde, sehen wir, dass <code>name</code> ihren Inhalt in jedem Durchlauf der Schleife geändert hat.</p>
<p>Wir stellen fest, dass <code>for</code>-Schleifen folgende Eigenschaften haben:</p>
<ul>
<li>Sie führen einen Code-Block genauso oft aus, wie ein übergebener Vektor lang ist.</li>
<li>Eine Schleifenvariable nimmt in jedem Durchlauf den nächsten Wert des übergebenen Vektors an.</li>
<li>Im Körper der Schleife können wir auf die Schleifenvariable zugreifen, um in jedem Durchlauf andere Berechnungen durchzuführen.</li>
</ul>
<p>Das ist tatsächlich schon alles! Im Folgenden lernen wir zwei konkrete Anwendungen von <code>for</code>-Schleifen kennen.</p>
<div id="sequentielle-bepunktung-von-testitems" class="section level2">
<h2><span class="header-section-number">6.1</span> Sequentielle Bepunktung von Testitems</h2>
<p>In <a href="psychometrie.html#umkodierung">Kapitel 4</a> haben wir gelernt, wie wir mithilfe eines Schlüssels Testfragen aus einem psychologischen Test bepunkten können. Im NPI hatten wir den Fall, dass jedes Item aus einer narzisstischen und einer nicht-narzisstischen Aussage bestand; wir haben für ein Item genau dann einen Punkt vergeben, wenn die narzisstische Aussage gewählt wurde.</p>
<p>Wir wollen im Folgenden diese Bepunktung mithilfe einer <code>for</code>-Schleife automatisieren, das heißt auf einmal für alle 40 Items des NPI durchführen. Dafür benötige ich für jedes Item des NPI den Schlüssel, den ich dem Codebuch entnehmen kann. Wir übertragen die 40 Schlüssel zunächst manuell in einen Vektor:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Schlüssel aller 40 Items in einen Vektor
keys &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>,
          <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>)</code></pre></div>
<p>Als Nächstes führe ich mit einer <code>for</code>-Schleife die Bepunktung aller Items durch. In diesem Code nehme ich an, dass die NPI-Antwortdaten schon eingelesen wurden und die Datenbereinigung aus Kapitel 4 durchgeführt wurde, mir also ein <code>data.frame</code> mit Namen <code>npi_clean</code> vorliegt, der alle Fälle ohne fehlende Antworten enthält.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Die Variable `npi_clean` enthält die Antworten für das NPI, siehe
## Kapitel 4

<span class="co"># for-Schleife für die Kodierung:</span>
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">40</span>) {
    <span class="co"># 1. Wähle Spaltenname des i&#39;ten Items aus:</span>
    colname &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="st">&quot;Q&quot;</span>, i)
    <span class="co"># 2. Wähle aus Spalte die Antworten aus:</span>
    ith_item &lt;-<span class="st"> </span>npi_clean[[colname]]
    <span class="co"># 3. Führe Umkodierung durch:</span>
    narcissistic_response &lt;-<span class="st"> </span><span class="kw">ifelse</span>(ith_item <span class="op">==</span><span class="st"> </span>keys[i], <span class="dv">1</span>, <span class="dv">0</span>)
    <span class="co"># 4. Erstelle Namen für neue Spalte:</span>
    new_colname  &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="st">&quot;coded&quot;</span>, colname)
    <span class="co"># 5. Hänge kodierte Werte an data.frame an:</span>
    npi_clean[[new_colname]] &lt;-<span class="st"> </span>narcissistic_response
}</code></pre></div>
<p>Der erste Befehl im Körper der Schleife generiert mit der Funktion <code>paste0</code> den Namen der Spalte, der adressiert werden soll. Im ersten Durchgang der <code>for</code>-Schleife wird also die Spalte <code>Q1</code> adressiert, da die Schleifenvariable <code>i</code> den ersten Wert des Vektors <code>1:40</code> angenommen hat. Dann folgen <code>Q2</code>, <code>Q3</code> und so weiter. Als Namen von Schleifenvariablen werden häufig kurze Namen wie <code>i</code> oder <code>j</code> verwendet, insbesondere wenn es sich um <em>Indexvariablen</em> handelt, sie also eine numerische Sequenz der Form <code>1:n</code> durchlaufen.</p>
<p>Der zweite Befehl im Körper der Schleife wählt die zuvor definierte Spalte von <code>npi_clean</code> als Vektor aus. Ich benutze dabei die <code>[[·]]</code>-Notation, da sie mir erlaubt, eine Variable vom Typ <code>character</code> in den Klammern zu übergeben. Der folgende Aufruf mit der <code>$</code>-Notation würde nicht funktionieren: <code>npi_clean$colname</code> – hierbei würde <code>R</code> nach einer Spalte mit dem Namen <code>colname</code> suchen, aber wir wollen hier ja stattdessen eigentlich den in der Variable <code>colname</code> enthaltenen Spaltennamen (etwa <code>Q23</code>) verwenden.</p>
<p>Der dritte Befehl im Körper der Schleife führt mit einem Aufruf der Funktion <code>ifelse</code> die eigentliche Umkodierung durch. Es wird kodiert, ob Probanden beim i’ten Item die narzisstische Aussage ausgewählt haben. Eine 1 wird vergeben, wenn das der Fall war, andernfalls eine Null. Ich speichere diesen numerischen Vektor aus Einsen und Nullen in der Variablen <code>narcissistic_response</code> zwischen. Beachtet, dass diese Variable in jedem Durchlauf der Schleife überschrieben wird (dasselbe gilt für die Variablen <code>colname</code>, <code>ith_item</code> und <code>new_colname</code>) .</p>
<p>Der vierte Befehl im Körper der Schleife generiert mit einem Aufruf der Funktion <code>paste0</code> in jedem Durchlauf einen neuen Spaltennamen. Die neuen Spalten haben Namen der Form <code>codedQ1</code>, <code>codedQ2</code> und so weiter.</p>
<p>Der fünfte Befehl im Körper der Schleife fügt mit der <code>[[·]]</code>-Notation die umkodierten Narzissmus-Werte als Spalte an <code>npi_clean</code> hinzu. So stelle ich sicher, dass ich auch später darauf zugreifen kann, etwa um Summenwerte über alle Items oder Item-Trennschärfen zu bestimmen.</p>
<p>Beachtet, dass ich die <code>for</code>-Schleife auch mit weniger Zwischenschritten hätte umsetzen können; folgender Code würde in weniger Zeilen dasselbe Ergebnis erzielen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">40</span>) {
    colname &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="st">&quot;Q&quot;</span>, i)
    npi_clean[[<span class="kw">paste0</span>(<span class="st">&quot;coded&quot;</span>, colname)]] &lt;-
<span class="st">        </span><span class="kw">ifelse</span>(npi_clean[[colname]] <span class="op">==</span><span class="st"> </span>keys[i], <span class="dv">1</span>, <span class="dv">0</span>)
}</code></pre></div>
<p>Im ersten Beispiel habe ich jedoch jeden Zwischenschritt in einer eigenen Variablen abgespeichert, um den Code besser verständlich zu machen und alle Schritte zu erklären. Aus meiner Sicht ist das Zwischenspeichern in Variablen gut geeignet, um zu kommunizieren, was Code macht – insbesondere, wenn die Variablen gut benannt sind.</p>
</div>
<div id="berechnung-von-part-whole-korrigierten-trennscharfen" class="section level2">
<h2><span class="header-section-number">6.2</span> Berechnung von part-whole korrigierten Trennschärfen</h2>
<p>Nachdem ich mit der letzten <code>for</code>-Schleife die rohen Antwortdaten in die angemessene Form umkodiert habe, kann ich mit meiner Analyse starten. Ein wichtiger Teil einer Item-Analyse ist die Berechnung von <a href="psychometrie.html#trennschaerfe">Item-Trennschärfen</a>. Dieser Abschnitt behandelt die Frage, wie wir mithilfe einer <code>for</code>-Schleife korrigierte Item-Trennschärfen für alle 40 Items des NPI berechnen können. Wir nutzen diesen Code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Wir nutzen die umkodierten NPI-Werte: speichere diese
## zunächst in einem separaten data.frame ab:
columns &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="st">&quot;codedQ&quot;</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">40</span>)
items &lt;-<span class="st"> </span>npi_clean[, columns]

## Berechne die Trennschärfen in Schleife
<span class="cf">for</span> (column <span class="cf">in</span> columns) {
    <span class="co"># 1. Summenwert unter Ausschluss eines Items</span>
    scores &lt;-<span class="st"> </span><span class="kw">rowSums</span>(items[, column <span class="op">!=</span><span class="st"> </span><span class="kw">colnames</span>(items)])
    <span class="co"># 2. Korreliere damit den Item-Score</span>
    part_whole &lt;-<span class="st"> </span><span class="kw">cor</span>(items[[column]], scores)
    <span class="co"># 3. Gib die Trennschärfe aus</span>
    <span class="kw">print</span>(part_whole)
}</code></pre></div>
<pre><code>[1] 0.3558674
[1] 0.4201535
[1] 0.3321716
...</code></pre>
<p>Mithilfe der Funktion <code>print</code> gebe ich nacheinander die 40 Trennschärfen aus, die ich in den Durchläufen der Schleife berechne; um die Seite nicht mit einer ausufernden Liste an Trennschärfen zu fluten, habe ich hier aber nur drei davon angezeigt. Um ein Objekt während des Laufs einer Schleife in der Konsole auszugeben, muss man <code>print</code> explizit auf das auszugebende Objekt aufrufen; das Objekt ohne <code>print</code> anzusteuern würde in keiner Reaktion resultieren.</p>
<p>Nun aber zur Logik des Codes: Vor dem Durchlauf der Schleife wähle ich genau die Spalten aus <code>npi_clean</code> aus, die die zuvor erstellten Item-Scores enthalten und speichere sie in der Variable <code>items</code> ab. Danach startet die Schleife. In diesem Beispiel habe ich die Schleifenvariable <code>column</code> genannt. Das war recht willkürlich – ich kann der Schleifenvariable jeden Namen geben, den ich möchte. Hier habe ich mich anders als im vorherigen Beispiel nicht für den Namen <code>i</code> entschieden, da die Schleifenvariable keine Indexvariable ist und keine Sequenz von ganzen Zahlen der Form <code>1:n</code> durchläuft. Stattdessen durchläuft sie einen Vektor, der die Spaltennamen enthält, auf die ich zugreifen möchte. Deswegen erschien mir der Variablenname <code>column</code> passend.</p>
<p>Der erste Befehl im Schleifenkörper berechnet einen Summenwert über 39 Items. Dabei wird jeweils das Item nicht berücksichtigt, das in der Spalte <code>name</code> des von <code>items</code> abgespeichert ist. Betrachtet den Code genau: Mithilfe der <code>[·,·]</code>-Notation werden genau die 39 anderen Spalten ausgewählt. Dafür wird hinter dem Komma der <code>[·,·]</code>-Notation ein logischer Vektor der Länge 40 übergeben, der nur an einer Stelle <code>FALSE</code> enthält und sonst <code>TRUE</code>. Dieser logische Vektor wurde mit dem Befehl <code>column != colnames(items)</code> erstellt.</p>
<p>Der zweite Befehl im Schleifenkörper berechnet die korrigierte Trennschärfe. Hier wird der Summenscore über 39 Items mit dem verbleibenden Item korreliert und der resultierende Korrelationskoeffizient wird in der Variablen <code>part_whole</code> abgespeichert. Der dritte Befehl gibt lediglich die Trennschärfe in der Konsole aus.</p>
</div>
<div id="datenspeicherung-in-einer-schleife" class="section level2">
<h2><span class="header-section-number">6.3</span> Datenspeicherung in einer Schleife</h2>
<p>Im vorherigen Beispiel habe ich Item-Trennschärfen berechnet und dann mit dem <code>print</code>-Befehl in der Konsole ausgegeben. Oftmals möchte ich die Ergebnisse von Berechnungen, die während einer Schleife anfallen, aber nicht nur ausgeben, sondern auch abspeichern. Im ersten Anwendungsbeispiel einer <code>for</code>-Schleife – Umkodierung von Items – hatten wir uns zunutze gemacht, dass man mit der <code>[[·]]</code>-Notation neue Spalten an an <code>data.frames</code> anhängen kann. Es macht jedoch keinen Sinn, die 40 Trennschärfen an den <code>data.frame</code> mit 10440 anzuhängen. Stattdessen könnte ich einen Vektor mit 40 Elementen zu erstellen, in dem ich die Trennschärfen speichere; ich berechne ja in jedem Durchlauf der Schleife genau einen Wert. Im Folgenden sehen wir uns an, wie wir das machen können. Dabei betrachten wir zwei Fälle: Einmal adressieren wir die Elemente des Vektors, der die Trennschärfen beinhaltet per Name und einmal per Index (siehe <a href="dataframes.html#nameindex">Kapitel 3.5</a>).</p>
<div id="adressierung-per-name" class="section level3">
<h3><span class="header-section-number">6.3.1</span> Adressierung per Name</h3>
<p>Zunächst erstelle ich wie folgt einen leeren<a href="#fn60" class="footnoteRef" id="fnref60"><sup>60</sup></a> Vektor der Länge 40:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">discriminations &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="dt">length =</span> <span class="dv">40</span>)</code></pre></div>
<p>Mithilfe der Funktion <code>vector</code><a href="#fn61" class="footnoteRef" id="fnref61"><sup>61</sup></a> erstelle ich einen Vektor; das Argument <code>length</code> bestimmt dabei die Länge des Vektors. Darin möchte ich im Verlauf der 40 Durchläufe der Schleife die Trennschärfen der 40 Items abspeichern. Um eine Adressierung per Name zu ermöglichen, gebe ich den Elementen des Vektors wie folgt Namen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(discriminations) &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="st">&quot;codedQ&quot;</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">40</span>)
## Teste:
discriminations[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>]</code></pre></div>
<pre><code>codedQ1 codedQ2 codedQ3 
  FALSE   FALSE   FALSE </code></pre>
<p>So haben die Elemente meines leeren Vektors dieselben Namen wie die Spalten des <code>data.frames</code> <code>items</code>, den ich zur Berechnung der Trennschärfen verwendet habe. Dass ich ausgerechnet diese Namen vergeben habe, hat zur Folge, dass ich recht einfach den obigen Code zur Berechnung der Trennschärfen umwandeln kann, um die Trennschärfen auch noch abzuspeichern. Dies ist der leicht angepasste Code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Wähle Items aus:
columns &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="st">&quot;codedQ&quot;</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">40</span>)
items &lt;-<span class="st"> </span>npi_clean[, columns]

## Erstelle leeren Vektor-Container und benenne ihn:
discriminations &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="dt">length =</span> <span class="dv">40</span>)
<span class="kw">names</span>(discriminations) &lt;-<span class="st"> </span>columns

<span class="cf">for</span> (column <span class="cf">in</span> columns) {
    <span class="co"># 1. Summenwert unter Ausschluss eines Items</span>
    scores &lt;-<span class="st"> </span><span class="kw">rowSums</span>(items[, column <span class="op">!=</span><span class="st"> </span><span class="kw">colnames</span>(items)])
    <span class="co"># 2. Korreliere damit den Item-Score</span>
    part_whole &lt;-<span class="st"> </span><span class="kw">cor</span>(items[[column]], scores)
    <span class="co"># 3. Speichere Trennschärfe ab</span>
    discriminations[column] &lt;-<span class="st"> </span>part_whole
}
## Voilá:
<span class="kw">head</span>(discriminations)</code></pre></div>
<pre><code>  codedQ1   codedQ2   codedQ3   codedQ4   codedQ5   codedQ6 
0.3558674 0.4201535 0.3321716 0.5012883 0.4414333 0.4790852 </code></pre>
</div>
<div id="vektorspeicherung-adressierung-per-index" class="section level3">
<h3><span class="header-section-number">6.3.2</span> Vektorspeicherung – Adressierung per Index</h3>
<p>Oftmals wird die Schleifenvariable als <em>Indexvariable</em> verwendet, d.h., sie durchläuft einen ganzzahligen numerischen Vektor, zumeist der Form <code>1:n</code>. So war es beispielsweise der Fall, als ich die 40 Items des NPI umkodiert habe. Diese Verwendung der Schleifenvariable ist oft dann nützlich, wenn ich in jedem Durchlauf der Schleife auf verschiedene Datenstrukturen zugreifen möchte – etwa auf einen <code>data.frame</code>, der Antworten enthält, und einen Vektor, der Schlüssel enthält. Da dieser Spezialfall wichtig ist, zeige ich auch für die Berechnung der Item-Trennschärfen, wie man die <code>for</code>-Schleife mit einer Index-Schleifenvariablen umsetzen kann:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Wähle Items aus:
columns &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="st">&quot;codedQ&quot;</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">40</span>)
items &lt;-<span class="st"> </span>npi_clean[, columns]

## Erstelle leeren Vektor-Container:
discriminations &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="dt">length =</span> <span class="dv">40</span>)

## Erstelle Index-Vektor:
indices &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">40</span>
## Berechne Trennschärfen in Schleife
<span class="cf">for</span> (i <span class="cf">in</span> indices) {
    <span class="co"># 1. Summenwert unter Ausschluss eines Items</span>
    scores &lt;-<span class="st"> </span><span class="kw">rowSums</span>(items[, indices[<span class="op">-</span>i]])
    <span class="co"># 2. Korreliere damit den Item-Score</span>
    part_whole &lt;-<span class="st"> </span><span class="kw">cor</span>(items[[i]], scores)
    <span class="co"># 3. Speichere Trennschärfe ab</span>
    discriminations[i] &lt;-<span class="st"> </span>part_whole
}
## Voilá:
<span class="kw">head</span>(discriminations)</code></pre></div>
<pre><code>[1] 0.3558674 0.4201535 0.3321716 0.5012883 0.4414333 0.4790852</code></pre>
<p>Hier wird die Index-Variable <code>i</code> gleich mehrfach verwendet: (1) zur Auswahl der Spalten, die den jeweiligen Testwert berechnen; (2) zur Auswahl der Spalte des Items, für das die Trennschärfe bestimmt wird; (3) zum Abspeichern der Trennschärfe im Vektor <code>discriminations</code>.</p>
</div>
</div>
<div id="for-loops-are-evil-oder-nicht" class="section level2">
<h2><span class="header-section-number">6.4</span> for-loops are evil – oder nicht?</h2>
<p>Inhalt folgt.</p>

</div>
</div>
<div class="footnotes">
<hr />
<ol start="59">
<li id="fn59"><p>Wer nach dem Durcharbeiten des Kapitels noch nicht genug von Schleifen hat, kann sich mithilfe einer Google-Suche mit der <code>while</code>-Schleife vertraut machen.<a href="schleifen.html#fnref59">↩</a></p></li>
<li id="fn60"><p>Tatsächlich ist der Vektor nicht wirklich leer. Schaut ihn euch einmal nach der Erstellung an (d.h., gebt ihn in der Konsole aus).<a href="schleifen.html#fnref60">↩</a></p></li>
<li id="fn61"><p>Es ist allgemein so, dass Funktionen mit dem Namen einer Datenstruktur besagte Datenstruktur erstellen. Erinnern wir uns an die Funktion <code>data.frame</code>. Ebenso gibt es die Funktion <code>list</code>, die eine Liste erstellt, oder die Funktion <code>matrix</code>, die eine Matrix erstellt. Diese Funktionen sind oft nützlich, um leere Datencontainer zu erstellen, die im Verlaufe einer <code>for</code>-Schleife gefüllt werden.<a href="schleifen.html#fnref61">↩</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="funktionen.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="simulationen.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
},
"search": false
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
